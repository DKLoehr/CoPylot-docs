\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

\begin{document}
  \section{Python Language Grammar}
  % This grammar is based on the AST defined in the python2_ast.ml file

  We use the convention that a symbol with a star above it is optional.

  \begin{grammar}
    \grule[variables]{\pvariable}{}
    \grule[suites]{\psuite}{\gtobrk \pstmt; \ldots \gtcbrk}
    \grule[statements]{\pstmt}{
                \gtdef \pvariable \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \gtclass \pvariable \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \gtreturn \pexpropt \gline
        \gor    \pexpr, \ldots \pexpr \gteq \pexpr \gline
        \gor    \pexpr \pbinop \gteq \pexpr \gline
        %I really don't care about print statements so I'm ignoring them
        \gor    \gtfor \pexpr \gtin \pexpr \gtcolon \psuite \gline
        \gor    \gtwhile \pexpr \gtcolon \psuite \gline
        \gor    \gtif \pexpr \gtcolon \psuite \gtelse \gtcolon \psuite \gline
        \gor    \gtraise \pexpropt, \pexpropt, \pexpropt \gline
        \gor    \gttry \gtcolon \psuite \gtobrk \pexcepthandler; \ldots \gtcbrk \gline
        \gor    \pexpr \gline
        \gor    \gtpass \gline
        \gor    \gtbreak \gline
        \gor    \gtcontinue \gline
    }
    \grule[expressions]{\pexpr}{
                \punop \pexpr \gline
        \gor    \pexpr \pbinop \pexpr \gline
        \gor    \pexpr \gtand \pexpr \gline
        \gor    \pexpr \gtor \pexpr \gline
        \gor    \pexpr \pcmpop \pexpr \pcmpop \ldots \pcmpop \pexpr \gline
        \gor    \pexpr \gtif \pexpr \gtelse \pexpr \gline
        \gor    \pexpr \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pnum \gline
        \gor    \mathbb{S} \gline
        \gor    \mathbb{B} \gline
        \gor    \pexpr.\pvariable \gline
        \gor    \pexpr \gtobrk \pslice \gtcbrk \gline
        \gor    \pvariable \gline
        \gor    \gtobrk \pexpr, \dots \gtcbrk \gline
        \gor    \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \gtNone \gline
    }
    \grule[unary operators]{\punop}{
                \gtuplus
           \gor \gtusub
           \gor \gtnot
    }
    \grule[binary operators]{\pbinop}{
                \gtplus
           \gor \gtsub
           \gor \gtmult
           \gor \gtdiv
           \gor \gtmod
           \gor \gtpow
    }
    \grule[comparison operators]{\pcmpop}{
                \gtiseq
           \gor \gtneq
           \gor \gtgeq
           \gor \gtleq
           \gor \gtge
           \gor \gtle
           \gor \gtis
           \gor \gtis \gtnot
           \gor \gtin
           \gor \gtnot \gtin
    }
    \grule[exception handlers]{\pexcepthandler}{
                \gtexcept \gtcolon \psuite \gline
           \gor \gtexcept \pexpr \gtcolon \psuite \gline
           \gor \gtexcept \pexpr \gtas \pexpr \gtcolon \psuite
    }
    \grule[slice]{\pslice}{
                \pexpr \gline
           \gor \pexpropt \gtcolon \pexpropt \gline
           \gor \pexpropt \gtcolon \pexpropt \gtcolon \pexpropt
    }
    \grule[numbers]{\pnum}{}
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
  \end{grammar}

  \section{Python Simplified Grammar}
  % This grammar is based on the AST defined in the python2_ast.ml file

  \begin{grammar}
    \grule[variables]{\pvariable}{}
    \grule[suites]{\psuite}{\gtobrk \pstmt; \ldots \gtcbrk}
    \grule[statements]{\pstmt}{
                \gtreturn \pexpr \gline
        \gor    \pvariable \gteq \pexpr \gline
        \gor    \gtwhile \pvariable \gtcolon \psuite \gline
        \gor    \gtif \pexpr \gtcolon \psuite \gtelse \gtcolon \psuite \gline
        \gor    \gtraise \pexpr \gline
        \gor    \gttry \gtcolon \psuite \gtexcept \pvariable \gtcolon \psuite \gline
        \gor    \gtpass \gline
        \gor    \gtbreak \gline
        \gor    \gtcontinue \gline
        \gor    \pexpr \gline
    }
    \grule[expressions]{\pexpr}{
                \punop \pexpr \gline
        \gor    \pexpr \pbinop \pexpr \gline
        \gor    \pexpr \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pexpr.\pvariable \gline
        \gor    \gtobrk \pexpr, \dots \gtcbrk \gline
        \gor    \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pnum \gline
        \gor    \mathbb{S} \gline
        \gor    \mathbb{B} \gline
        \gor    \pvariable \gline
        \gor    \gtfun \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \gtclass \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \pmagic
    }
    \grule[unary operators]{\punop}{
                \gtnot
    }
    \grule[binary operators]{\pbinop}{
                \gtis
    }
    \grule[numbers]{\pnum}{}
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
    \grule[magic builtins]{\pmagic}{
                \gtbool
           \gor \gtslice
           \gor \gtValueError
           \gor \gtAttributeError \gline
           \gor \gtTypeError
           \gor \gtStopIteration
    }
  \end{grammar}

\section{Python Simplification Process}

In the following rules, the expression ``\tfreshvar'' will indicate a fresh variable name.
Identical expressions in a single rule will all refer to the same variable name.

The left-hand side of each rule is in the Python language, while the right-hand side is
in the the Simplified language.

Additionally, for all $e_1$, we will define $S_{(e_1)}$ and $e_{(e_1)}$ to be such
that $\meaningof{e_1} = \gsLR{S_{(e_1)}, e_{(e_1)}}$. We may also use this notation
for slices.

\subsection{Statements}

\begin{mathpar}
  \translationRule{Suite (statement list)}{
    \gtobrk \pstmt_1, \ldots, \pstmt_n \gtcbrk
  }{
    \gtobrk \meaningof{\pstmt_1}, \ldots, \meaningof{\pstmt_n} \gtcbrk
  }{
  }
\end{mathpar}

\newsavebox{\funcDefBox}
\begin{lrbox}{\funcDefBox}
\begin{python}
$\pvariable$ = $\gtfun \gtopar \pvariable_0, \ldots, \pvariable_n \gtcpar$:
  $\meaningof{\psuite'}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Function Definition}{
    \gtdef \pvariable \gtopar \pexpr_0, \ldots, \pexpr_n \gtcpar \gtcolon \psuite
  }{
    \usebox{\funcDefBox}
  }{
    \mbox{where }
    \pexpr_i = \pvariable_i, \\
    \psuite' = \osFunc{add\_return}(\psuite)
  }
\end{mathpar}

\newsavebox{\classDefBox}
\begin{lrbox}{\classDefBox}
\begin{python}
$\psuite_{(e_0)}$
$\psuite_{(e_1  )}$
$\ldots$
$\psuite_{(e_n)}$
$\pvariable$ = $\gtclass \gtopar \pexpr_{(\pexpr_0)}, \ldots, \pexpr_{(\pexpr_n)} \gtcpar$:
  $\meaningof{\psuite'}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Class Definition}{
    \gtclass \pvariable \gtopar \pexpr_0, \ldots, \pexpr_n \gtcpar \gtcolon \psuite
  }{
    \usebox{\classDefBox}
  }{
  }
\end{mathpar}

\newsavebox{\returnBox}
\begin{lrbox}{\returnBox}
\begin{python}
$\psuite_{(\pexpr)}$
return $\pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Return Expression}{
    \gtreturn \pexpr
  }{
    \usebox{\returnBox}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\ereturnBox}
\begin{lrbox}{\ereturnBox}
\begin{python}
return $\mathtt{\star None}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Empty Return}{
    \gtreturn
  }{
    \usebox{\ereturnBox}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\multipleAssignmentBox}
\begin{lrbox}{\multipleAssignmentBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\tfreshvar = \pexpr_{(\pexpr)}$
$\meaningof{\pexpr_1 = \tfreshvar}$
...
$\meaningof{\pexpr_n = \tfreshvar}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Multiple Assignment}{
    \pexpr_1 \gteq \ldots \gteq \pexpr_n \gteq \pexpr
  }{
    \usebox{\multipleAssignmentBox}
  }{
    \mbox{where }
    n > 1
  }
\end{mathpar}

\newsavebox{\variableAssignmentBox}
\begin{lrbox}{\variableAssignmentBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\pvariable = \pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Variable Assignment}{
    \pvariable \gteq \pexpr
  }{
    \usebox{\variableAssignmentBox}
  }{
  }
\end{mathpar}

\newsavebox{\attributeAssignmentBox}
\begin{lrbox}{\attributeAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_2)}$
$\psuite_{(\pexpr_1)}$
$\pexpr_{(\pexpr_1)}$.__setattr__($s$, $\pexpr_{(\pexpr_2)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Attribute Assignment}{
    \pexpr_1.\pvariable \gteq \pexpr_2
  }{
    \usebox{\attributeAssignmentBox}
  }{
    \mbox{where }
    s = \osFunc{string\_of\_variable}(\pvariable)
  }
\end{mathpar}

\newsavebox{\sliceAssignmentBox}
\begin{lrbox}{\sliceAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_2)}$
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pslice)}$
$\pexpr_{(\pexpr_1)}$.__setitem__($\pexpr_{(\pslice)}$, $\pexpr_{(\pexpr_2)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Slice Assignment}{
    \pexpr_1 \gtobrk \pslice \gtcbrk \gteq \pexpr_2
  }{
    \usebox{\sliceAssignmentBox}
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{List Assignment}{
    \gtobrk \pexpr_1, \ldots, \pexpr_n \gtcbrk \gteq \pexpr
  }{
    \meaningof{\gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar \gteq \pexpr}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\tupleAssignmentBox}
\begin{lrbox}{\tupleAssignmentBox}
\begin{python}
$\tfreshvar$ = $\pexpr$.__iter__().next
try:
  $\tfreshvar_1$ = $\tfreshvar$()
  ...
  $\tfreshvar_n$ = $\tfreshvar$()

  try:
    $\tfreshvar$() # Should throw $\star$StopIteration
    raise $\star$ValueError, "too many elements to unpack"
  except $\star$StopIteration:
    pass

except $\star$StopIteration:
  raise $\star$ValueError, "too few elements to unpack"

$\pexpr_1$ = $\tfreshvar_1$
...
$\pexpr_n$ = $\tfreshvar_n$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Tuple Assignment}{
    \gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar \gteq \pexpr
  }{
    \left\llbracket\usebox{\tupleAssignmentBox}\right\rrbracket
  }{
    % No premises, surprisingly
  }
\end{mathpar}

TODO: The augmented assignment rules reflect the current code, but are wrong.
We also need to check for \_\_radd\_\_ and maybe some more stuff, and should throw a
TypeError if we can't figure out how to do the addition. Also, the value
expression should be evaluated first.
\newsavebox{\augmentedAssignmentBox}
\begin{lrbox}{\augmentedAssignmentBox}
\begin{python}
try:
  $\tfreshvar$ = $\pvariable$.iopFunc
except $\star$AttributeError:
  $\tfreshvar$ = $\pvariable$.opFunc
$\pvariable$ = $\tfreshvar$($\pexpr$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Variable Assignment}{
    \pvariable \pbinop \gteq \pexpr
  }{
    \left\llbracket\usebox{\augmentedAssignmentBox}\right\rrbracket
  }{
  \mbox{where }
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\augmentedAttributeAssignmentBox}
\begin{lrbox}{\augmentedAttributeAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\tfreshvar_1$ = $\pexpr_{(\pexpr_1)}$
try:
  $\tfreshvar_2$ = $\tfreshvar_1$.$\pvariable$.iopFunc
except AttributeError:
  $\tfreshvar_2$ = $\tfreshvar_1$.$\pvariable$.opFunc
$\tfreshvar_1$.$\pvariable$ = $\tfreshvar_2$($\pexpr_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Attribute Assignment}{
    \pexpr_1.\pvariable \pbinop \gteq \pexpr_2
  }{
    \left\llbracket\usebox{\augmentedAttributeAssignmentBox}\right\rrbracket
  }{
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\augmentedSliceAssignmentBox}
\begin{lrbox}{\augmentedSliceAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pslice)}$
$\tfreshvar_1$ = $\pexpr_{(\pexpr_1)}$
$\tfreshvar_2$ = $\pexpr_{(\pslice)}$
try:
  $\tfreshvar_3$ = $\tfreshvar_1$[$\tfreshvar_2$].iopFunc
except AttributeError:
  $\tfreshvar_3$ = $\tfreshvar_1$[$\tfreshvar_2$].opFunc
$\tfreshvar_1$[$\tfreshvar_2$] = $\tfreshvar_3$($\pexpr_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Slice Assignment}{
    \pexpr_1 \gtobrk \pslice \gtcbrk \pbinop \gteq \pexpr_2
  }{
    \left\llbracket\usebox{\augmentedSliceAssignmentBox}\right\rrbracket
  }{
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\forBox}
\begin{lrbox}{\forBox}
\begin{python}
$\tfreshvar$ = $\pexpr_2$.__iter__().next
try:
  while $\star$True:
    $\pexpr_1$ = $\tfreshvar$()
    $\psuite$
except $\star$StopIteration:
  pass
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{For loop}{
    \gtfor \pexpr_1 \gtin \pexpr_2 \gtcolon \psuite
  }{
    \left\llbracket\usebox{\forBox}\right\rrbracket
  }{
  }
\end{mathpar}

\newsavebox{\whileBox}
\begin{lrbox}{\whileBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\tfreshvar$ = $\star$bool($\pexpr_{(\pexpr)}$)
while $\tfreshvar$:
  $\meaningof{\psuite}$
  $\psuite_{(\pexpr)}$
  $\tfreshvar$ = $\star$bool($\pexpr_{(\pexpr)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{While loop}{
    \gtwhile \pexpr \gtcolon \psuite
  }{
    \usebox{\whileBox}
  }{
  }
\end{mathpar}

\newsavebox{\ifBox}
\begin{lrbox}{\ifBox}
\begin{python}
$\psuite_{(\pexpr)}$
if $\star$bool($\pexpr_{(\pexpr)}$):
  $\meaningof{\psuite_1}$
else:
  $\meaningof{\psuite_2}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{If statement}{
    \gtif \pexpr \gtcolon \psuite_1 \gtelse \gtcolon \psuite_2
  }{
    \usebox{\ifBox}
  }{
  }
\end{mathpar}

\newsavebox{\raiseBox}
\begin{lrbox}{\raiseBox}
\begin{python}
$\psuite_{(\pexpr)}$
raise $\pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Raise statement}{
    \gtraise \pexpr
  }{
    \usebox{\raiseBox}
  }{
  }
\end{mathpar}

\newsavebox{\tryBox}
\begin{lrbox}{\tryBox}
\begin{python}
try:
  $\meaningof{\psuite}$
except $\tfreshvar$:
  $\meaningof{\gtobrk \pexcepthandler_1; \ldots; \pexcepthandler_n \gtcbrk}_{\tfreshvar}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Try/Except statement}{
    \gttry \gtcolon \psuite \gtobrk \pexcepthandler_1; \ldots; \pexcepthandler_n \gtcbrk
  }{
    \usebox{\tryBox}
  }{
  }
\end{mathpar}

\newsavebox{\passBox}
\begin{lrbox}{\passBox}
\begin{python}
pass
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Pass statement}{
    \gtpass
  }{
    \usebox{\passBox}
  }{
  }
\end{mathpar}

\newsavebox{\breakBox}
\begin{lrbox}{\breakBox}
\begin{python}
break
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Break statement}{
    \gtbreak
  }{
    \usebox{\breakBox}
  }{
  }
\end{mathpar}

\newsavebox{\continueBox}
\begin{lrbox}{\continueBox}
\begin{python}
continue
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Continue statement}{
    \gtcontinue
  }{
    \usebox{\continueBox}
  }{
  }
\end{mathpar}

\subsection{Expressions}

We will use the convention that $\left<\psuite, \meaningof{\pexpr}\right>$ is to be interpreted as
$\left<\psuite || \psuite_{(\pexpr)}, \pexpr_{(\pexpr)}\right>$.

\newsavebox{\andBox}
\begin{lrbox}{\andBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\tfreshvar$ = $\pexpr_{(\pexpr_1)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Boolean expression (And)}{
    \pexpr_1 \gtand \pexpr_2
  }{
    \left<\usebox{\andBox}\hspace{25pt},
    \meaningof{\pexpr_2 \gtif \tfreshvar \gtelse \tfreshvar}\right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Boolean expression (Or)}{
    \pexpr_1 \gtor \pexpr_2
  }{
    \left<\usebox{\andBox}\hspace{25pt},
    \meaningof{\tfreshvar \gtif \tfreshvar \gtelse \pexpr_2}\right>
  }{
  }
\end{mathpar}

TODO: Stuff like \_\_radd\_\_ if $\pexpr_1$ doesn't have an appropriate function, etc

\newsavebox{\binopBox}
\begin{lrbox}{\binopBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pexpr_2)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Binary Operation}{
    \pexpr_1 \pbinop \pexpr_2
  }{
    \left<\usebox{\binopBox}\hspace{25pt}, \pexpr_{(\pexpr_1)}.\mathtt{opFunc}(\pexpr_{(\pexpr_2)}) \right>
  }{
  \mbox{where }
  \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop)
  }
\end{mathpar}

\newsavebox{\notBox}
\begin{lrbox}{\notBox}
\begin{python}
$\psuite_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (not)}{
    \gtnot \pexpr
  }{
    \left<\usebox{\notBox}\hspace{20pt}, \gtnot (\star\gtbool(\pexpr_{(\pexpr)}))\right>
  }{
  }
\end{mathpar}

\newsavebox{\uplusBox}
\begin{lrbox}{\uplusBox}
\begin{python}
$\psuite_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (+)}{
    \gtuplus \pexpr
  }{
    \left<\usebox{\uplusBox}\hspace{20pt}, \pexpr_{(\pexpr)}.\mathtt{\_\_pos\_\_}() \right>
  }{
  }
\end{mathpar}

\newsavebox{\usubBox}
\begin{lrbox}{\usubBox}
\begin{python}
$\psuite_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (-)}{
    \gtusub \pexpr
  }{
    \left<\usebox{\usubBox}\hspace{20pt}, \pexpr_{(\pexpr)}.\mathtt{\_\_neg\_\_}() \right>
  }{
  }
\end{mathpar}

\newsavebox{\ifExpBox}
\begin{lrbox}{\ifExpBox}
\begin{python}
$\psuite_{(\pexpr_2)}$
if $\star$bool($\pexpr_{(\pexpr_2)}$):
  $\psuite_{(\pexpr_1)}$
  $\tfreshvar$ = $\pexpr_{(\pexpr_1)}$
else:
  $\psuite_{(\pexpr_3)}$
  $\tfreshvar$ = $\pexpr_{(\pexpr_3)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{If expression}{
    \pexpr_1 \gtif \pexpr_2 \gtelse \pexpr_3
  }{
    \left< \usebox{\ifExpBox}\hspace{30pt}, \tfreshvar \right>
  }{
  }
\end{mathpar}

\newsavebox{\compareBox}
\begin{lrbox}{\compareBox}
\begin{python}
$\meaningof{\tfreshvar_1 = \pexpr_1}$
$\meaningof{\tfreshvar_2 = \pexpr_2}$
$\tfreshvar_3$ = $\tfreshvar_1.\mathtt{opFunc}(\tfreshvar_2)$
\end{python}
\end{lrbox}

TODO: Look for comparison functions on both sides, maybe?

\begin{mathpar}
  \translationRule{Comparison operator}{
    \pexpr_1 \pcmpop_1 \pexpr_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n
  }{
    \left< \usebox{\compareBox}\hspace{30pt},
    \meaningof{(\tfreshvar_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n) \gtif
    \tfreshvar_3 \gtelse \tfreshvar_3} \right>
  }{
    \mbox{where } \pcmpop_1 \mbox { is not } \gtis, \gtis \gtnot,\mbox{ or } \gtnot \gtin,
    \mathtt{opFunc} = \osFunc{cpmop\_to\_func}(\pbinop)
  }
\end{mathpar}

\newsavebox{\compareIsBox}
\begin{lrbox}{\compareIsBox}
\begin{python}
$\meaningof{\tfreshvar_1 = \pexpr_1}$
$\meaningof{\tfreshvar_2 = \pexpr_2}$
$\tfreshvar_3$ = $\tfreshvar_1 \gtis \tfreshvar_2$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Comparison operator (is)}{
    \pexpr_1 \gtis \pexpr_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n
  }{
    \left< \usebox{\compareIsBox}\hspace{30pt},
    \meaningof{(\tfreshvar_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n) \gtif
    \tfreshvar_3 \gtelse \tfreshvar_3} \right>
  }{
  }
\end{mathpar}

\newsavebox{\compareIsNotBox}
\begin{lrbox}{\compareIsNotBox}
\begin{python}
$\meaningof{\tfreshvar_1 = \pexpr_1}$
$\meaningof{\tfreshvar_2 = \pexpr_2}$
$\tfreshvar_3$ = $\gtnot$($\tfreshvar_1 \gtis \tfreshvar_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Comparison operator (is not)}{
    \pexpr_1 (\gtis \gtnot) \pexpr_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n
  }{
    \left< \usebox{\compareIsNotBox}\hspace{30pt},
    \meaningof{(\tfreshvar_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n) \gtif
    \tfreshvar_3 \gtelse \tfreshvar_3} \right>
  }{
  }
\end{mathpar}

\newsavebox{\callBox} % No, not the blue one
\begin{lrbox}{\callBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\psuite_{(\pexpr_1)}$
...
$\psuite_{(\pexpr_n)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Function call}{
    \pexpr \gtopar \pexpr_1, \ldots \pexpr_n \gtcpar
  }{
    \left< \usebox{\callBox}\hspace{10pt},
    \pexpr_{(\pexpr)}(\pexpr_{(\pexpr_1)}, \ldots, \pexpr_{(\pexpr_n)}) \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Attribute access}{
    \pexpr.\pvariable
  }{
    \left< \psuite_{(\pexpr)} , \pexpr_{(\pexpr)}.\pvariable \right>
  }{
  }
\end{mathpar}

\newsavebox{\listAccessBox}
\begin{lrbox}{\listAccessBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\psuite_{(\pslice)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Subscript}{
    \pexpr \gtobrk \pslice \gtcbrk
  }{
    \left< \usebox{\listAccessBox}\hspace{20pt},
    \pexpr_{(\pexpr)}.\mathtt{\_\_getitem\_\_} ( \pexpr_{(\pslice)} )
    \right>
  }{
  }
\end{mathpar}

\newsavebox{\listBox}
\begin{lrbox}{\listBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
...
$\psuite_{(\pexpr_n)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{List expression}{
    \gtobrk \pexpr_1, \ldots, \pexpr_n \gtcbrk
  }{
    \left< \usebox{\listBox}\hspace{5pt}, \gtobrk \pexpr_{(\pexpr_1)}, \ldots, \pexpr_{(\pexpr_n)} \gtcbrk \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Tuple expression}{
    \gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar
  }{
    \left< \usebox{\listBox}\hspace{5pt}, \gtopar \pexpr_{(\pexpr_1)}, \ldots, \pexpr_{(\pexpr_n)} \gtcpar \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{None expression}{
    \gtNone
  }{
    \left< \gtobrk \gtcbrk , \mathtt{\star None} \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Literal expression}{
    \pexpr
  }{
    \left< \gtobrk \gtcbrk , \pexpr \right>
  }{
    \mbox{where } \pexpr \mbox{ is a number, string, boolean or identifier}
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Slice (index)}{
    \pslice
  }{
    \left< \gtobrk \gtcbrk , \meaningof{\pexpr} \right>
  }{
    \mbox{where} \pslice \gteq \pexpr
  }
\end{mathpar}

\subsection{Other forms}

\newsavebox{\sliceBox}
\begin{lrbox}{\sliceBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pexpr_2)}$
$\psuite_{(\pexpr_3)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Slice (slice)}{
    \pexpr_1 \gtcolon \pexpr_2 \gtcolon \pexpr_3
  }{
    \left< \usebox{\sliceBox}\hspace{20pt},
    \star\mathtt{slice}(\pexpr_{(\pexpr_1)}, \pexpr_{(\pexpr_2)}, \pexpr_{(\pexpr_3)}) \right>
  }{
    \mbox{where } \psuite_{(\pexpr_i)} \mbox{ is empty and } \pexpr_{(\pexpr_i)}
    \mbox{ is } \mathtt{*None} \mbox{ if } \pexpr_i \mbox{ is omitted}
  }
\end{mathpar}

\newsavebox{\exnBox}
\begin{lrbox}{\exnBox}
\begin{python}
if(True):
  $\meaningof{\psuite}$
else:
  $\meaningof{\gtobrk \pexcepthandler_2; \ldots; \pexcepthandler_n \gtcbrk}_{\pvariable}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Exception handler list}{
    \gtobrk (\gtexcept \gtcolon \psuite); \pexcepthandler_2; \ldots; \pexcepthandler_n \gtcbrk _{\pvariable}
  }{
    \usebox{\exnBox}
  }{
    \mbox{where } n > 0
  }
\end{mathpar}

\newsavebox{\exnBoxTwo}
\begin{lrbox}{\exnBoxTwo}
\begin{python}
$\psuite_{(\pexpr)}$
if $\tfreshvar$.__class__ is $\pexpr_{(\pexpr)}$:
  $\meaningof{\psuite}$
else:
  $\meaningof{\gtobrk \pexcepthandler_2; \ldots; \pexcepthandler_n \gtcbrk}_{\pvariable}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Exception handler list}{
    \gtobrk (\gtexcept \pexpr \gtcolon \psuite); \pexcepthandler_2; \ldots; \pexcepthandler_n \gtcbrk _{\pvariable}
  }{
    \usebox{\exnBoxTwo}
  }{
    \mbox{where } n > 0
  }
\end{mathpar}

\newsavebox{\exnBoxThree}
\begin{lrbox}{\exnBoxThree}
\begin{python}
$\psuite_{(\pexpr)}$
if $\pvariable$.__class__ is $\pexpr_{(\pexpr)}$:
  $\pvariable_1$ = $\pvariable$
  $\meaningof{\psuite}$
else:
  $\meaningof{\gtobrk \pexcepthandler_2; \ldots; \pexcepthandler_n \gtcbrk}_{\pvariable}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Exception handler list}{
    \gtobrk (\gtexcept \pexpr \gtas \pvariable_1 \gtcolon \psuite);
    \pexcepthandler_2; \ldots; \pexcepthandler_n \gtcbrk _{\pvariable}
  }{
    \usebox{\exnBoxThree}
  }{
    \mbox{where } n > 0
  }
\end{mathpar}

\newsavebox{\exnBoxEmpty}
\begin{lrbox}{\exnBoxEmpty}
\begin{python}
raise $\pvariable$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Exception handler list}{
    \gtobrk  \gtcbrk _{\pvariable}
  }{
    \usebox{\exnBoxEmpty}
  }{
  }
\end{mathpar}

\subsection{Helper function definitions}
\begin{definition}[Binary Operators]
  \begin{flalign*}
  \begin{array}[t]{ c | c c }
   \pbinop & \osFunc{Binop\_to\_func}(\pbinop) & \osFunc{Binop\_to\_ifunc}(\pbinop) \\
   \hline
   \gtplus & \_\_add\_\_ & \_\_iadd\_\_ \\
   \gtsub & \_\_sub\_\_ & \_\_isub\_\_ \\
   \gtmult & \_\_mul\_\_ & \_\_imul\_\_ \\
   \gtdiv & \_\_div\_\_ & \_\_idiv\_\_ \\
   \gtmod & \_\_mod\_\_ & \_\_imod\_\_ \\
   \gtpow & \_\_pow\_\_ & \_\_ipow\_\_ \\
  \end{array}
  \end{flalign*}
\end{definition}

\begin{definition}[Comparison Operators]
  \begin{flalign*}
  \begin{array}[t]{ c | c c }
   \pbinop & \osFunc{Cmpop\_to\_func}(\pbinop) \\
   \hline
   \gteq & \_\_eq\_\_ \\
   \gtneq & \_\_ne\_\_ \\
   \gtle & \_\_lt\_\_ \\
   \gtleq & \_\_le\_\_ \\
   \gtge & \_\_gt\_\_ \\
   \gtgeq & \_\_ge\_\_ \\
   \gtin & \_\_contains\_\_ \\
  \end{array}
  \end{flalign*}
\end{definition}

\begin{definition}[Comparison Operators]
  \begin{flalign*}
  \osFunc{Add\_Return}(\psuite) = \psuite || \gtobrk \gtreturn \gtNone \gtcbrk
  \end{flalign*}
\end{definition}

\section{Normalized Python Grammar}
\begin{grammar}
  \grule[variables]{\pvariable}{}
  \grule[suites]{\psuite}{\gtobrk \pstmt; \ldots \gtcbrk}
  \grule[statements]{\pstmt}{
              \gtreturn \pvariable \gline
      \gor    \pvariable \gteq \pexpr \gline
      \gor    \gtwhile \pvariable \gtcolon \psuite \gline
      \gor    \gtif \pvariable \gtcolon \psuite \gtelse \gtcolon \psuite \gline
      \gor    \gtraise \pvariable \gline
      \gor    \gttry \gtcolon \psuite \gtexcept \pvariable \gtcolon \psuite \gline
      \gor    \gtpass \gline
      \gor    \gtbreak \gline
      \gor    \gtcontinue \gline
  }
  \grule[expressions]{\pexpr}{
              \punop \pvariable \gline
      \gor    \pvariable \pbinop \pvariable \gline
      \gor    \pvariable \gtopar \pvariable, \dots \gtcpar \gline
      \gor    \pvariable.\pvariable \gline
      \gor    \gtobrk \pvariable, \dots \gtcbrk \gline
      \gor    \gtopar \pvariable, \dots \gtcpar \gline
      \gor    \pnum \gline
      \gor    \mathbb{S} \gline
      \gor    \mathbb{B} \gline
      \gor    \pvariable \gline
      \gor    \gtfun \gtopar \pvariable, \ldots \gtcpar \gtcolon \psuite \gline
      \gor    \gtclass \gtopar \pvariable, \ldots \gtcpar \gtcolon \psuite \gline
      \gor    \pmagic
  }
  \grule[unary operators]{\punop}{
              \gtnot
  }
  \grule[binary operators]{\pbinop}{
              \gtis
  }
  \grule[numbers]{\pnum}{}
  \grule[strings]{\mathbb{S}}{}
  \grule[booleans]{\mathbb{B}}{
              \ostrue
      \gor    \osfalse
  }
  \grule[magic builtins]{\pmagic}{
              \gtbool
         \gor \gtslice
         \gor \gtValueError
         \gor \gtAttributeError \gline
         \gor \gtTypeError
         \gor \gtStopIteration
  }
\end{grammar}

The translation process from Simplified to Normalized Python is standard A-normalization.
It is entirely unremarkable in every way, so we omit it.

\section{Lamia Language Grammar}

\begin{grammar}
  \grule[labels]{\olbl}{}
  \grule[value variables]{\ovalvariable}{}
  \grule[memory variables]{\omemvariable}{}
  \grule[blocks]{\ostmts}{
              \ostmt \gtsemi \ldots
  }
  \grule[statements]{\ostmt}{
              \olbl \gtcolon \odirective
  }
  \grule[blocks]{\otstmts}{
              \otstmt \gtsemi \ldots
  }
  \grule[statements]{\otstmt}{
              \odirective \text{ such that all \ostmts \, are replaced with \otstmts}
      \gor    \gtobrc \osBlock{while} \gtcbrc
      % \gor    \gtobrc \osBlock{try} \gtcbrc
      \gline
      \gor    \gtobrc \osBlock{if} \gtcbrc
      \gor    \gtlet \omemvariable \gteq \gtobrc \osBlock{fun} \gtcbrc
  }
  \grule[directive]{\odirective}{
              \gtlet \ovalvariable \gteq \oexpr \gline
      \gor    \gtlet \omemvariable \gteq \gtalloc \gline
      % \gor    \gtlet \ovalvariable \gteq \gtmethodbind \omemvariable \; \ovalvariable \gline
      \gor    \gtlet \ovalvariable \gteq \ovalvariable \gline
      \gor    \gtlet \omemvariable \gteq \omemvariable \gline
      \gor    \gtlet \ovalvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtarrow \omemvariable \gtcbrc \gline
      \gor    \gtlet \omemvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtcbrc \gline
      \gor    \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable \gtcomma \ldots \gtcpar \gline
      \gor    \gtlet \omemvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcbrk \gline
      \gor    \gtlet \ovalvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcolon \ovalvariable \gtcbrk \gline
      \gor    \gtstore \omemvariable\ \ovalvariable \gline
      \gor    \gtlet \ovalvariable \gteq \gtget \omemvariable \gline
      \gor    \gtlet \ovalvariable \gteq \omemvariable \gtis \omemvariable \gline
      \gor    \gtlet \ovalvariable \gteq \ounop \ovalvariable \gline
      \gor    \gtlet \ovalvariable \gteq \ovalvariable \obinop \ovalvariable \gline
      \gor    \gtifresult \ovalvariable \gline
      \gor    \gtifresult \omemvariable \gline
      \gor    \gtreturn \omemvariable \gline
      \gor    \gtraise \omemvariable \gline
      \gor    \gttry \gtobrc \ostmts \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts \gtcbrc \gline
      \gor    \gtlet \ovalvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts \gtcbrc \gtelse \gtobrc \ostmts \gtcbrc \gline
      \gor    \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts \gtcbrc \gtelse \gtobrc \ostmts \gtcbrc \gline
      \gor    \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc
  }
  \grule[unary operators]{\ounop}{
              \gtnot
      \gor    \gtisfunc
      \gor    \gtisint
      \gor    \gtisbool
  }
  \grule[binary operators]{\obinop}{
              \gtintplus
      \gor    \gtintminus
      % \gor    \gtand
      % \gor    \gtor
      \gor    \gthaskey
      \gor    \gtlstconcat
      \gor    \gtcmp
  }
  \grule[value expressions]{\oexpr}{
              \mathbb{Z}
      \gor    \mathbb{S}
      \gor    \mathbb{B}
      \gor    \gtdef \gtopar \ovalvariable, \ldots \gtcpar \gtobrc \ostmts \gtcbrc
      \gor    \gtobrk \omemvariable, \ldots \gtcbrk
      \gor    \gtobrk \omemvariable, \ldots \gtcpar
      \gor    \gtobrc \gtcbrc
      \gor    \osnone
  }
  \grule[strings]{\mathbb{S}}{}
  \grule[booleans]{\mathbb{B}}{
              \ostrue
      \gor    \osfalse
  }
  \grule[heap]{\oheap}{
              \gtobrc \ovalvariable \mapsto \ovalue, \ldots \gtcbrc
      \cup    \gtobrc \omemvariable \mapsto \omem, \ldots \gtcbrc
      \cup    \gtobrc \omem \mapsto \ovalue, \ldots \gtcbrc
  }
\end{grammar}

\section{Normalized to Lamia Translation}

Whenever a statement $s$ involves a function returning a tuple of $<\psuite, \pexpr>$ we
replace it with $\psuite || [s']$, where $s'$ is $s$ but with the function call replaced by $\pexpr$.

If a statement contains multiple such function calls, we replace them in order from left-to-right.

Furthermore, we define $<\psuite, \pexpr>$ to mean $<\psuite || \psuite', \pexpr'>$ whenever\\
$\meaningof{\pexpr} = <\psuite', \pexpr'>$. This is ok because eventually the expression will become simple
enough that $\meaningof{\pexpr} = <\gtobrk \gtcbrk, \pexpr>$

\subsection{Blocks}

\begin{mathpar}
  \translationRule{Entire program}{
    \gtobrk \pstmt_1, \ldots, \pstmt_n \gtcbrk
  }{
    \osFunc{preamble}()\ \listConcat \gtobrk \meaningof{\pstmt_1}, \ldots, \meaningof{\pstmt_n} \gtcbrk
  }{
    \mbox{where } \gtobrk \pstmt_1, \ldots, \pstmt_n \gtcbrk \mbox{ is at the top level}
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Subordinate blocks}{
    \gtobrk \pstmt_1, \ldots, \pstmt_n \gtcbrk
  }{
    \gtobrk \meaningof{\pstmt_1}, \ldots, \meaningof{\pstmt_n} \gtcbrk
  }{
    \mbox{where } \gtobrk \pstmt_1, \ldots, \pstmt_n \gtcbrk \mbox{ is not at the top level}
  }
\end{mathpar}

\subsection{Statements}

\newsavebox{\lamiaAsgnBox}
\begin{lrbox}{\lamiaAsgnBox}
\begin{python}
$\osFunc{Python\_assign}$($\pvariable$, $\meaningof{\pexpr}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Variable assignment}{
    \pvariable \gteq \pexpr
  }{
    \usebox{\lamiaAsgnBox}
  }{
  }
\end{mathpar}

\newsavebox{\lamiaRetBox}
\begin{lrbox}{\lamiaRetBox}
\begin{python}
return $\osFunc{Lookup}$($\pvariable$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Return statement}{
    \gtreturn \pvariable
  }{
    \usebox{\lamiaRetBox}
  }{
  }
\end{mathpar}

\newsavebox{\lamiaWhileBox}
\begin{lrbox}{\lamiaWhileBox}
\begin{python}
let $\tfreshmem$ = alloc
let $\tfreshval$ = $\osFunc{Lookup}$($\pvariable$) is $\star$True
store $\tfreshmem$ $\tfreshval$
while $\tfreshmem$ do {
  $\meaningof{\psuite}$
  let $\tfreshval$ = $\osFunc{Lookup}$($\pvariable$) is $\star$True
  store $\tfreshmem$ $\tfreshval$
}
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{While loop}{
    \gtwhile \pvariable \gtcolon \psuite
  }{
    \usebox{\lamiaWhileBox}
  }{
  }
\end{mathpar}

\newsavebox{\lamiaIfBox}
\begin{lrbox}{\lamiaIfBox}
\begin{python}
$\gtlet$ $\tfreshval_1$ = $\osFunc{Lookup}$($\pvariable$) is True
$\gtlet$ $\tfreshval_2$ =
  $\gtif$ $\tfreshval_1$ $\gtthen$ {
    $\meaningof{\psuite_1}$
    $\gtlet$ $\tfreshval_3$ = $\star$None
    $\gtifresult$ $\tfreshval_3$
  } $\gtelse$ {
    $\meaningof{\psuite_2}$
    $\gtlet$ $\tfreshval_3$ = $\star$None
    $\gtifresult$ $\tfreshval_3$
  }
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{If statement}{
    \gtif \pvariable \gtthen \gtcolon \psuite_1 \gtelse \gtcolon \psuite_2
  }{
    \usebox{\lamiaIfBox}
  }{
  }
\end{mathpar}

\newsavebox{\lamiaRaiseBox}
\begin{lrbox}{\lamiaRaiseBox}
\begin{python}
raise $\osFunc{Lookup}$($\pvariable$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Raise statement}{
    \gtraise \pvariable
  }{
    \usebox{\lamiaRaiseBox}
  }{
  }
\end{mathpar}

\newsavebox{\lamiaTryBox}
\begin{lrbox}{\lamiaTryBox}
\begin{python}
$\gttry$ {
  $\meaningof{\psuite_1}$
} $\gtexcept$ $\tfreshmem$ {
  $\osFunc{Python\_assign}$($\pvariable$, $\tfreshmem$)
  $\meaningof{\psuite_2}$
}
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Try/Except block}{
    \gttry \gtcolon \psuite_1 \gtexcept \pvariable \gtcolon \psuite_2
  }{
    \usebox{\lamiaTryBox}
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Pass statement}{
    \gtpass
  }{
    \gtobrk \gtcbrk
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Break statement}{
    \gtbreak
  }{
    \mbox{Not yet implemented}
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Continue statement}{
    \gtcontinue
  }{
    \mbox{Not yet implemented}
  }{
  }
\end{mathpar}

\subsection{Expressions}

\newsavebox{\lamiaUnopBox}
\begin{lrbox}{\lamiaUnopBox}
\begin{python}
$\gtlet$ $\tfreshval_1$ = $\osFunc{lookup\_and\_get\_attr}$("$\star$value", $\pvariable$)
$\gtlet$ $\tfreshval_2$ = $\gtnot$ $\tfreshval_1$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (not)}{
    \gtnot \pvariable
  }{
    \left<
    \usebox{\lamiaUnopBox}\hspace{120pt},
    \meaningof{\osFunc{wrap\_bool}(\tfreshval_2)}
    \right>
  }{
  }
\end{mathpar}

\newsavebox{\lamiaBinopBox}
\begin{lrbox}{\lamiaBinopBox}
\begin{python}
$\gtlet$ $\tfreshval$ = $\osFunc{Lookup}$($\pvariable_1$) is $\osFunc{Lookup}$($\pvariable_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Binary Operation (is)}{
    \pvariable_1 \gtis \pvariable_2
  }{
    \left<
    \usebox{\lamiaBinopBox}\hspace{100pt},
    \meaningof{\osFunc{wrap\_bool}(\tfreshval)}
    \right>
  }{
  }
\end{mathpar}

\newsavebox{\lamiaCallBox}
\begin{lrbox}{\lamiaCallBox}
\begin{python}
$\gtlet$ $\tfreshmem_1$ = $\osFunc{Lookup}(\pvariable)$
$\gtlet$ $\tfreshval_1$ = [$\osFunc{Lookup}(\pvariable_1)$, ..., $\osFunc{Lookup}(\pvariable_n)$]
$\gtlet$ $\tfreshval_2$ = $\osFunc{Get\_call}(\tfreshmem_1)$
$\gtlet$ $\tfreshmem_2$ = $\tfreshval_2$($\tfreshval_1$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Function Call}{
    \pvariable \gtopar \pvariable_1, \ldots, \pvariable_n \gtcpar
  }{
    \left<
    \usebox{\lamiaCallBox}\hspace{120pt},
    \tfreshmem_2
    \right>
  }{
  }
\end{mathpar}

\newsavebox{\lamiaAttrBox}
\begin{lrbox}{\lamiaAttrBox}
\begin{python}
TODO: I cry evertim
\end{python}
\end{lrbox}

NOTE: This rule will change significantly when we add inheritance
\begin{mathpar}
  \translationRule{Attribute access}{
    \pvariable_1.\pvariable_2
  }{
    \left<
    \usebox{\lamiaAttrBox}
    \right>
  }{
  }
\end{mathpar}

\newsavebox{\lamiaListBox}
\begin{lrbox}{\lamiaListBox}
\begin{python}
$\gtlet$ $\tfreshvar$ = [$\osFunc{Lookup}(\pvariable_1)$, ..., $\osFunc{Lookup}(\pvariable_n)$]
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{List value}{
    \gtobrk \pvariable_1, \ldots, \pvariable_n \gtcbrk
  }{
    \left<
    \usebox{\lamiaListBox}\hspace{120pt},
    \osFunc{wrap\_list}(\tfreshvar)
    \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Tuple value}{
    \gtopar \pvariable_1, \ldots, \pvariable_n \gtcpar
  }{
    \left<
    \usebox{\lamiaListBox}\hspace{120pt},
    \osFunc{wrap\_tuple}(\tfreshvar)
    \right>
  }{
  }
\end{mathpar}

\newsavebox{\lamiaIntBox}
\begin{lrbox}{\lamiaIntBox}
\begin{python}
$\gtlet$ $\tfreshvar$ = $n$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Integer literal}{
    n
  }{
    \left<
    \usebox{\lamiaIntBox}\hspace{30pt},
    \osFunc{wrap\_int}(\tfreshvar)
    \right>
  }{
    \mbox{where } n \mbox{ is an integer}
  }
\end{mathpar}

\newsavebox{\lamiaFloatBox}
\begin{lrbox}{\lamiaFloatBox}
\begin{python}
$\gtlet$ $\tfreshvar$ = $f$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Float literal}{
    f
  }{
    \left<
    \usebox{\lamiaFloatBox}\hspace{30pt},
    \osFunc{wrap\_float}(\tfreshvar)
    \right>
  }{
    \mbox{where } f \mbox{ is a float}
  }
\end{mathpar}

\newsavebox{\lamiaStrBox}
\begin{lrbox}{\lamiaStrBox}
\begin{python}
$\gtlet$ $\tfreshvar$ = $t$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{String literal}{
    t
  }{
    \left<
    \usebox{\lamiaStrBox}\hspace{30pt},
    \osFunc{wrap\_str}(\tfreshvar)
    \right>
  }{
    \mbox{where } t \mbox{ is a string}
  }
\end{mathpar}

\newsavebox{\lamiaBoolBox}
\begin{lrbox}{\lamiaBoolBox}
\begin{python}
$\gtlet$ $\tfreshvar$ = $b$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Boolean literal}{
    b
  }{
    \left<
    \usebox{\lamiaBoolBox}\hspace{30pt},
    \osFunc{wrap\_bool}(\tfreshvar)
    \right>
  }{
    \mbox{where } b \mbox{ is a boolean}
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Name}{
    \pvariable
  }{
    \left<
    \gtobrk \gtcbrk, \osFunc{Lookup}(\pvariable)
    \right>
  }{
    % No premises
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Builtin name}{
    \star\pvariable
  }{
    \left<
    \gtobrk \gtcbrk,
    \osFunc{builtin\_memloc}(\star\pvariable)
    \right>
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\lamiaFuncBox}
\begin{lrbox}{\lamiaFuncBox}
\begin{python}
$\gtlet$ $\tfreshval_1$ = $\gtdef$($\tfreshval_2$) { $\osFunc{Convert\_func\_body}$($\psuite$, $\tfreshval_2$, ($\pvariable_1, \ldots, \pvariable_n$)) }
$\gtlet$ $\tfreshmem$ = alloc
$\gtstore$ $\tfreshmem$ $\tfreshval_1$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Function Value}{
    \gtfun (\pvariable_1, \ldots, \pvariable_n) \gtcolon \psuite
  }{
    \left<
    \usebox{\lamiaFuncBox}\hspace{190pt},
    \tfreshmem
    \right>
  }{
    % No premises
  }
\end{mathpar}

\subsection{Helper functions}

\newsavebox{\PythonAssignBox}
\begin{lrbox}{\PythonAssignBox}
\begin{python}
$\gtlet$ $\tfreshval_1$ = $\osFunc{string\_of\_id}$($\pvariable$)
$\gtlet$ $\tfreshval_2$ = $\gtget$ &scope
$\gtlet$ $\tfreshval_3$ = $\tfreshval_2${$\tfreshval_1$ $\gtarrow$ $\omemvariable$}
$\gtstore$ $\tfreshval_3$ &scope
\end{python}
\end{lrbox}

\begin{definition}[Python variable assignment]\ \\
$\osFunc{Python\_assign}(\pvariable,\omemvariable)$ =
\usebox{\PythonAssignBox}
\end{definition}

\newsavebox{\ConvertFuncBox}
\begin{lrbox}{\ConvertFuncBox}
\begin{python}
$\gtlet$ get_from_parent_scope = get_from_scope
$\gtlet$ &scope = alloc
$\gtlet$ get_from_scope = $\osFunc{get\_from\_scope}$()
$\gtlet$ $\tfreshval_{scope-0}$ = { }

$\gtlet$ $\tfreshval_{1-1}$ = 0
$\gtlet$ $\tfreshval_{1-2}$ = $\pvariable$[$\tfreshval_{1-1}$]
$\gtlet$ $\tfreshval_{1-3}$ = $\osFunc{string\_of\_id}(\pvariable_1)$
$\gtlet$ $\tfreshval_{scope-1}$ = $\tfreshval_{scope-0}${$\tfreshval_{1-3}$ $\gtarrow$ $\tfreshval_{1-2}$}

$\gtlet$ $\tfreshval_{2-1}$ = 1
$\gtlet$ $\tfreshval_{2-2}$ = $\pvariable$[$\tfreshval_{2-1}$]
$\gtlet$ $\tfreshval_{2-3}$ = $\osFunc{string\_of\_id}(\pvariable_2)$
$\gtlet$ $\tfreshval_{scope-2}$ = $\tfreshval_{scope-1}${$\tfreshval_{2-3}$ $\gtarrow$ $\tfreshval_{2-2}$}

...

$\gtlet$ $\tfreshval_{n-1}$ = (n-1)
$\gtlet$ $\tfreshval_{n-2}$ = $\pvariable$[$\tfreshval_{n-1}$]
$\gtlet$ $\tfreshval_{n-3}$ = $\osFunc{string\_of\_id}(\pvariable_3)$
$\gtlet$ $\tfreshval_{scope-n}$ = $\tfreshval_{scope-(n-1)}${$\tfreshval_{n-3}$ $\gtarrow$ $\tfreshval_{n-2}$}

$\gtstore$ &scope $\tfreshval_{scope-n}$
$\meaningof{\psuite}$
\end{python}
\end{lrbox}

\begin{definition}[Function body conversion]\ \\
$\osFunc{Convert\_func\_body}(\psuite, \pvariable, (\pvariable_1, \ldots, \pvariable_n))$ =
\usebox{\ConvertFuncBox}
\end{definition}

\newsavebox{\LookupBox}
\begin{lrbox}{\LookupBox}
\begin{python}
$\gtlet$ $\tfreshval$ = $\osFunc{string\_of\_id}$($\pvariable$)
$\gtlet$ $\tfreshmem$ = get_from_scope([$\tfreshval$])
\end{python}
\end{lrbox}

\begin{definition}[Lookup]\ \\
$\osFunc{Lookup}(\pvariable)$ =
$\left<\usebox{\LookupBox}\hspace{30px}, \tfreshmem\right>$
\end{definition}

\begin{definition}[string\_of\_id]\ \\
$\osFunc{string\_of\_id}(\pvariable)$ = $\pvariable$
\end{definition}

\begin{definition}[Builtins]
  \begin{flalign*}
  \begin{array}[t]{ c | c }
   \star\pvariable & \osFunc{Builtin\_memloc}(\pbinop)\\
   \hline
   \star \mathtt{True} & \&\mathtt{True} \\
   \star \mathtt{False} & \&\mathtt{False} \\
   \star \mathtt{slice} & \&\mathtt{slice} \\
   \star \mathtt{bool} & \&\mathtt{bool} \\
   \star \mathtt{AttributeError} & \&\mathtt{AttributeError} \\
   \star \mathtt{ValueError} & \&\mathtt{ValueError} \\
   \star \mathtt{TypeError} & \&\mathtt{TypeError} \\
   \star \mathtt{StopIteraiton} & \&\mathtt{StopIteration} \\
  \end{array}
  \end{flalign*}
\end{definition}

\newsavebox{\ScopegetBox}
\begin{lrbox}{\ScopegetBox}
\begin{python}
$\gtlet$ $\tfreshval_1$ = $\gtget$ &scope
$\gtlet$ $\tfreshval_2$ = $\tfreshval_1$ haskey $\tfreshval$
$\gtlet$ $\tfreshmem_1$ =
  if $\tfreshval_2$ then {
    $\gtlet$ $\tfreshmem_2$ = $\tfreshval_1${$\tfreshval$}
    $\gtifresult$ $\tfreshmem_2$
  } else {
    $\gtlet$ $\tfreshmem_3$ = get_from_parent_scope($\tfreshval$)
    $\gtifresult$ $\tfreshmem_3$
  }
return $\tfreshmem_1$
\end{python}
\end{lrbox}

\begin{definition}[Python variable retrieval]\ \\
$\osFunc{get\_from\_scope}()$ = $\gtdef (\tfreshval) : \{ \psuite \}$, \\
where $\psuite = $
\usebox{\ScopegetBox}
\end{definition}

\newsavebox{\GetCallBox}
\begin{lrbox}{\GetCallBox}
\begin{python}
$\gtlet$ $\tfreshmem$ = $\omemvariable$

#Compute test condition for our loop
$\gtlet$ $\tfreshval_1$ = get $\tfreshmem$
$\gtlet$ $\tfreshval_2$ = get $\osFunc{get\_attr}$("$\star$value", $\tfreshval_1$)
$\gtlet$ $\tfreshval_3$ = is_function? $\tfreshval_2$
$\gtlet$ $\tfreshval_4$ = not $\tfreshval_3$
$\gtlet$ $\tfreshmem_1$ = alloc
$\gtstore$ $\tfreshval_4$ $\tfreshmem_1$

#Loop until error or callable
while $\tfreshmem_1$:
  $\gtlet$ $\tfreshval_5$ = "__call__"
  $\gtlet$ $\tfreshval_6$ = $\tfreshval_1$ haskey $\tfreshval_5$
  $\gtlet$ $\tfreshmem_2$ =
    if $\tfreshval_6$ then {
      $\gtlet$ $\tfreshmem_3$ = $\tfreshval_1${$\tfreshval_5$}
      $\gtifresult$ $\tfreshmem_3$
    } else {
      #FIXME: Strictly speaking this string should contain the class of the object
      $\gtlet \tfreshval_7$ = "Object is not callable"
      $\gtlet \tfreshval_8$ = $\osFunc{wrap\_type\_error}(\tfreshval_7)$
      raise $\tfreshval_8$
    }
  #At the end of the loop recompute the test
  $\gtlet$ $\tfreshmem$ = $\tfreshmem_2$
  $\gtlet$ $\tfreshval_1$ = get $\tfreshmem$
  $\gtlet$ $\tfreshval_2$ = get $\osFunc{get\_attr}$("$\star$value", $\tfreshval_1$)
  $\gtlet$ $\tfreshval_3$ = is_function? $\tfreshval_2$
  $\gtlet$ $\tfreshval_4$ = not $\tfreshval_3$
  $\gtstore$ $\tfreshval_4$ $\tfreshmem_1$

\end{python}
\end{lrbox}

\begin{definition}[Determine calling behavior]\ \\
$\osFunc{get\_call}(\omemvariable)$ = $\left< \psuite, \tfreshval_2 \right>$ \\
where \psuite =
\usebox{\GetCallBox}
\end{definition}

\newsavebox{\GetAttrFuncBox}
\begin{lrbox}{\GetAttrFuncBox}
\begin{python}
$\gtlet$ $\tfreshval_1$ = s
$\gtlet$ $\tfreshval_2$ = $\ovalvariable$ haskey $\tfreshval_1$
$\gtlet$ $\tfreshmem$ =
  if $\tfreshval_2$ then {
    $\gtlet$ $\tfreshmem_2$ = $\ovalvariable${$\tfreshval_1$}
    $\gtifresult$ $\tfreshmem_2$
  } else {
    $\gtlet$ $\tfreshval_1$ = "Object has no attribute" ^ s
    $\gtlet$ $\tfreshmem_3$ = $\osFunc{wrap\_attribute\_error}$($\tfreshval_1$)
    raise $\tfreshmem_3$
  }
\end{python}
\end{lrbox}

\begin{definition}[Attribute Retrieval]\ \\
$\osFunc{get\_attr}(s, \ovalvariable)$ = $\left< \psuite, \tfreshmem \right>$ \\
where s is a string literal, \^{} denotes compile-time string concatenation, and
\\\psuite =
\usebox{\GetAttrFuncBox}
\end{definition}

\begin{definition}[Lookup followed by attribute retrieval]\ \\
$\osFunc{lookup\_and\_get\_attr}(s_1, s_2)$ =
$\left< \gtlet \tfreshval_1 = \gtget \osFunc{Lookup}(s_1), \osFunc{get\_attr}(s_2, \tfreshval_1) \right>$ \\
where $s_1,s_2$ are string literals
\end{definition}

\begin{definition}[Wrapping Objects]\ \\
The functions of the form $\osFunc{wrap\_*}$ result in an object of type * with
the given value. The details will change heavily when we add classes so we omit them.
\end{definition}

\newsavebox{\PreambleBox}
\begin{lrbox}{\PreambleBox}
\begin{python}
$\gtlet$ $\tfreshval_1$ = {}
$\gtlet$ &scope = $\gtalloc$
$\gtstore$ $\tfreshval_1$ &scope

$\gtlet$ get_from_parent_scope = def ($\tfreshval_2$) {
  # Technically should contain the actual name
  $\gtlet$ $\tfreshval_3$ = "Name is not defined"
  $\gtlet$ $\tfreshmem_1$ = $\osFunc{wrap\_name\_error}$($\tfreshval_3$)
  raise $\tfreshmem_1$
}

$\gtlet$ get_from_scope = $\osFunc{get\_from\_scope}$()

#We add each of the below variables to the python scope after they are defined

$\gtlet$ $\star$True = #builtin true object
$\gtlet$ $\star$False = #builtin false object
$\gtlet$ $\star$None = #builtin none object

$\gtlet$ $\star$AttributeError = #builtin AttrError type
$\gtlet$ $\star$TypeError = #builtin TypeError type
$\gtlet$ $\star$NameError = #builtin NameError type
$\gtlet$ $\star$StopIteration = #builtin StopIteration type

$\gtlet$ $\star$bool = #builtin bool function

#Stop adding new variables to the python scope

$\gtlet$ $\star$int_add = #builtin integer addition function

\end{python}
\end{lrbox}

\begin{definition}[Preamble]\ \\
$\osFunc{Preamble}()$ = \usebox{\PreambleBox}
\end{definition}

\end{document}
