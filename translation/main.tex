\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

\begin{document}
  \section{Python Language Grammar}
  % This grammar is based on the AST defined in the python2_ast.ml file

  We use the convention that a symbol with a star above it is optional.

  \begin{grammar}
    \grule[variables]{\pvariable}{}
    \grule[suites]{\psuite}{\gtobrk \pstmt; \ldots \gtcbrk}
    \grule[statements]{\pstmt}{
                \gtdef \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \gtreturn \pexpropt \gline
        \gor    \pexpr, \ldots \pexpr \gteq \pexpr \gline
        \gor    \pexpr \pbinop\gteq \pexpr \gline
        %I really don't care about print statements so I'm ignoring them
        \gor    \gtfor \pexpr \gtin \pexpr \gtcolon \psuite \gline
        \gor    \gtwhile \pexpr \gtcolon \psuite \gline
        \gor    \gtif \pexpr \gtcolon \psuite \gtelse \gtcolon \psuite \gline
        \gor    \gtraise \pexpropt, \pexpropt, \pexpropt \gline
        \gor    \gttry \gtcolon \psuite \gtobrk \pexcepthandler; \ldots \gtcbrk \gline
        \gor    \pexpr \gline
        \gor    \gtpass \gline
        \gor    \gtbreak \gline
        \gor    \gtcontinue \gline
    }
    \grule[expressions]{\pexpr}{
                \punop \pexpr \gline
        \gor    \pexpr \pbinop \pexpr \gline
        \gor    \pexpr \gtand \pexpr \gline
        \gor    \pexpr \gtor \pexpr \gline
        \gor    \pexpr \pcmpop \pexpr \gline
        \gor    \pexpr \gtif \pexpr \gtelse \pexpr \gline
        \gor    \pexpr \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pnum \gline
        \gor    \mathbb{S} \gline
        \gor    \mathbb{B} \gline
        \gor    \pexpr.\pvariable \gline
        \gor    \pexpr \gtobrk \pslice \gtcbrk \gline
        \gor    \pvariable \gline
        \gor    \gtobrk \pexpr, \dots \gtcbrk \gline
        \gor    \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \gtNone \gline
    }
    \grule[unary operators]{\punop}{
                \gtuplus
           \gor \gtusub
           \gor \gtnot
    }
    \grule[binary operators]{\pbinop}{
                \gtplus
           \gor \gtsub
           \gor \gtmult
           \gor \gtdiv
           \gor \gtmod
           \gor \gtpow
    }
    \grule[comparison operators]{\pcmpop}{
                \gtiseq
           \gor \gtneq
           \gor \gtgeq
           \gor \gtleq
           \gor \gtge
           \gor \gtle
           \gor \gtis
           \gor \gtis \gtnot
           \gor \gtin
           \gor \gtnot \gtin
    }
    \grule[exception handlers]{\pexcepthandler}{
                \gtexcept \gtcolon \psuite \gline
           \gor \gtexcept \pexpr \gtcolon \psuite \gline
           \gor \gtexcept \pexpr \gtas \pexpr \gtcolon \psuite
    }
    \grule[slice]{\pslice}{
                \pexpr \gline
           \gor \pexpropt \gtcolon \pexpropt \gline
           \gor \pexpropt \gtcolon \pexpropt \gtcolon \pexpropt
    }
    \grule[numbers]{\pnum}{}
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
  \end{grammar}

  \section{Python Simplified Grammar}
  % This grammar is based on the AST defined in the python2_ast.ml file

  \begin{grammar}
    \grule[variables]{\pvariable}{}
    \grule[suites]{\psuite}{\gtobrk \pstmt; \ldots \gtcbrk}
    \grule[statements]{\pstmt}{
                \gtreturn \pexpr \gline
        \gor    \pvariable \gteq \pexpr \gline
        \gor    \gtwhile \pvariable \gtcolon \psuite \gline
        \gor    \gtif \pexpr \gtcolon \psuite \gtelse \gtcolon \psuite \gline
        \gor    \gtraise \pexpr \gline
        \gor    \gttry \gtcolon \psuite \gtexcept \pvariable \gtcolon \psuite \gline
        \gor    \gtpass \gline
        \gor    \gtbreak \gline
        \gor    \gtcontinue \gline
        \gor    \pexpr \gline
    }
    \grule[expressions]{\pexpr}{
                \punop \pexpr \gline
        \gor    \pexpr \pbinop \pexpr \gline
        \gor    \pexpr \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pexpr.\pvariable \gline
        \gor    \gtobrk \pexpr, \dots \gtcbrk \gline
        \gor    \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pnum \gline
        \gor    \mathbb{S} \gline
        \gor    \mathbb{B} \gline
        \gor    \pvariable \gline
        \gor    \gtfun \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \pmagic
    }
    \grule[unary operators]{\punop}{
                \gtnot
    }
    \grule[binary operators]{\pbinop}{
                \gtis
    }
    \grule[numbers]{\pnum}{}
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
    \grule[magic builtins]{\pmagic}{
                \gtbool
           \gor \gtslice
           \gor \gtValueError
           \gor \gtAttributeError \gline
           \gor \gtTypeError
           \gor \gtStopIteration
    }
  \end{grammar}

\section{Python Simplification Process}

In the following rules, the expression ``\tfreshvar'' will indicate a fresh variable name.
Identical expressions in a single rule will all refer to the same variable name.

The left-hand side of each rule is in the Python language, while the right-hand side is
in the the Simplified language.

Additionally, for all $e_1$, we will define $S_{(e_1)}$ and $e_{(e_1)}$ to be such
that $\meaningof{e_1} = \gsLR{S_{(e_1)}, e_{(e_1)}}$. We may also use this notation
for slices.

\subsection{Statements}

\newsavebox{\funcDefBox}
\begin{lrbox}{\funcDefBox}
\begin{python}
$\tfreshvar$ = $\gtfun \gtopar \pvariable_0, \ldots, \pvariable_n \gtcpar$:
  $\meaningof{\psuite'}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Function Definition}{
    \gtdef \gtopar \pexpr_0, \ldots, \pexpr_n \gtcpar \gtcolon \psuite
  }{
    \usebox{\funcDefBox}
  }{
    \mbox{where }
    \pexpr_i = \pvariable_i, \\
    \psuite' = \osFunc{add\_return}(\psuite)
  }
\end{mathpar}

\newsavebox{\returnBox}
\begin{lrbox}{\returnBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
return $\pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Return Expression}{
    \gtreturn \pexpr
  }{
    \usebox{\returnBox}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\ereturnBox}
\begin{lrbox}{\ereturnBox}
\begin{python}
return $\mathtt{None}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Empty Return}{
    \gtreturn
  }{
    \usebox{\ereturnBox}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\multipleAssignmentBox}
\begin{lrbox}{\multipleAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
$\tfreshvar = \pexpr_{(\pexpr)}$
$\meaningof{\pexpr_1 = \tfreshvar}$
...
$\meaningof{\pexpr_n = \tfreshvar}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Multiple Assignment}{
    \pexpr_1 \gteq \ldots \gteq \pexpr_n \gteq \pexpr
  }{
    \usebox{\multipleAssignmentBox}
  }{
    \mbox{where }
    n > 1
  }
\end{mathpar}

\newsavebox{\variableAssignmentBox}
\begin{lrbox}{\variableAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
$\pvariable = \pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Variable Assignment}{
    \pvariable \gteq \pexpr
  }{
    \usebox{\variableAssignmentBox}
  }{
  }
\end{mathpar}

\newsavebox{\attributeAssignmentBox}
\begin{lrbox}{\attributeAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr_2)}}$
$\meaningof{\psuite_{(\pexpr_1)}}$
$\pexpr_{(\pexpr_1)}$.__setattr__($s$, $\pexpr_{(\pexpr_2)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Attribute Assignment}{
    \pexpr_1.\pvariable \gteq \pexpr_2
  }{
    \usebox{\attributeAssignmentBox}
  }{
    \mbox{where }
    s = \osFunc{string\_of\_variable}(\pvariable)
  }
\end{mathpar}

\newsavebox{\sliceAssignmentBox}
\begin{lrbox}{\sliceAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr_2)}}$
$\meaningof{\psuite_{(\pexpr_1)}}$
$\meaningof{\psuite_{(\pslice)}}$
$\pexpr_{(\pexpr_1)}$.__setitem__($\pexpr_{(\pslice)}$, $\pexpr_{(\pexpr_2)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Slice Assignment}{
    \pexpr_1 \gtobrk \pslice \gtcbrk \gteq \pexpr_2
  }{
    \usebox{\sliceAssignmentBox}
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{List Assignment}{
    \gtobrk \pexpr_1, \ldots, \pexpr_n \gtcbrk \gteq \pexpr
  }{
    \meaningof{\gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar \gteq \pexpr}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\tupleAssignmentBox}
\begin{lrbox}{\tupleAssignmentBox}
\begin{python}
$\tfreshvar$ = $\pexpr$.__iter__().next
try:
  $\tfreshvar_1$ = $\tfreshvar$()
  ...
  $\tfreshvar_n$ = $\tfreshvar$()

  try:
    $\tfreshvar$() # Should throw StopIteration
    raise ValueError, "too many elements to unpack"
  except StopIteration:
    pass

except StopIteration:
  raise ValueError, "too few elements to unpack"

$\pexpr_1$ = $\tfreshvar_1$
...
$\pexpr_n$ = $\tfreshvar_n$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Tuple Assignment}{
    \gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar \gteq \pexpr
  }{
    \left\llbracket\usebox{\tupleAssignmentBox}\right\rrbracket
  }{
    % No premises, surprisingly
  }
\end{mathpar}

TODO: The augmented assignment rules reflect the current code, but are wrong.
We also need to check for \_\_radd\_\_ and maybe some more stuff, and should throw a
TypeError if we can't figure out how to do the addition. Also, the value
expression should be evaluated first.
\newsavebox{\augmentedAssignmentBox}
\begin{lrbox}{\augmentedAssignmentBox}
\begin{python}
try:
  $\tfreshvar$ = $\pvariable$.iopFunc
except AttributeError:
  $\tfreshvar$ = $\pvariable$.opFunc
$\pvariable$ = $\tfreshvar$($\pexpr$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Variable Assignment}{
    \pvariable \pbinop \gteq \pexpr
  }{
    \left\llbracket\usebox{\augmentedAssignmentBox}\right\rrbracket
  }{
  \mbox{where }
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\augmentedAttributeAssignmentBox}
\begin{lrbox}{\augmentedAttributeAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\tfreshvar_1$ = $\pexpr_{(\pexpr_1)}$
try:
  $\tfreshvar_2$ = $\tfreshvar_1$.$\pvariable$.iopFunc
except AttributeError:
  $\tfreshvar_2$ = $\tfreshvar_1$.$\pvariable$.opFunc
$\tfreshvar_1$.$\pvariable$ = $\tfreshvar_2$($\pexpr_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Attribute Assignment}{
    \pexpr_1.\pvariable \pbinop \gteq \pexpr_2
  }{
    \left\llbracket\usebox{\augmentedAttributeAssignmentBox}\right\rrbracket
  }{
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\augmentedSliceAssignmentBox}
\begin{lrbox}{\augmentedSliceAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pslice)}$
$\tfreshvar_1$ = $\pexpr_{(\pexpr_1)}$
$\tfreshvar_2$ = $\pexpr_{(\pslice)}$
try:
  $\tfreshvar_3$ = $\tfreshvar_1$[$\tfreshvar_2$].iopFunc
except AttributeError:
  $\tfreshvar_3$ = $\tfreshvar_1$[$\tfreshvar_2$].opFunc
$\tfreshvar_1$[$\tfreshvar_2$] = $\tfreshvar_3$($\pexpr_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Slice Assignment}{
    \pexpr_1 \gtobrk \pslice \gtcbrk \pbinop \gteq \pexpr_2
  }{
    \left\llbracket\usebox{\augmentedSliceAssignmentBox}\right\rrbracket
  }{
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\forBox}
\begin{lrbox}{\forBox}
\begin{python}
$\tfreshvar$ = $\pexpr_2$.__iter__().next
try:
  while True:
    $\pexpr_1$ = $\tfreshvar$()
    $\psuite$
except StopIteration:
  pass
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{For loop}{
    \gtfor \pexpr_1 \gtin \pexpr_2 \gtcolon \psuite
  }{
    \left\llbracket\usebox{\forBox}\right\rrbracket
  }{
  }
\end{mathpar}

\newsavebox{\whileBox}
\begin{lrbox}{\whileBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
$\tfreshvar$ = bool($\pexpr_{(\pexpr)}$)
while $\tfreshvar$:
  $\meaningof{\psuite}$
  $\meaningof{\psuite_{(\pexpr)}}$
  $\tfreshvar$ = bool($\pexpr_{(\pexpr)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{While loop}{
    \gtwhile \pexpr \gtcolon \psuite
  }{
    \usebox{\whileBox}
  }{
  }
\end{mathpar}

\newsavebox{\ifBox}
\begin{lrbox}{\ifBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
if bool($\pexpr_{(\pexpr)}$):
  $\meaningof{\psuite_1}$
else:
  $\meaningof{\psuite_2}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{If statement}{
    \gtif \pexpr \gtcolon \psuite_1 \gtelse \gtcolon \psuite_2
  }{
    \usebox{\ifBox}
  }{
  }
\end{mathpar}

\newsavebox{\raiseBox}
\begin{lrbox}{\raiseBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
raise $\pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Raise statement}{
    \gtraise \pexpr
  }{
    \usebox{\raiseBox}
  }{
  }
\end{mathpar}

\newsavebox{\tryBox}
\begin{lrbox}{\tryBox}
\begin{python}
COMPLICATED -- TODO
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Try/Except statement}{
    \gttry \gtcolon \psuite \gtobrk \pexcepthandler; \ldots \gtcbrk
  }{
    \usebox{\tryBox}
  }{
  }
\end{mathpar}

\newsavebox{\passBox}
\begin{lrbox}{\passBox}
\begin{python}
pass
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Pass statement}{
    \gtpass
  }{
    \usebox{\passBox}
  }{
  }
\end{mathpar}

\newsavebox{\breakBox}
\begin{lrbox}{\breakBox}
\begin{python}
break
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Break statement}{
    \gtbreak
  }{
    \usebox{\breakBox}
  }{
  }
\end{mathpar}

\newsavebox{\continueBox}
\begin{lrbox}{\continueBox}
\begin{python}
continue
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Continue statement}{
    \gtcontinue
  }{
    \usebox{\continueBox}
  }{
  }
\end{mathpar}

\subsection{Expressions}

\newsavebox{\andBox}
\begin{lrbox}{\andBox}
\begin{python}
$\tfreshvar$ = $\pexpr_1$
$\pexpr_2$ if $\tfreshvar$ else $\tfreshvar$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Boolean expression (And)}{
    \pexpr_1 \gtand \pexpr_2
  }{
    \left\llbracket\usebox{\andBox}\ \ \ \ \ \ \right\rrbracket
  }{
  }
\end{mathpar}

\newsavebox{\orBox}
\begin{lrbox}{\orBox}
\begin{python}
$\tfreshvar$ = $\pexpr_1$
$\tfreshvar$ if $\tfreshvar$ else $\pexpr_2$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Boolean expression (Or)}{
    \pexpr_1 \gtor \pexpr_2
  }{
    \left\llbracket\usebox{\orBox}\ \ \ \ \ \ \right\rrbracket
  }{
  }
\end{mathpar}

\newsavebox{\binopBox}
\begin{lrbox}{\binopBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pexpr_2)}$
$\pexpr_{(\pexpr_1)}$.opFunc($\pexpr_{(\pexpr_2)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Binary Operation}{
    \pexpr_1 \pbinop \pexpr_2
  }{
    \usebox{\binopBox}
  }{
  \mbox{where }
  \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop)
  }
\end{mathpar}

\newsavebox{\notBox}
\begin{lrbox}{\notBox}
\begin{python}
$\psuite_{(\pexpr)}$
not bool($\pexpr_{(\pexpr)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (not)}{
    \gtnot \pexpr
  }{
    \usebox{\notBox}
  }{
  }
\end{mathpar}

\newsavebox{\uplusBox}
\begin{lrbox}{\uplusBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\pexpr_{(\pexpr)}$.__pos__()
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (+)}{
    \gtuplus \pexpr
  }{
    \usebox{\uplusBox}
  }{
  }
\end{mathpar}

\newsavebox{\usubBox}
\begin{lrbox}{\usubBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\pexpr_{(\pexpr)}$.__neg__()
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (-)}{
    \gtusub \pexpr
  }{
    \usebox{\usubBox}
  }{
  }
\end{mathpar}

\newsavebox{\ifExpBox}
\begin{lrbox}{\ifExpBox}
\begin{python}
$\psuite_{(\pexpr_2)}$
if $\pexpr_{(\pexpr_2)}$:
  $\psuite_{(\pexpr_1)}$
  $\tfreshvar_1$ = $\pexpr_{(\pexpr_1)}$
else:
  $\psuite_{(\pexpr_3)}$
  $\tfreshvar_1$ = $\pexpr_{(\pexpr_3)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (-)}{
    \pexpr_1 \gtif \pexpr_2 \gtelse \pexpr_3
  }{
    \usebox{\ifExpBox}
  }{
  \mbox{and we return } \tfreshvar_1
  }
\end{mathpar}

\end{document}
