\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

\begin{document}
  \section{Python Language Grammar}
  % This grammar is based on the AST defined in the python2_ast.ml file

  We use the convention that a symbol with a star above it is optional.

  \begin{grammar}
    \grule[variables]{\pvariable}{}
    \grule[suites]{\psuite}{\gtobrk \pstmt; \ldots \gtcbrk}
    \grule[statements]{\pstmt}{
                \gtdef \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \gtreturn \pexpropt \gline
        \gor    \pexpr, \ldots \pexpr \gteq \pexpr \gline
        \gor    \pexpr \pbinop \gteq \pexpr \gline
        %I really don't care about print statements so I'm ignoring them
        \gor    \gtfor \pexpr \gtin \pexpr \gtcolon \psuite \gline
        \gor    \gtwhile \pexpr \gtcolon \psuite \gline
        \gor    \gtif \pexpr \gtcolon \psuite \gtelse \gtcolon \psuite \gline
        \gor    \gtraise \pexpropt, \pexpropt, \pexpropt \gline
        \gor    \gttry \gtcolon \psuite \gtobrk \pexcepthandler; \ldots \gtcbrk \gline
        \gor    \pexpr \gline
        \gor    \gtpass \gline
        \gor    \gtbreak \gline
        \gor    \gtcontinue \gline
    }
    \grule[expressions]{\pexpr}{
                \punop \pexpr \gline
        \gor    \pexpr \pbinop \pexpr \gline
        \gor    \pexpr \gtand \pexpr \gline
        \gor    \pexpr \gtor \pexpr \gline
        \gor    \pexpr \pcmpop \pexpr \pcmpop \ldots \pcmpop \pexpr \gline
        \gor    \pexpr \gtif \pexpr \gtelse \pexpr \gline
        \gor    \pexpr \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pnum \gline
        \gor    \mathbb{S} \gline
        \gor    \mathbb{B} \gline
        \gor    \pexpr.\pvariable \gline
        \gor    \pexpr \gtobrk \pslice \gtcbrk \gline
        \gor    \pvariable \gline
        \gor    \gtobrk \pexpr, \dots \gtcbrk \gline
        \gor    \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \gtNone \gline
    }
    \grule[unary operators]{\punop}{
                \gtuplus
           \gor \gtusub
           \gor \gtnot
    }
    \grule[binary operators]{\pbinop}{
                \gtplus
           \gor \gtsub
           \gor \gtmult
           \gor \gtdiv
           \gor \gtmod
           \gor \gtpow
    }
    \grule[comparison operators]{\pcmpop}{
                \gtiseq
           \gor \gtneq
           \gor \gtgeq
           \gor \gtleq
           \gor \gtge
           \gor \gtle
           \gor \gtis
           \gor \gtis \gtnot
           \gor \gtin
           \gor \gtnot \gtin
    }
    \grule[exception handlers]{\pexcepthandler}{
                \gtexcept \gtcolon \psuite \gline
           \gor \gtexcept \pexpr \gtcolon \psuite \gline
           \gor \gtexcept \pexpr \gtas \pexpr \gtcolon \psuite
    }
    \grule[slice]{\pslice}{
                \pexpr \gline
           \gor \pexpropt \gtcolon \pexpropt \gline
           \gor \pexpropt \gtcolon \pexpropt \gtcolon \pexpropt
    }
    \grule[numbers]{\pnum}{}
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
  \end{grammar}

  \section{Python Simplified Grammar}
  % This grammar is based on the AST defined in the python2_ast.ml file

  \begin{grammar}
    \grule[variables]{\pvariable}{}
    \grule[suites]{\psuite}{\gtobrk \pstmt; \ldots \gtcbrk}
    \grule[statements]{\pstmt}{
                \gtreturn \pexpr \gline
        \gor    \pvariable \gteq \pexpr \gline
        \gor    \gtwhile \pvariable \gtcolon \psuite \gline
        \gor    \gtif \pexpr \gtcolon \psuite \gtelse \gtcolon \psuite \gline
        \gor    \gtraise \pexpr \gline
        \gor    \gttry \gtcolon \psuite \gtexcept \pvariable \gtcolon \psuite \gline
        \gor    \gtpass \gline
        \gor    \gtbreak \gline
        \gor    \gtcontinue \gline
        \gor    \pexpr \gline
    }
    \grule[expressions]{\pexpr}{
                \punop \pexpr \gline
        \gor    \pexpr \pbinop \pexpr \gline
        \gor    \pexpr \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pexpr.\pvariable \gline
        \gor    \gtobrk \pexpr, \dots \gtcbrk \gline
        \gor    \gtopar \pexpr, \dots \gtcpar \gline
        \gor    \pnum \gline
        \gor    \mathbb{S} \gline
        \gor    \mathbb{B} \gline
        \gor    \pvariable \gline
        \gor    \gtfun \gtopar \pexpr, \ldots \gtcpar \gtcolon \psuite \gline
        \gor    \pmagic
    }
    \grule[unary operators]{\punop}{
                \gtnot
    }
    \grule[binary operators]{\pbinop}{
                \gtis
    }
    \grule[numbers]{\pnum}{}
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
    \grule[magic builtins]{\pmagic}{
                \gtbool
           \gor \gtslice
           \gor \gtValueError
           \gor \gtAttributeError \gline
           \gor \gtTypeError
           \gor \gtStopIteration
    }
  \end{grammar}

\section{Python Simplification Process}

In the following rules, the expression ``\tfreshvar'' will indicate a fresh variable name.
Identical expressions in a single rule will all refer to the same variable name.

The left-hand side of each rule is in the Python language, while the right-hand side is
in the the Simplified language.

Additionally, for all $e_1$, we will define $S_{(e_1)}$ and $e_{(e_1)}$ to be such
that $\meaningof{e_1} = \gsLR{S_{(e_1)}, e_{(e_1)}}$. We may also use this notation
for slices.

\subsection{Statements}

\newsavebox{\funcDefBox}
\begin{lrbox}{\funcDefBox}
\begin{python}
$\tfreshvar$ = $\gtfun \gtopar \pvariable_0, \ldots, \pvariable_n \gtcpar$:
  $\meaningof{\psuite'}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Function Definition}{
    \gtdef \gtopar \pexpr_0, \ldots, \pexpr_n \gtcpar \gtcolon \psuite
  }{
    \usebox{\funcDefBox}
  }{
    \mbox{where }
    \pexpr_i = \pvariable_i, \\
    \psuite' = \osFunc{add\_return}(\psuite)
  }
\end{mathpar}

\newsavebox{\returnBox}
\begin{lrbox}{\returnBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
return $\pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Return Expression}{
    \gtreturn \pexpr
  }{
    \usebox{\returnBox}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\ereturnBox}
\begin{lrbox}{\ereturnBox}
\begin{python}
return $\mathtt{None}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Empty Return}{
    \gtreturn
  }{
    \usebox{\ereturnBox}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\multipleAssignmentBox}
\begin{lrbox}{\multipleAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
$\tfreshvar = \pexpr_{(\pexpr)}$
$\meaningof{\pexpr_1 = \tfreshvar}$
...
$\meaningof{\pexpr_n = \tfreshvar}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Multiple Assignment}{
    \pexpr_1 \gteq \ldots \gteq \pexpr_n \gteq \pexpr
  }{
    \usebox{\multipleAssignmentBox}
  }{
    \mbox{where }
    n > 1
  }
\end{mathpar}

\newsavebox{\variableAssignmentBox}
\begin{lrbox}{\variableAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
$\pvariable = \pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Variable Assignment}{
    \pvariable \gteq \pexpr
  }{
    \usebox{\variableAssignmentBox}
  }{
  }
\end{mathpar}

\newsavebox{\attributeAssignmentBox}
\begin{lrbox}{\attributeAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr_2)}}$
$\meaningof{\psuite_{(\pexpr_1)}}$
$\pexpr_{(\pexpr_1)}$.__setattr__($s$, $\pexpr_{(\pexpr_2)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Attribute Assignment}{
    \pexpr_1.\pvariable \gteq \pexpr_2
  }{
    \usebox{\attributeAssignmentBox}
  }{
    \mbox{where }
    s = \osFunc{string\_of\_variable}(\pvariable)
  }
\end{mathpar}

\newsavebox{\sliceAssignmentBox}
\begin{lrbox}{\sliceAssignmentBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr_2)}}$
$\meaningof{\psuite_{(\pexpr_1)}}$
$\meaningof{\psuite_{(\pslice)}}$
$\pexpr_{(\pexpr_1)}$.__setitem__($\pexpr_{(\pslice)}$, $\pexpr_{(\pexpr_2)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Slice Assignment}{
    \pexpr_1 \gtobrk \pslice \gtcbrk \gteq \pexpr_2
  }{
    \usebox{\sliceAssignmentBox}
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{List Assignment}{
    \gtobrk \pexpr_1, \ldots, \pexpr_n \gtcbrk \gteq \pexpr
  }{
    \meaningof{\gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar \gteq \pexpr}
  }{
    % No premises
  }
\end{mathpar}

\newsavebox{\tupleAssignmentBox}
\begin{lrbox}{\tupleAssignmentBox}
\begin{python}
$\tfreshvar$ = $\pexpr$.__iter__().next
try:
  $\tfreshvar_1$ = $\tfreshvar$()
  ...
  $\tfreshvar_n$ = $\tfreshvar$()

  try:
    $\tfreshvar$() # Should throw StopIteration
    raise ValueError, "too many elements to unpack"
  except StopIteration:
    pass

except StopIteration:
  raise ValueError, "too few elements to unpack"

$\pexpr_1$ = $\tfreshvar_1$
...
$\pexpr_n$ = $\tfreshvar_n$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Tuple Assignment}{
    \gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar \gteq \pexpr
  }{
    \left\llbracket\usebox{\tupleAssignmentBox}\right\rrbracket
  }{
    % No premises, surprisingly
  }
\end{mathpar}

TODO: The augmented assignment rules reflect the current code, but are wrong.
We also need to check for \_\_radd\_\_ and maybe some more stuff, and should throw a
TypeError if we can't figure out how to do the addition. Also, the value
expression should be evaluated first.
\newsavebox{\augmentedAssignmentBox}
\begin{lrbox}{\augmentedAssignmentBox}
\begin{python}
try:
  $\tfreshvar$ = $\pvariable$.iopFunc
except AttributeError:
  $\tfreshvar$ = $\pvariable$.opFunc
$\pvariable$ = $\tfreshvar$($\pexpr$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Variable Assignment}{
    \pvariable \pbinop \gteq \pexpr
  }{
    \left\llbracket\usebox{\augmentedAssignmentBox}\right\rrbracket
  }{
  \mbox{where }
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\augmentedAttributeAssignmentBox}
\begin{lrbox}{\augmentedAttributeAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\tfreshvar_1$ = $\pexpr_{(\pexpr_1)}$
try:
  $\tfreshvar_2$ = $\tfreshvar_1$.$\pvariable$.iopFunc
except AttributeError:
  $\tfreshvar_2$ = $\tfreshvar_1$.$\pvariable$.opFunc
$\tfreshvar_1$.$\pvariable$ = $\tfreshvar_2$($\pexpr_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Attribute Assignment}{
    \pexpr_1.\pvariable \pbinop \gteq \pexpr_2
  }{
    \left\llbracket\usebox{\augmentedAttributeAssignmentBox}\right\rrbracket
  }{
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\augmentedSliceAssignmentBox}
\begin{lrbox}{\augmentedSliceAssignmentBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pslice)}$
$\tfreshvar_1$ = $\pexpr_{(\pexpr_1)}$
$\tfreshvar_2$ = $\pexpr_{(\pslice)}$
try:
  $\tfreshvar_3$ = $\tfreshvar_1$[$\tfreshvar_2$].iopFunc
except AttributeError:
  $\tfreshvar_3$ = $\tfreshvar_1$[$\tfreshvar_2$].opFunc
$\tfreshvar_1$[$\tfreshvar_2$] = $\tfreshvar_3$($\pexpr_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Augmented Slice Assignment}{
    \pexpr_1 \gtobrk \pslice \gtcbrk \pbinop \gteq \pexpr_2
  }{
    \left\llbracket\usebox{\augmentedSliceAssignmentBox}\right\rrbracket
  }{
    \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop) \\
    \mathtt{iopFunc} = \osFunc{binop\_to\_ifunc}(\pbinop)
  }
\end{mathpar}

\newsavebox{\forBox}
\begin{lrbox}{\forBox}
\begin{python}
$\tfreshvar$ = $\pexpr_2$.__iter__().next
try:
  while True:
    $\pexpr_1$ = $\tfreshvar$()
    $\psuite$
except StopIteration:
  pass
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{For loop}{
    \gtfor \pexpr_1 \gtin \pexpr_2 \gtcolon \psuite
  }{
    \left\llbracket\usebox{\forBox}\right\rrbracket
  }{
  }
\end{mathpar}

\newsavebox{\whileBox}
\begin{lrbox}{\whileBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
$\tfreshvar$ = bool($\pexpr_{(\pexpr)}$)
while $\tfreshvar$:
  $\meaningof{\psuite}$
  $\meaningof{\psuite_{(\pexpr)}}$
  $\tfreshvar$ = bool($\pexpr_{(\pexpr)}$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{While loop}{
    \gtwhile \pexpr \gtcolon \psuite
  }{
    \usebox{\whileBox}
  }{
  }
\end{mathpar}

\newsavebox{\ifBox}
\begin{lrbox}{\ifBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
if bool($\pexpr_{(\pexpr)}$):
  $\meaningof{\psuite_1}$
else:
  $\meaningof{\psuite_2}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{If statement}{
    \gtif \pexpr \gtcolon \psuite_1 \gtelse \gtcolon \psuite_2
  }{
    \usebox{\ifBox}
  }{
  }
\end{mathpar}

\newsavebox{\raiseBox}
\begin{lrbox}{\raiseBox}
\begin{python}
$\meaningof{\psuite_{(\pexpr)}}$
raise $\pexpr_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Raise statement}{
    \gtraise \pexpr
  }{
    \usebox{\raiseBox}
  }{
  }
\end{mathpar}

\newsavebox{\tryBox}
\begin{lrbox}{\tryBox}
\begin{python}
COMPLICATED -- TODO
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Try/Except statement}{
    \gttry \gtcolon \psuite \gtobrk \pexcepthandler; \ldots \gtcbrk
  }{
    \usebox{\tryBox}
  }{
  }
\end{mathpar}

\newsavebox{\passBox}
\begin{lrbox}{\passBox}
\begin{python}
pass
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Pass statement}{
    \gtpass
  }{
    \usebox{\passBox}
  }{
  }
\end{mathpar}

\newsavebox{\breakBox}
\begin{lrbox}{\breakBox}
\begin{python}
break
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Break statement}{
    \gtbreak
  }{
    \usebox{\breakBox}
  }{
  }
\end{mathpar}

\newsavebox{\continueBox}
\begin{lrbox}{\continueBox}
\begin{python}
continue
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Continue statement}{
    \gtcontinue
  }{
    \usebox{\continueBox}
  }{
  }
\end{mathpar}

\subsection{Expressions}

We will use the convention that $\left<\psuite, \meaningof{\pexpr}\right>$ is to be interpreted as
$\left<\psuite || \psuite_{(\pexpr)}, \pexpr_{(\pexpr)}\right>$.

\newsavebox{\andBox}
\begin{lrbox}{\andBox}
\begin{python}
$\tfreshvar$ = $\pexpr_1$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Boolean expression (And)}{
    \pexpr_1 \gtand \pexpr_2
  }{
    \left<\usebox{\andBox}\hspace{20pt},
    \meaningof{\pexpr_2 \gtif \tfreshvar \gtelse \tfreshvar}\right>
  }{
  }
\end{mathpar}

\newsavebox{\orBox}
\begin{lrbox}{\orBox}
\begin{python}
$\tfreshvar$ = $\pexpr_1$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Boolean expression (Or)}{
    \pexpr_1 \gtor \pexpr_2
  }{
    \left<\usebox{\orBox}\hspace{18pt},
    \meaningof{\tfreshvar \gtif \tfreshvar \gtelse \pexpr_2}\right>
  }{
  }
\end{mathpar}

\newsavebox{\binopBox}
\begin{lrbox}{\binopBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pexpr_2)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Binary Operation}{
    \pexpr_1 \pbinop \pexpr_2
  }{
    \left<\usebox{\binopBox}\hspace{25pt}, \pexpr_{(\pexpr_1)}.\mathtt{opFunc}(\pexpr_{(\pexpr_2)}) \right>
  }{
  \mbox{where }
  \mathtt{opFunc} = \osFunc{binop\_to\_func}(\pbinop)
  }
\end{mathpar}

\newsavebox{\notBox}
\begin{lrbox}{\notBox}
\begin{python}
$\psuite_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (not)}{
    \gtnot \pexpr
  }{
    \left<\usebox{\notBox}\hspace{20pt}, \gtnot \gtbool(\pexpr_{(\pexpr)})\right>
  }{
  }
\end{mathpar}

\newsavebox{\uplusBox}
\begin{lrbox}{\uplusBox}
\begin{python}
$\psuite_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (+)}{
    \gtuplus \pexpr
  }{
    \left<\usebox{\uplusBox}\hspace{20pt}, \pexpr_{(\pexpr)}.\mathtt{\_\_pos\_\_}() \right>
  }{
  }
\end{mathpar}

\newsavebox{\usubBox}
\begin{lrbox}{\usubBox}
\begin{python}
$\psuite_{(\pexpr)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Unary Operation (-)}{
    \gtusub \pexpr
  }{
    \left<\usebox{\usubBox}\hspace{20pt}, \pexpr_{(\pexpr)}.\mathtt{\_\_neg\_\_}() \right>
  }{
  }
\end{mathpar}

\newsavebox{\ifExpBox}
\begin{lrbox}{\ifExpBox}
\begin{python}
$\psuite_{(\pexpr_2)}$
if $\pexpr_{(\pexpr_2)}$:
  $\psuite_{(\pexpr_1)}$
  $\tfreshvar$ = $\pexpr_{(\pexpr_1)}$
else:
  $\psuite_{(\pexpr_3)}$
  $\tfreshvar$ = $\pexpr_{(\pexpr_3)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{If expression}{
    \pexpr_1 \gtif \pexpr_2 \gtelse \pexpr_3
  }{
    \left< \usebox{\ifExpBox}\hspace{30pt}, \tfreshvar \right>
  }{
  }
\end{mathpar}

\newsavebox{\compareBox}
\begin{lrbox}{\compareBox}
\begin{python}
$\meaningof{\tfreshvar_1 = \pexpr_1}$
$\meaningof{\tfreshvar_2 = \pexpr_2}$
$\tfreshvar_3$ = $\tfreshvar_1.\mathtt{opFunc}(\tfreshvar_2)$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Comparison operator}{
    \pexpr_1 \pcmpop_1 \pexpr_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n
  }{
    \left< \usebox{\compareBox}\hspace{30pt},
    \meaningof{(\tfreshvar_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n) \gtif
    \tfreshvar_3 \gtelse \tfreshvar_3} \right>
  }{
    \mbox{where } \pcmpop_1 \mbox { is not } \gtis, \gtis \gtnot,\mbox{ or } \gtnot \gtin,
    \mathtt{opFunc} = \osFunc{cpmop\_to\_func}(\pbinop)
  }
\end{mathpar}

\newsavebox{\compareIsBox}
\begin{lrbox}{\compareIsBox}
\begin{python}
$\meaningof{\tfreshvar_1 = \pexpr_1}$
$\meaningof{\tfreshvar_2 = \pexpr_2}$
$\tfreshvar_3$ = $\tfreshvar_1 \gtis \tfreshvar_2$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Comparison operator (is)}{
    \pexpr_1 \gtis \pexpr_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n
  }{
    \left< \usebox{\compareIsBox}\hspace{30pt},
    \meaningof{(\tfreshvar_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n) \gtif
    \tfreshvar_3 \gtelse \tfreshvar_3} \right>
  }{
  }
\end{mathpar}

\newsavebox{\compareIsNotBox}
\begin{lrbox}{\compareIsNotBox}
\begin{python}
$\meaningof{\tfreshvar_1 = \pexpr_1}$
$\meaningof{\tfreshvar_2 = \pexpr_2}$
$\tfreshvar_3$ = $\gtnot$($\tfreshvar_1 \gtis \tfreshvar_2$)
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Comparison operator (is not)}{
    \pexpr_1 (\gtis \gtnot) \pexpr_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n
  }{
    \left< \usebox{\compareIsNotBox}\hspace{30pt},
    \meaningof{(\tfreshvar_2 \pcmpop_2 \ldots \pcmpop_{n-1} \pexpr_n) \gtif
    \tfreshvar_3 \gtelse \tfreshvar_3} \right>
  }{
  }
\end{mathpar}

\newsavebox{\callBox} % No, not the blue one
\begin{lrbox}{\callBox}
\begin{python}
$\psuite_{(\pexpr)}$
$\psuite_{(\pexpr_1)}$
...
$\psuite_{(\pexpr_n)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Function call}{
    \pexpr \gtopar \pexpr_1, \ldots \pexpr_n \gtcpar
  }{
    \left< \usebox{\callBox}\hspace{10pt},
    \pexpr_{(\pexpr)}(\pexpr_{(\pexpr_{(\pexpr_1)}, \ldots, \pexpr_{(\pexpr_n)})}) \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Attribute access}{
    \pexpr.\pvariable
  }{
    \left< \psuite_{(\pexpr)} , \pexpr_{(\pexpr)}.\pvariable \right>
  }{
  \mbox{where } \pexpr \mbox{ is a number, string, boolean or identifier}
  }
\end{mathpar}

\newsavebox{\listBox}
\begin{lrbox}{\listBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
...
$\psuite_{(\pexpr_n)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{List expression}{
    \gtobrk \pexpr_1, \ldots, \pexpr_n \gtcbrk
  }{
    \left< \usebox{\listBox}\hspace{5pt}, \gtobrk \pexpr_{(\pexpr_1)}, \ldots, \pexpr_{(\pexpr_n)} \gtcbrk \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Tuple expression}{
    \gtopar \pexpr_1, \ldots, \pexpr_n \gtcpar
  }{
    \left< \usebox{\listBox}\hspace{5pt}, \gtopar \pexpr_{(\pexpr_1)}, \ldots, \pexpr_{(\pexpr_n)} \gtcpar \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{None expression}{
    \gtNone
  }{
    \left< [] , \mathtt{*None} \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Literal expression}{
    \pexpr
  }{
    \left< [] , \pexpr \right>
  }{
  }
\end{mathpar}

\begin{mathpar}
  \translationRule{Slice (index)}{
    \pslice
  }{
    \left< [] , \meaningof{\pexpr} \right>
  }{
    \mbox{where} \pslice \gteq \pexpr
  }
\end{mathpar}

\newsavebox{\sliceBox}
\begin{lrbox}{\sliceBox}
\begin{python}
$\psuite_{(\pexpr_1)}$
$\psuite_{(\pexpr_2)}$
$\psuite_{(\pexpr_3)}$
\end{python}
\end{lrbox}

\begin{mathpar}
  \translationRule{Slice (slice)}{
    \pexpr_1 \gtcolon \pexpr_2 \gtcolon \pexpr_3
  }{
    \left< \usebox{\sliceBox}\hspace{20pt},
    \mathtt{slice}(\pexpr_{(\pexpr_1)}, \pexpr_{(\pexpr_2)}, \pexpr_{(\pexpr_3)}) \right>
  }{
    \mbox{where } \psuite_{(\pexpr_i)} \mbox{ is empty and } \pexpr_{(\pexpr_i)}
    \mbox{ is } \mathtt{*None} \mbox{ if } \pexpr_i \mbox{ is omitted}
  }
\end{mathpar}

\subsection{Helper function definitions}
\begin{definition}[Binary Operators]
  \begin{flalign*}
  \begin{array}[t]{ c | c c }
   \pbinop & \osFunc{Binop\_to\_func}(\pbinop) & \osFunc{Binop\_to\_ifunc}(\pbinop) \\
   \hline
   \gtplus & \_\_add\_\_ & \_\_iadd\_\_ \\
   \gtsub & \_\_sub\_\_ & \_\_isub\_\_ \\
   \gtmult & \_\_mul\_\_ & \_\_imul\_\_ \\
   \gtdiv & \_\_div\_\_ & \_\_idiv\_\_ \\
   \gtmod & \_\_mod\_\_ & \_\_imod\_\_ \\
   \gtpow & \_\_pow\_\_ & \_\_ipow\_\_ \\
  \end{array}
  \end{flalign*}
\end{definition}

\begin{definition}[Comparison Operators]
  \begin{flalign*}
  \begin{array}[t]{ c | c c }
   \pbinop & \osFunc{Cmpop\_to\_func}(\pbinop) \\
   \hline
   \gteq & \_\_eq\_\_ \\
   \gtneq & \_\_ne\_\_ \\
   \gtle & \_\_lt\_\_ \\
   \gtleq & \_\_le\_\_ \\
   \gtge & \_\_gt\_\_ \\
   \gtgeq & \_\_ge\_\_ \\
   \gtin & \_\_contains\_\_ \\
  \end{array}
  \end{flalign*}
\end{definition}

\begin{definition}[Comparison Operators]
  \begin{flalign*}
  \osFunc{Add\_Return}(\psuite) = \psuite || \gtobrk \gtreturn \gtNone \gtcbrk
  \end{flalign*}
\end{definition}


\end{document}
