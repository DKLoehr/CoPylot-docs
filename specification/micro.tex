\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

% TODO: Fix program state representation.

\begin{document}


        \begin{figure}\center
              \begin{grammar}
                \grule[variables]{\ovariable}{\osType{alphanumeric} \gor \star \osType{alphanumeric}}
                \grule[general labels]{\oglbl}{\olbl \gor \osplat}
                \grule[labels]{\olbl}{}
                \grule[stack]{\ostack}{
                            [\ostackframe,\ldots]
                }
                \grule[stack frames]{\ostackframe}{
                            \osLR{\opscope,\oglbl,\oprogram}
                }
                \grule[programs]{\oprogram}{
                            [\ostmt,\ldots]
                }
                \grule[clauses]{\ostmt}{\olbl:\oglbl:\odirective}
                % statements
                \grule[directives]{\odirective}{
                            \ovariable \gteq \oexpr % x = e
                    \gor    \okw{return} \ovariable % return x
                    \gor    \okw{goto} \olbl % goto x
                    \gor    \okw{goto} \olbl \okw{if not} \ovariable % goto x if not v
                    \gline
                    \gor    \okw{raise} \ovariable % raise x
                    \gor    \okw{catch} \ovariable % catch x
                    \gor    \okw{pass} % pass
                }
                \grule[bindings]{\obinding}{\{\ovariable \mapsto \omem, \ldots\}}
                \grule[heap]{\oheap}{\{\omem \mapsto \ovalue, \ldots\}}
                % value types
                \grule[values]{\ovalue}{
                            \mathbb{Z}
                    \gor    [\omem, \ldots] % [m, ...]
                    \gor    (\omem, \ldots) % (m, ...)
                    \gor    \obinding % B
                    \gor    \ogenf
                    \gor    \ogenm
                    % \gor    \osnone
                    \gor    \osplat
                }
                % expressions
                \grule[expressions]{\oexpr}{
                            \ovalue
                    \gor    \ovariable % x
                    \gor    \okw{def} \ovariable(\ovariable,\ldots) \gteq \{ \oprogram \} % def x(x, ...) = {S}
                    \gor    \ovariable(\ovariable, \ldots) % x(x, ...)
                    \gor    \ovariable.\ovariable % x.x
                    \gor    [\ovariable, \ldots] % [x, ...]
                    \gor    (\ovariable, \ldots) % (x, ...)
                }
                \grule[microcode stack]{\omstack}{[\omcode,\ldots]}
                \grule[microcode literal stack]{\olstack}{[\olcode,\ldots]}
                \grule[microcode commands]{\omcode}{
                            \osMC{Store}
                    \gor    \osMC{Wrap}
                    \gor    \osMC{Bind}
                    \gor    \osMC{LookUp}
                    \gor    \osMC{List} \;n
                    \gor    \osMC{Tuple} \;n
                    \gline
                    \gor    \osMC{Advance}
                    \gor    \osMC{Pop}
                    \gor    \osMC{Push} \;\oprogram
                    \gor    \osMC{Raise}
                    \gor    \osMC{Goto} \;\olbl
                    \gor    \osMC{Gotoifn} \;\olbl
                    % \gor    \osMC{Ignore}
                    \gline
                    \gor    \osMC{Call} \;n
                    \gor    \osMC{Retrieve}
                    \gor    \osMC{AllocNameError}
                    \gor    \osMC{AllocTypeError}
                    \gor    \osMC{AllocAttrError}
                }
                \grule[microcode literals]{\olcode}{
                            \ovariable
                    \gor    \omem
                    \gor    \ovalue
                }
                \grule[parental map]{\oparent}{\omem \mapsto \omem}
                \grule[general memory locations]{\ogmem}{
                            \omem
                    \gor    \opscope
                    \gor    \osplat
                }
                \grule[memory locations]{\opscope, \omem}{
                            \osType{<address>}
                    % \gor    \osnone
                }
                \grule[general functions]{\ogenf}{
                            \osLR{ \opscope,\okw{def}(\ovariable, \ldots) \ofuncarr \oprogram } % < scope, def (x) -> S >
                    \gor    \omagicf
                    \gor    \omagicm
                }
                \grule[general methods]{\ogenm}{
                            \osLR{ \omem, \ogenf } % < m, F >
                }
                \grule[magic functions]{\omagicf, \omagicm}{}
                \grule[integers]{n}{}

              \end{grammar}
              \caption{Expression Grammar}
              \label{fig_langExpr}
          \end{figure}


          \begin{figure}\center
                \begin{grammar}
                  \grule[heap]{\osInit{\oheap}}{}

                \end{grammar}
                \caption{Initialization}
                \label{fig_langinit}
            \end{figure}


      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Store \ovalue}{
                  \omem \notin \oheap \\
                  \oheap' = \oheap[\omem \mapsto \ovalue]
              }{
                  \oparent, \olstack \listConcat [\ovalue, \osMC{Store}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\omem] \listConcat \omstack, \ostack, \oheap'
              }

              \relationRule{Wrap \omem}{
                  \ovalue = \osGetObj(\oheap, \omem)
              }{
                  \oparent, \olstack \listConcat [\omem, \osMC{Wrap}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Bind \omem \! to \ovariable}{
                  \obinding = \oheap[\opscope] \\
                  \obinding' = \obinding[\ovariable \mapsto \omem] \\
                  \oheap' = \oheap[\opscope \mapsto \obinding']
              }{
                  \oparent, \olstack \listConcat [\omem, \ovariable, \osMC{Bind}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, \ostack, \oheap'
              }

              \relationRule{Advance}{
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective \\
                  \olbl \osBefore{\oprogram} \oglbl''
              }{
                  \oparent, \olstack \listConcat [\osMC{Advance}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, [\osLR{\opscope, \oglbl'', \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Pop}{
                  % \opscope' = \oparent[\opscope]
              }{
                  \oparent, \olstack \listConcat [\osMC{Pop}] \listConcat \omstack, \ostackframe \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Push \oprogram}{
                  \oparent' = \oparent[\opscope' \mapsto \opscope], \opscope' \notin \oparent \\
                  \oprogram = [\olbl:\oglbl':\odirective, \ldots]
              }{
                  \oparent, \olstack \listConcat [\opscope, \osMC{Push} \;\oprogram] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent', \olstack \listConcat \omstack, [\osLR{\opscope', \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Look up \ovariable \,(bound)}{
                  % \obinding = \oheap[\opscope] \\
                  \osLookup(\oparent, \oheap, \opscope, \ovariable) = \omem
              }{
                  \oparent, \olstack \listConcat [\ovariable, \osMC{LookUp}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\omem] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Look up \ovariable \,(NameError)}{
                  \osLookup(\oparent, \oheap, \opscope, \ovariable) = \osplat
              }{
                  \oparent, \olstack \listConcat [\ovariable, \osMC{LookUp}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, [\osMC{AllocNameError}, \osMC{Raise}], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Make List}{
                  \ovalue = [\omem_1, \ldots, \omem_n]
              }{
                  \oparent, \olstack \listConcat [\omem_1, \ldots, \omem_n, \osMC{List}\;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Make Tuple}{
                  \ovalue = (\omem_1, \ldots, \omem_n)
              }{
                  \oparent, \olstack \listConcat [\omem_1, \ldots, \omem_n, \osMC{Tuple}\;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

            \end{mathpar}
            \caption{Microcommands}
            \label{fig_langMicro}
          \end{figure}

          \begin{figure}\center
              \begin{mathpar}

              \relationRule{Raise \,(no exception label)}{
                  \oprogram(\olbl) = \olbl:\osplat: \odirective \\
              }{
                  \oparent, \olstack \listConcat [\osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\osMC{Pop}, \osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Raise \,(caught)}{
                  \oprogram(\olbl) = \olbl:\olbl_0: \odirective \\
                  \oprogram(\olbl_0) = \olbl_0:\olbl_1: \okw{catch} x \\
                  \omstack' = [\ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, \olstack \listConcat [\osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack' \listConcat \omstack, [\osLR{\opscope, \olbl_0, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto \olbl}{
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \oparent, \olstack \listConcat [\osMC{Goto}\;\olbl] \listConcat \omstack, [\osLR{\opscope, \olbl', \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(success)}{
                  \oheap[\omem] = \osfalse \\
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \oparent, \olstack \listConcat [\omem, \osMC{Gotoifn}\;\olbl] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\osMC{Goto}] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(failure)}{
                  \oheap[\omem] = \ostrue
              }{
                  \oparent, \olstack \listConcat [\omem, \osMC{Gotoifn}\;\olbl] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\osMC{Advance}] \listConcat \omstack, \ostack, \oheap
              }

              % \relationRule{Ignore \olcode}{
              % }{
              %     \oparent, \olstack \listConcat [\omem, \osMC{Ignore}] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, \olstack \listConcat \omstack, \ostack, \oheap
              % }

              \relationRule{Call function \omem}{
                  % \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                  \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                  \omstack' = [\opscope, \osMC{Push}\;\oprogram, \omem_1, \ovariable_1, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
              }{
                  \oparent, \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Call function (wrong args)}{
                  \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \oprogram } q \neq n
                  % \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \oprogram }, q \neq n
              }{
                  \oparent, \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              }

              \relationRule{Get Call}{
                  \ovalue = \osGetCall(\oheap, \omem_0) % returns F,M
                  \omstack' = [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert}]
              }{
                  \oparent, \olstack \listConcat [\omem_0, \ldots, \omem_n, \osMC{GetCall} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Get Call (TypeError)}{
                  \osplat = \osGetCall(\oheap, \omem_0) % returns *
              }{
                  \oparent, \olstack \listConcat [\omem_0, \ldots, \omem_n, \osMC{GetCall} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              }

              \relationRule{Convert Function}{
              }{
                  \oparent, \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap
              }

              % \relationRule{Call method \omem}{
              %     \oheap[\omem] = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
              %     \omstack' = [\opscope, \osMC{Push}\;\oprogram, \omem_0, \ovariable_0, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
              % }{
              %     \oparent, \olstack \listConcat [\omem, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              % }
              %
              % \relationRule{Call method (wrong args)}{
              %     \oheap[\omem] = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_q) \ofuncarr \oprogram }, q \neq n
              % }{
              %     \oparent, \olstack \listConcat [\omem, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              % }

              \relationRule{Retrieve \ovariable}{
                  \osFunc{LookupObj}(\oparent, \oheap, \omem, \ovariable) = \omem'
              }{
                  \oparent, \olstack \listConcat [\omem, \ovariable, \osMC{Retrieve}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\omem'] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Retrieve \ovariable \,(AttributeError)}{
                  \osFunc{LookupObj}(\oparent, \oheap, \omem, \ovariable) = \osplat
              }{
                  \oparent, \olstack \listConcat [\omem, \ovariable, \osMC{Retrieve}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, [\osMC{AllocAttrError}, \osMC{Raise}], \ostack, \oheap
              }

          \end{mathpar}
          \caption{Microcommands (cont.)}
          \label{fig_langMicro}
      \end{figure}

      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Literal Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \mathbb{Z} \\
                  % \osFunc{Valueofliteral}(\oexpr) = \ovalue \\
                  \omstack = [\ovalue, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \tnote{TODO: make literal category (ints, str, bool, None)}

              \relationRule{Name Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable_1 = \ovariable_2 \\
                  \omstack = [\ovariable_2, \osMC{Lookup}, \ovariable_1, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{List Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable = [\ovariable_1, \ldots, \ovariable_n] \\
                  \omstack = [(\ovariable_1, \osMC{LookUp}), \ldots, (\ovariable_n, \osMC{LookUp}), \osMC{List} \; n, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \tnote{Parentheses in \omstack group instructions together for convenience of reading.}

              \relationRule{Tuple Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable = [\ovariable_1, \ldots, \ovariable_n] \\
                  \omstack = [(\ovariable_1, \osMC{LookUp}), \ldots, (\ovariable_n, \osMC{LookUp}), \osMC{Tuple} \; n, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{FunctionDef Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl': \ovariable = \okw{def} (\ovariable_1, \ldots, \ovariable_n) = \{\oprogram'\} \\
                  \ovalue = \osLR{ \opscope, \okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram' } \\
                  \omstack = [\ovalue, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Attribute Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_1.\ovariable_2 \\
                  \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{Retrieve}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Call Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
                  \omstack = [\ovariable_0, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{GetCall} \;n]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

          \end{mathpar}
          \caption{Operational Semantics: Assignment}
          \label{fig_langOS}
      \end{figure}

      % \begin{figure}\center
      %     \begin{mathpar}
              %
              % \relationRule{Method Call}{
              %     \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_1.\ovariable_0(\ovariable_2,\ldots,\ovariable_n) \\
              %     \omstack = [\ovariable_1, \osMC{Lookup}, \ovariable_0, \osMC{Retrieve}, \ovariable_2, \osMC{Lookup}, \ldots, \ovariable_n, \osMC{Lookup},  \osMC{Call} \;n]
              % }{
              %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }
      %     \end{mathpar}
      %     \caption{Operational Semantics: Call}
      %     \label{fig_langOS}
      % \end{figure}

      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Pass}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{pass} \\
                  \omstack = [\osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Return}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{return} \ovariable \\
                  \ostack = [\osLR{ \opscope', \olbl'',\oprogram' }] \listConcat \ostack' \\
                  \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable' = \oexpr \\
                  \omstack = [\ovariable, \osMC{LookUp}, \osMC{Pop}, \ovariable', \osMC{Bind},\osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{goto} \olbl'' \\
                  \omstack = [\osMC{Goto} \;\olbl'']
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{GotoIfNot}{
                  \oprogram(\olbl) = \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
                  \omstack = [\ovariable, \osMC{Lookup}, \osMC{Gotoifn} \;\olbl'']
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              % \relationRule{Name Statement}{
              %     \oprogram(\olbl) = \olbl:\olbl' : \ovariable \\
              %     \omstack = [\ovariable_1, \osMC{Lookup}, \osMC{Ignore}, \osMC{Advance}]
              % }{
              %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }

              \relationRule{End of Function}{
                  \ostackframe = \osLR{ \opscope', \olbl, \oprogram' } \\
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \oexpr \\
                  \omstack = [\osMC{Pop}, \omem_{\osnone}, \ovariable, \osMC{Bind},  \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \osplat, \oprogram}, \ostackframe] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \osplat, \oprogram}, \ostackframe] \listConcat \ostack, \oheap
              }

              \tnote{$\omem_{\osnone}$ is a memory location reserved for \osnone.}

              \relationRule{End of Program}{
                  \ostack = [\osLR{\opscope, \osplat, \oprogram}]
                  \omstack = [\osMC{Pop}]
              }{
                  \oparent, [\;], \ostack, \oheap \osTransition
                  \oparent, \omstack, \ostack, \oheap
              }

          \end{mathpar}
          \caption{Operational Semantics: Flow}
          \label{fig_langOS}
      \end{figure}

      \begin{figure}

          % TODO: add lookup rule
          % Lookup
          \begin{definition}
            $$
              \osLookup(\oparent,\oheap,\opscope,\ovariable) =
              \tnote{todo}
            $$
          \end{definition}

          % LookupObj
          \begin{definition}
            $$
              \osFunc{LookupObj}(\oparent,\oheap,\omem,\ovariable) =
              \tnote{todo}
            $$
          \end{definition}

          % GetObj
          \begin{definition}
              \begin{equation}
                \osGetObj (\oheap, \omem) =
                  \begin{cases}
                    \obinding, & \text{if}\ \ovalue = \obinding \\
                    \obinding = {\ostarvalue{value} \mapsto \ovalue}, & \text{otherwise}
                  \end{cases}
                  , \oheap[\omem] = \ovalue
                \end{equation}
          \end{definition}

          % GetCall
          \begin{definition}
            $\oheap[\omem] = \obinding
            , \obinding[\ostarvalue{value}] = \ovalue$
              \begin{equation}
                \osGetCall (\oheap, \omem) =
                  \begin{cases}
                    % % CASE method
                    % \osLR{\osLR{ \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram }, [\omem_0]}
                    % , & \text{if }\ \ovalue = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                    %
                    % CASE function & method
                    \ovalue, & \text{if } \ovalue = \ogenf \;|\; \ogenm \\
                    % CASE otherwise
                    \osplat, & \text{otherwise}
                  \end{cases}
                \end{equation}
          \end{definition}

        \caption{Helper Functions}
        \label{fig_langhelper}
    \end{figure}
\end{document}
