\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

% TODO: Fix program state representation.

\begin{document}
  \section{Operational Semantics}

        \subsection{Grammar}
            \begin{grammar}
              \grule[variables]{\ovariable}{\osType{alphanumeric} \gor \star \osType{alphanumeric}}
              \grule[general labels]{\oglbl}{\olbl \gor \osplat}
              \grule[labels]{\olbl}{}
              \grule[stack]{\ostack}{
                          [\ostackframe,\ldots]
              }
              \grule[stack frames]{\ostackframe}{
                          \osLR{\opscope,\oglbl}
              }
              \grule[programs]{\oprogram}{
                          [\ostmt,\ldots]
              }
              \grule[clauses]{\ostmt}{\olbl:\oglbl:\odirective}
              % statements
              \grule[directives]{\odirective}{
                          \ovariable \gteq \oexpr % x = e
                  \gor    \okw{return} \ovariable % return x
                  \gor    \okw{goto} \olbl % goto x
                  \gor    \okw{goto} \olbl \okw{if not} \ovariable % goto x if not v
                  \gline
                  \gor    \okw{raise} \ovariable % raise x
                  \gor    \okw{catch} \ovariable % catch x
                  \gor    \okw{pass} % pass
              }
              \grule[bindings]{\obinding}{\{\ovariable \mapsto \omem, \ldots\}}
              \grule[heap]{\oheap}{\{\omem \mapsto \ovalue, \ldots\}}

              % value types
              \grule[values]{\ovalue}{
                          \mathbb{Z}
                  \gor    \mathbb{S}
                  \gor    [\omem, \ldots] % [m, ...]
                  \gor    (\omem, \ldots) % (m, ...)
                  \gor    \obinding % B
                  \gor    \ogenf
                  \gor    \ogenm
                  % \gor    \osnone
                  \gor    \osplat
              }

              % expressions
              \grule[expressions]{\oexpr}{
                          \mathbb{Z} % int
                  \gor    \mathbb{S} % string
                  %\gor    \osnone % None
                  \gor    \ovariable % x
                  \gor    \okw{def} (\ovariable,\ldots)\{ \oprogram \} % def x(x, ...) = {S}
                  \gor    \ovariable(\ovariable, \ldots) % x(x, ...)
                  \gor    \ovariable.\ovariable % x.x
                  \gor    [\ovariable, \ldots] % [x, ...]
                  \gor    (\ovariable, \ldots) % (x, ...)
              }
              \grule[microcode stack]{\omstack}{[\omcode,\ldots]}
              \grule[microcode literal stack]{\olstack}{[\olcode,\ldots]}
              \grule[microcode instructions]{\omcode}{
                          \osMC{Store}
                  \gor    \osMC{Wrap}
                  \gor    \osMC{Bind}
                  \gor    \osMC{LookUp}
                  \gor    \osMC{List} \;n
                  \gor    \osMC{Tuple} \;n
                  \gline
                  \gor    \osMC{Advance}
                  \gor    \osMC{Pop}
                  \gor    \osMC{Push} \;\olbl
                  \gor    \osMC{Raise}
                  \gor    \osMC{Goto} \;\olbl
                  \gor    \osMC{Gotoifn} \;\olbl
                  % \gor    \osMC{Ignore}
                  \gline
                  \gor    \osMC{Call} \;n
                  % \gor    \osMC{GetCall} \;n
                  \gor    \osMC{Convert} \;n
                  \gor    \osMC{Retrieve}
                  \gor    \osMC{Get}
                  \gor    \osMC{Assign}
                  \gline
                  \gor    \osMC{AllocNameError}
                  \gor    \osMC{AllocTypeError}
                  \gor    \osMC{AllocAttrError}
              }
              \grule[microcode literals]{\olcode}{
                          \ovariable
                  \gor    \omem
                  \gor    \ovalue
              }
              % \grule[parental map]{\oparent}{\omem \mapsto \omem}
              \grule[general memory locations]{\ogmem}{
                          \omem
                  \gor    \opscope
                  \gor    \osplat
              }
              \grule[memory locations]{\opscope, \omem}{
                          \osType{<address>}
                  % \gor    \osnone
              }
              \grule[general functions]{\ogenf}{
                          \osLR{ \opscope,\okw{def}(\ovariable, \ldots) \ofuncarr \olbl } % < scope, def (x) -> S >
                  \gor    \omagicf
                  \gor    \omagicm
              }
              \grule[general methods]{\ogenm}{
                          \osLR{ \omem, \ogenf } % < m, F >
              }
              \grule[magic functions]{\omagicf, \omagicm}{
                          \osMagic{CallFunc}
                  \gor    \osMagic{Type}
                  \gor    \osMagic{IntAdd}
                  \gor    \osMagic{IntNeg}
                  \gor    \osMagic{StrAdd}
                  \gor    \osMagic{StrContains}
              }
              \grule[integers]{n}{}

            \end{grammar}

          \begin{definition} Initialization
            \begin{flalign*}
            \osI{\osInit{\oheap}}{
                \{
                      \osInit{\opscope} \mapsto \osInit{\obinding},
                      \omem_{\osnone} \mapsto \{\;\},
                      \omem_{\texttt{AttrError}} \mapsto \{\;\},
                      \omem_{\texttt{FunType}} \mapsto \{\;\},
                      \omem_{\texttt{MetType}} \mapsto \{\;\}, \\
                      &
                      \omem_{\texttt{IntType}} \mapsto \{\;\},
                      \omem_{\texttt{StrType}} \mapsto \{\;\},
                      \omem_{\texttt{LstType}} \mapsto \{\;\},
                      \omem_{\texttt{TplType}} \mapsto \{\;\},
                      \osMem{GetAttribute} \mapsto \obinding, \\
                      &
                      \osMem{SetAttr} \mapsto \obinding,
                \}
            } \\
            \osI{\osInit{\obinding}}{
                \{
                      \star\osnone \mapsto \omem_{\osnone},
                      \osType{AttributeError} \mapsto \osMem{AttrError},
                      \osType{FunctionType} \mapsto \osMem{FunType}, \\
                      &
                      \osType{MethodType} \mapsto \osMem{MetType},
                      \osType{IntType} \mapsto \osMem{IntType},
                      \osType{StringType} \mapsto \osMem{StrType}, \\
                      &
                      \osType{ListType} \mapsto \osMem{LstType},
                      \osType{TupleType} \mapsto \osMem{TplType},
                \}
            } \\
            \osI{\osInit{\ostackframe}}{\osLR{\osInit{\opscope}, \osInit{\olbl}, \osInit{\oprogram}}} \\
            \osI{\osInit{\ostack}}{[\osInit{\ostackframe}]} \\
            % \osI{\osInit{\oparent}}{\{\;\}} \\
            % \osI{\omagicf}{\{\;\}} \\
            % \osI{\omagicm}{\{\;\}} \\
            % \osI{\osFunc{GetCall}}{\osLR{\opscope, \okw{def}(f) \ofuncarr
          \end{flalign*}
          % \text{\tnote{"if \$1 == None then return getattribute(o.\osClown{class},a) else return \$1"}} \\
          % \tnote{todo: add builtin mappings $\omem \mapsto \ogenf$}
          \text{\tnote{We need to specify what GetAttribute is.}} \\
          \end{definition}

      \subsection{Micro-Instruction Rules}
          \begin{mathpar}

              \relationRule{Store \ovalue}{
                  \omem \notin \oheap \\
                  \oheap' = \oheap[\omem \mapsto \ovalue]
              }{
                  \osInStack{\ovalue, \osMC{Store}}, \ostack, \oheap \osTransition
                  \osInStack{\omem}, \ostack, \oheap'
              }

              \relationRule{Wrap \ovalue \! in \omem}{
                  \ovalue' = \osGetObj(\omem, \ovalue)
              }{
                  \osInStack{\omem, \ovalue, \osMC{Wrap}}, \ostack, \oheap \osTransition
                  \osInStack{\ovalue'}, \ostack, \oheap
              }

              \relationRule{Bind \omem \! to \ovariable}{
                  \obinding = \oheap[\opscope] \\
                  \obinding' = \obinding[\ovariable \mapsto \omem] \\
                  \oheap' = \oheap[\opscope \mapsto \obinding']
              }{
                  \osInStack{\omem, \ovariable, \osMC{Bind}}, \ostack, \oheap \osTransition
                  \osInStack{}, \ostack, \oheap'
              }

              \relationRule{Advance}{
                  \olbl \osBefore{\oprogram} \olbl'
              }{
                  \osInStack{\osMC{Advance}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \osInStack{}, [\osLR{\opscope, \olbl'}] \listConcat \ostack, \oheap
              }

              \relationRule{Advance (end of function)}{
                  \olbl \osBefore{\oprogram} \osplat \\
                  \ostackframe = \osLR{ \opscope', \olbl' } \\
                  \oprogram(\olbl') = \olbl':\oglbl'': \ovariable \gteq \oexpr \\
                  \omstack' = [\osMC{Pop}, \omem_{\osnone}, \ovariable, \osMC{Bind},  \osMC{Advance}]
              }{
                  \osInStack{\osMC{Advance}}, [\osLR{\opscope, \olbl}, \ostackframe] \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack' \listConcat \omstack, [\osLR{\opscope, \olbl}, \ostackframe] \listConcat \ostack, \oheap
              }

              % \tnote{$\omem_{\osnone}$ is a memory location reserved for \osnone.}

              \relationRule{Advance (EOF)}{
                  \ostack = [\osLR{\opscope, \olbl}] \\
                  \olbl \osBefore{\oprogram} \osplat \\
                  \omstack' = [\osMC{Pop}]
              }{
                  \osInStack{\osMC{Advance}}, \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              }
              \\

              \relationRule{Pop}{
                  % \opscope' = \oparent[\opscope]
              }{
                  \osInStack{\osMC{Pop}}, \ostackframe \listConcat \ostack, \oheap \osTransition
                  \osInStack{}, \ostack, \oheap
              }

              \relationRule{Push \olbl}{
                  % \oparent' = \oparent[\opscope' \mapsto \opscope], \opscope' \notin \oparent \\
                  \oheap' = \oheap[\opscope' \mapsto \{\ostarvalue{parent} \mapsto \opscope\}],  \opscope' \notin \oheap
                  % \oprogram = [\olbl:\oglbl':\odirective, \ldots]
              }{
                  \osInStack{\opscope, \osMC{Push} \;\olbl}, \ostack, \oheap \osTransition
                  \osInStack{}, [\osLR{\opscope', \olbl}] \listConcat \ostack, \oheap'
              }

              \relationRule{Look up \ovariable \,(bound)}{
                  % \obinding = \oheap[\opscope] \\
                  \osLookup(\oheap, \opscope, \ovariable) = \omem
              }{
                  \osInStack{\ovariable, \osMC{LookUp}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \osInStack{\omem}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Look up \ovariable \,(NameError)}{
                  \osLookup(\oheap, \opscope, \ovariable) = \osplat
              }{
                  \osInStack{\ovariable, \osMC{LookUp}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  [\osMC{AllocNameError}, \osMC{Raise}], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Make List}{
                  \ovalue = [\omem_1, \ldots, \omem_n]
              }{
                  \osInStack{\omem_1, \ldots, \omem_n, \osMC{List}\;n}, \ostack, \oheap \osTransition
                  \osInStack{\ovalue}, \ostack, \oheap
              }
            \end{mathpar}

            \begin{mathpar}
              \relationRule{Make Tuple}{
                  \ovalue = (\omem_1, \ldots, \omem_n)
              }{
                  \osInStack{\omem_1, \ldots, \omem_n, \osMC{Tuple}\;n}, \ostack, \oheap \osTransition
                  \osInStack{\ovalue}, \ostack, \oheap
              }

              \relationRule{Raise \,(no exception label)}{
                  \oprogram(\olbl) = \olbl:\osplat: \odirective \\
              }{
                  \osInStack{\osMC{Raise}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \osInStack{\osMC{Pop}, \osMC{Raise}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Raise \,(caught)}{
                  \oprogram(\olbl) = \olbl:\olbl_0: \odirective \\
                  \oprogram(\olbl_0) = \olbl_0:\olbl_1: \okw{catch} \ovariable \\
                  \omstack' = [\ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \osInStack{\osMC{Raise}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack' \listConcat \omstack, [\osLR{\opscope, \olbl_0}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto \olbl}{
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \osInStack{\osMC{Goto}\;\olbl}, [\osLR{\opscope, \olbl'}] \listConcat \ostack, \oheap \osTransition
                  \osInStack{}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(success)}{
                  \oheap[\omem] = \osfalse \\
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \osInStack{\omem, \osMC{Gotoifn}\;\olbl}, \ostack, \oheap \osTransition
                  \osInStack{\osMC{Goto}\;\olbl}, \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(failure)}{
                  \oheap[\omem] = \ostrue
              }{
                  \osInStack{\omem, \osMC{Gotoifn}\;\olbl}, \ostack, \oheap \osTransition
                  \osInStack{\osMC{Advance}}, \ostack, \oheap
              }

              % \relationRule{Ignore \olcode}{
              % }{
              %     \oparent, \osInStack{\omem, \osMC{Ignore}}, \ostack, \oheap \osTransition
              %     \oparent, \osInStack{}, \ostack, \oheap
              % }

              \relationRule{Convert Function \ovalue}{
                  \ovalue = \ogenf \\
              }{
                  \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \ostack, \oheap \osTransition
                  \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap
              }

              \relationRule{Convert Method \ovalue}{
                  \ovalue = \osLR{ \omem_0, \ogenf } \\
                  \ovalue' = \ogenf \\
              }{
                  \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \ostack, \oheap \osTransition
                  \osInStack{\ovalue', \omem_0, \omem_1, \ldots, \omem_n, \osMC{Call} \;n+1}, \ostack, \oheap
              }

              % \relationRule{Get Call \omem}{
              %     \ovalue = \oheap[\omem_0][\ostarvalue{value}], \text{\;\ovalue\, is of form \ogenm, \omagicm \;or \omagicf} \\ % F,M
              %     \omstack' = [\ovalue, \omem_1, \ldots, \omem_n]
              % }{
              %     \osInStack{\omem_0, \ldots, \omem_n, \osMC{GetCall} \;n}, \ostack, \oheap \osTransition
              %     \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              % }

              % \relationRule{Get Call (TypeError)}{
              %     \ovalue = \oheap[\omem_0][\ostarvalue{value}], \text{\;\ovalue\, is not of form \ogenm, \omagicm \;or \omagicf} % *
              % }{
              %     \osInStack{\omem_0, \ldots, \omem_n, \osMC{GetCall} \;n}, \ostack, \oheap \osTransition
              %     [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              % }

              \relationRule{Call function \omem}{
                % \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl } \\
                \omstack' = [\opscope, \osMC{Push} \;\olbl, \omem_1, \ovariable_1, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
              }{
                \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap \osTransition
                \osInStack{\omstack'}, \ostack, \oheap
              }

              \relationRule{Call function (wrong args)}{
                \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \olbl }, q \neq n
                % \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \oprogram }, q \neq n
              }{
                \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap \osTransition
                [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              }

            \end{mathpar}

            \begin{mathpar}
              % \relationRule{Convert Object \ovalue}{
              %     \ovalue = \osLR{ \omem_0, \ogenf } \\
              %     \ovalue' = \ogenf \\
              % }{
              %     \oparent, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \ostack, \oheap \osTransition
              %     \oparent, \osInStack{\ovalue', \omem_0, \omem_1, \ldots, \omem_n, \osMC{Call} \;n+1}, \ostack, \oheap
              % }

              % \relationRule{Call method \omem}{
              %     \oheap[\omem] = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
              %     \omstack' = [\opscope, \osMC{Push} \;\olbl, \omem_0, \ovariable_0, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
              % }{
              %     \oparent, \osInStack{\omem, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap \osTransition
              %     \oparent, \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              % }
              %
              % \relationRule{Call method (wrong args)}{
              %     \oheap[\omem] = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_q) \ofuncarr \oprogram }, q \neq n
              % }{
              %     \oparent, \osInStack{\omem, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap \osTransition
              %     \oparent, [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              % }

              \relationRule{Retrieve \ovariable}{
                  % \osFunc{LookupObj}(\oparent, \oheap, \omem, \ovariable) = \omem'
                  \omem' = \oheap[\omem][\ovariable] \\
                  %\omstack' = [\ovalue, \osMC{Store}]
              }{
                  \osInStack{\omem, \ovariable, \osMC{Retrieve}}, \ostack, \oheap \osTransition
                  \osInStack{\omem'}, \ostack, \oheap
              }

              \relationRule{Retrieve \ovariable \,(AttributeError)}{
                  % \osFunc{LookupObj}(\oparent, \oheap, \omem, \ovariable) = \osplat
                  \osplat = \oheap[\omem][\ovariable]
              }{
                  \osInStack{\omem, \ovariable, \osMC{Retrieve}}, \ostack, \oheap \osTransition
                  [\osMC{AllocAttrError}, \osMC{Raise}], \ostack, \oheap
              }

              \relationRule{Get \omem}{
                  \ovalue = \oheap[\omem]
              }{
                  \osInStack{\omem, \osMC{Get}}, \ostack, \oheap \osTransition
                  \osInStack{\ovalue}, \ostack, \oheap
              }

              \relationRule{Assign \ovalue \! to \ovariable}{
                  \omstack' = [\ovalue, \osMC{Store}, \ovalue, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}]
              }{
                  \osInStack{\ovalue, \ovariable, \osMC{Assign}}, \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              }

            % \relationRule{\_\_getattribute\_\_}{
            %     \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \ovariable'.\_\_getattribute\_\_(\ovariable'') \\
            %     \omstack = [\ovariable', \osMC{Lookup}, \ovariable'', \osMC{Retrieve}, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
            % }{
            %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
            %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
            % }
          \end{mathpar}

          \subsection{Rules}

          \begin{mathpar}

              % \relationRule{None Assignment}{
              %     \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \osnone \\
              %     \omstack = [\omem_{\osnone}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              % }{
              %     [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }

              \relationRule{Literal Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr,\,\oexpr \text{ is of form } \mathbb{Z}, \mathbb{S}\\
                  \ovalue = \oexpr \\
                  \omstack = [\ovalue, \ovariable, \osMC{Assign}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \tnote{TODO: make literal category (ints, str, bool)}

              \relationRule{Name Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable_1 \gteq \ovariable_2 \\
                  \omstack = [\ovariable_2, \osMC{Lookup}, \ovariable_1, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{List Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq [\ovariable_1, \ldots, \ovariable_n] \\
                  \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{List} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              % \tnote{Parentheses in \omstack group instructions together for convenience of reading.}

              \relationRule{Tuple Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq (\ovariable_1, \ldots, \ovariable_n) \\
                  \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Tuple} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{FunctionDef Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl': \ovariable \gteq \okw{def} (\ovariable_1, \ldots, \ovariable_n)\{\oprogram'\} \\
                  \oprogram' = [\olbl'':\olbl''':\odirective, \ldots] \\
                  \ovalue = \osLR{ \opscope, \okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl'' } \\
                  \omstack = [\ovalue, \ovariable, \osMC{Assign}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }
            \end{mathpar}

            \begin{mathpar}
              \relationRule{Attribute Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_1.\ovariable_2 \\
                  % \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{Retrieve}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
                  \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{Retrieve}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Call Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
                  % \omstack = [\ovariable_0, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{GetCall} \;n, \osMC{Convert} \;n]
                  \omstack = [\ovariable_0, \osMC{LookUp}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, \ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Convert} \;n]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

      % \begin{figure}\center
      %     \begin{mathpar}
              %
              % \relationRule{Method Call}{
              %     \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_1.\ovariable_0(\ovariable_2,\ldots,\ovariable_n) \\
              %     \omstack = [\ovariable_1, \osMC{Lookup}, \ovariable_0, \osMC{Retrieve}, \ovariable_2, \osMC{Lookup}, \ldots, \ovariable_n, \osMC{Lookup},  \osMC{Call} \;n]
              % }{
              %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }
      %     \end{mathpar}
      %     \caption{Operational Semantics: Call}
      %     \label{fig_langOS}
      % \end{figure}

              \relationRule{Raise}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{raise} \ovariable \\
                  \omstack = [\ovariable, \osMC{LookUp}, \osMC{Raise}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Pass}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{pass} \\
                  \omstack = [\osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Return}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{return} \ovariable \\
                  \ostack = [\osLR{ \opscope', \olbl''}] \listConcat \ostack' \\
                  \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable' \gteq \oexpr \\
                  \omstack = [\ovariable, \osMC{LookUp}, \osMC{Pop}, \ovariable', \osMC{Bind},\osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{goto} \olbl'' \\
                  \omstack = [\osMC{Goto} \;\olbl'']
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              \relationRule{GotoIfNot}{
                  \oprogram(\olbl) = \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
                  \omstack = [\ovariable, \osMC{Lookup}, \osMC{Gotoifn} \;\olbl'']
              }{
                  [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
              }

              % \relationRule{Name Statement}{
              %     \oprogram(\olbl) = \olbl:\olbl' : \ovariable \\
              %     \omstack = [\ovariable_1, \osMC{Lookup}, \osMC{Ignore}, \osMC{Advance}]
              % }{
              %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }



          \end{mathpar}

      \subsection{Magic}
          \begin{mathpar}
            \relationRule{Call IntAdd}{
              \ovalue = \osMagic{IntAdd} \\
              \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
              \oprogram(\olbl) = \olbl:\oglbl':\ovariable = \oexpr \\
              \ovalue_1 = \oheap[\omem_1] = \mathbb{Z} \\
              \ovalue_2 = \oheap[\omem_2] = \mathbb{Z} \\
              \ovalue_{\texttt{sum}} = \ovalue_1 + \ovalue_2 \\
              \omstack' = [\ovalue_{\texttt{sum}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
            }{
              \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
              \osInStack{\omstack'}, \ostack, \oheap
            }
          \end{mathpar}

      \subsection{Helper Functions}

          % TODO: add lookup rule
          % Lookup
          \begin{definition}
            Let $ \obinding = \oheap[\opscope] $ in
            \begin{equation}
              \osLookup(\oheap,\opscope,\ovariable) =
                \begin{cases}
                  \omem, & \text{if}\; \omem = \obinding[\ovariable] \\
                  \osLookup(\oheap,\opscope',\ovariable), & \text{if}\; \osplat = \obinding[\ovariable], \opscope' = \obinding[\ostarvalue{parent}] \\
                  \osplat, & \text{if}\; \osplat = \obinding[\ovariable], \osplat = \obinding[\ostarvalue{parent}]
                \end{cases}
              \end{equation}
          \end{definition}

          % LookupObj
          % \begin{definition}
          %   $$
          %     \osFunc{LookupObj}(\oparent,\oheap,\omem,\ovariable) =
          %     \tnote{todo}
          %   $$
          % \end{definition}

          % GetObj
          \begin{definition}
            Let $ \obinding_{\texttt{obj}} = \{
                \ostarvalue{value} \mapsto \omem, \text{\osClown{getattribute}} \mapsto \osMem{Getattribute} \} % the base object
            $ in
              \begin{equation}
                \osGetObj (\omem, \ovalue) =
                  \begin{cases}
                    \obinding, & \text{if}\; \ovalue = \obinding \\
                    % \obinding = \obinding_{\texttt{obj}}[\text{\osClown{class}} \mapsto \osMem{FunType}], & \text{if}\; \ovalue = \ogenf \\
                    \obinding_{\texttt{obj}}[\text{\osClown{class}} \mapsto \osMem{MetType}], & \text{if}\; \ovalue = \ogenm \\
                    \obinding_{\texttt{obj}}[\osClown{add} \mapsto \osMagic{IntAdd}, \osClown{neg} \mapsto \osMagic{IntNeg}], & \text{if}\; \ovalue = \mathbb{Z} \\
                    \obinding_{\texttt{obj}}[\osClown{add} \mapsto \osMagic{StrAdd}, \osClown{contains} \mapsto \osMagic{StrContains}], & \text{if}\; \ovalue = \mathbb{S} \\
                    \obinding_{\texttt{obj}}[\osClown{iter} \mapsto \osMagic{LstIter}, \osClown{contains} \mapsto \osMagic{LstContains}, & \text{if}\; \ovalue = [\omem, \ldots] \\
                    \osClown{getitem} \mapsto \osMagic{LstGetitem}] & \\
                    \obinding_{\texttt{obj}}[\osClown{iter} \mapsto \osMagic{TplIter}, \osClown{contains} \mapsto \osMagic{TplContains}], & \text{if}\; \ovalue = (\omem, \ldots) \\
                    \osClown{getitem} \mapsto \osMagic{LstGetitem}] &
                  \end{cases}
                \end{equation}
          \end{definition}
          % \tnote{getobj takes (H,m,memory location of getattribute)}
          \tnote{setattr}

          % GetCall
          % \begin{definition}
          %   $$
          %   \oheap[\omem] = \obinding
          %   , \obinding[\ostarvalue{value}] = \ovalue
          %   $$
          %     \begin{equation}
          %       \osGetCall (\oheap, \omem) =
          %         \begin{cases}
          %           % % CASE method
          %           % \osLR{\osLR{ \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram }, [\omem_0]}
          %           % , & \text{if }\ \ovalue = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
          %           %
          %           % CASE function & method
          %           \ovalue, & \text{if } \ovalue = \ogenf \;|\; \ogenm \\
          %           % CASE otherwise
          %           \osplat, & \text{otherwise}
          %         \end{cases}
          %       \end{equation}
          % \end{definition}


    \section{Graph Semantics}

      \subsection{Grammar}

      \begin{grammar}
        \grule[graph]{\ggraph}{ \{\gedge, \ldots\} }
        \grule[edges]{\gedge}{
                    \gnode \gsBefore \gnode
            \gor    \gnode \gsSkip \gnode
        }
        \grule[nodes]{\gnode}{
                    \gsstart
            \gor    \gsend
            \gor    \gsLR{\olbl, \omstack, \gtime}
            \gor    \gsLR{\genter \olbl, \gtime}
            \gor    \gsLR{\gleave \olbl, \gtime}
        }
        \grule[time stamps]{\gtime}{\mathbb{N}}

      \end{grammar}
      %
      % \begin{theorem}[Bisimulation]
      %   If $\osLR{\omstack, \ostack, \oheap} \approx \ggraph$ and $\osLR{\omstack, \ostack, \oheap} \osTransition \osLR{\omstack', \ostack', \oheap'}$, then $\ggraph \gsTransition \ggraph'$ such that $\osLR{\omstack', \ostack', \oheap'} \approx \ggraph'$.
      % \end{theorem}

      \subsection{Rules}

      \begin{mathpar}
        \relationRule{Start}{
            \oprogram = [\ostmt, \ldots] \\
            \ostmt = \olbl:\oglbl':\odirective
        }{
            \gsAddEdge{\gsstart \gsBefore \gsLR{\olbl, [\;], 0}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Literal Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable_1 \gteq \oexpr, \oexpr \text{ is of form } \mathbb{Z}, \mathbb{S}\\
            \ovalue = \oexpr \\
            \omstack = [\ovalue, \ovariable_1, \osMC{Assign}, \osMC{Advance}]
        } {
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Name Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable_1 \gteq \ovariable_2 \\
            \omstack = [\ovariable_2, \osMC{LookUp}, \ovariable_1, \osMC{Bind}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{List Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq [\ovariable_1, \ldots, \ovariable_n] \\
            \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{List} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Tuple Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq (\ovariable_1, \ldots, \ovariable_n) \\
            \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Tuple} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{FunctionDef Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl': \ovariable \gteq \okw{def} (\ovariable_1, \ldots, \ovariable_n)\{\oprogram'\} \\
            \oprogram' = [\olbl'':\olbl''':\odirective, \ldots] \\
            \ovalue = \osLR{ \opscope, \okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl'' } \\
            \omstack = [\ovalue, \ovariable, \osMC{Assign}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Attribute Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_1.\ovariable_2 \\
            \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{Retrieve}, \ovariable, \osMC{Bind}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Call Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
            \omstack = [\ovariable_0, \osMC{LookUp}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, \ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Convert} \;n]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Raise}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{raise} \ovariable \\
            \omstack = [\ovariable, \osMC{LookUp}, \osMC{Raise}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Pass}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{pass} \\
            \omstack = [\osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Return}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{return} \ovariable \\
            \ostack = [\osLR{ \opscope', \olbl''}] \listConcat \ostack' \\
            \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable' \gteq \oexpr \\
            \omstack = [\ovariable, \osMC{LookUp}, \osMC{Pop}, \ovariable', \osMC{Bind},\osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Goto}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{goto} \olbl'' \\
            \omstack = [\osMC{Goto} \;\olbl'']
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{GotoIfNot}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
            \omstack = [\ovariable, \osMC{Lookup}, \osMC{Gotoifn} \;\olbl'']
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \subsection{Micro-Instruction Rules}

      \begin{mathpar}
        \relationRule{Store}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \osMC{Store}}, \gtime} \\
            \omem = \gsFunc{Alloc}(\gnode_2)
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omem}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Wrap}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem, \ovalue, \osMC{Wrap}}, \gtime} \\
            \ovalue = \gsFunc{GetObj}(\omem, \ovalue)
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omem}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Bind}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem, \ovariable, \osMC{Bind}}, \gtime} \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Lookup}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovariable, \osMC{LookUp}}, \gtime} \\
            \gsFunc{Lookup}(\ggraph, \gnode_2, \ovariable) \ni \omem
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Lookup (NameError)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovariable, \osMC{LookUp}}, \gtime} \\
            \gsFunc{Lookup}(\ggraph, \gnode_2, \ovariable) \niton \omem
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\osMC{AllocNameError}, \osMC{Raise}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Push}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\opscope, \osMC{Push}\;\olbl'}, \gtime} \\
            \gnode_3 = \gsLR{\genter \olbl, \gtime + 1}
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gnode_3, \gnode_3 \gsBefore \gsLR{\olbl', \osInStack{}, \gtime + 2}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Pop}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Pop}}, \gtime} \\
            \gnode_3 = \gsLR{\gleave \olbl', \gtime + 1} \\
            \gsLR{\genter \olbl', \gtime'} = \gnode_0' = \gsFunc{Startof}(\gnode_2) \\
            \gnode_1' = \gsBefore \gnode_0' \\
            \gnode_4 = \gsLR{\olbl', \osInStack{}, \gtime + 2}
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gnode_3, \gnode_3 \gsBefore \gnode_4, \gnode_1' \gsSkip \gnode_4}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Advance}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Advance}}, \gtime} \\
            \olbl \osBefore{\oprogram} \olbl'
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Advance (end of function)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Advance}}, \gtime} \\
            \olbl \osBefore{\oprogram} \osplat \\
            % \gnode_3 = \gsLR{\gleave \olbl', \gtime + 1} \\
            \gsLR{\genter \olbl', \gtime'} = \gnode_0' = \gsFunc{Startof}(\gnode_2) \\
            \gsLR{\olbl'', \omstack, \gtime' - 1} = \gnode_1' = \gsBefore \gnode_0' \\
            \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable \gteq \oexpr \\
            \omstack' = [\osMC{Pop}, \omem_{\osnone}, \ovariable, \osMC{Bind},  \osMC{Advance}]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{\omstack'}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Advance (EOF)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Advance}}, \gtime} \\
            \olbl \osBefore{\oprogram} \osplat \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsend}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Make List}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem_1, \ldots, \omem_n, \osMC{List}\;n}, \gtime} \\
            \ovalue = [\omem_1, \ldots, \omem_n]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue}, \gtime + 1}}
        }

        \relationRule{Make Tuple}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem_1, \ldots, \omem_n, \osMC{Tuple}\;n}, \gtime} \\
            \ovalue = (\omem_1, \ldots, \omem_n)
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Raise (no exception label)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Raise}}, \gtime} \\
            \oprogram(\olbl) = \olbl:\osplat: \odirective \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\osMC{Pop}, \osMC{Raise}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Raise (caught)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Raise}}, \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl': \odirective \\
            \oprogram(\olbl') = \olbl':\oglbl'': \okw{catch} \ovariable
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{\ovariable, \osMC{Bind}, \osMC{Advance}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Goto}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Goto}\;\olbl'}, \gtime} \\
            \oprogram(\olbl') = \olbl':\oglbl'': \odirective
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Call function}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \gtime} \\
            \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl } \\
            \omstack' = [\opscope, \osMC{Push} \;\olbl, \omem_1, \ovariable_1, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omstack'}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Call function (wrong args)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \gtime} \\
            \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \olbl }, q \neq n
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\osMC{AllocTypeError}, \osMC{Raise}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Convert Function}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \gtime} \\
            \ovalue = \ogenf \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Convert Method}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \gtime} \\
            \ovalue = \osLR{ \omem_0, \ogenf } \\
            \ovalue' = \ogenf \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue', \omem_0, \omem_1, \ldots, \omem_n, \osMC{Call} \;n+1}, \gtime + 1}}
        }

      \end{mathpar}

      \subsection{Helper Functions}

      \begin{definition}[Value Lookup]
          Let $ \gsFunc{Lookup}(\ggraph, \gnode_0, \ovariable) = \gsSet{\ogmem, \ldots} = \gresult $ be the function returning the least set satisfying the following rules:

          \begin{itemize}
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph$, $\gnode_1 = \gstart$, then $ \gresult \supseteq \gsSet{\osplat}$.
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph, \gnode_1 = \gsLR{\olbl, \osInStack{\omem, \ovariable, \osMC{Bind}}, \gtime}$, then $\gresult \supseteq \gsSet{\omem}$.
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph, \gnode_1 = \gsLR{\olbl, \osInStack{}, \gtime}, \omstack = [\omcode_0, \ldots], \omcode_0 \in \gsSet{\osMC{Store}, \osMC{Wrap}, \osMC{LookUp}, \osMC{Advance}}$, then $\gresult \supseteq \gsFunc{Lookup}(\ggraph, \gnode_0, \ovariable)$.
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph$, $\gnode_1 = \gsLR{\olbl, \osInStack{\omem, \ovariable', \osMC{Bind}}, \gtime}, \ovariable \neq \ovariable'$, then $\gresult \supseteq \gsFunc{Lookup}(\ggraph, \gnode_0, \ovariable)$.
          \end{itemize}
      \end{definition}

      \begin{definition}[Start of Function]
          \begin{flalign*}
            \gnode_1 \gsPrecede \gnode_2 & \iff \gnode_1 \gsBefore \gnode_2 \text{ or } \gnode_1 \gsSkip \gnode_2 \\
            \gsFunc{Startof}(\gnode_n) = \gnode_0 & \iff \gsSet{\gnode_0 \gsPrecede \gnode_1 \gsPrecede \ldots \gsPrecede \gnode_n} \in \ggraph, \text{where } \nexists \; \gnode_i \text{ of form } \gsLR{\genter \olbl', \gtime} \text{ or } \gsLR{\gleave \olbl', \gtime'}
          \end{flalign*}
      \end{definition}


\tnote{Get rid of mathpar blocks when we settle down.}
\end{document}
