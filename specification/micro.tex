\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

\begin{document}

  \section{Operational Semantics}

    \subsection{Grammar}

        \begin{grammar}

          \grule[variables]{\ovariable}{\osType{alphanumeric} \gor \star \osType{alphanumeric}}
          \grule[general labels]{\oglbl}{\olbl \gor \osplat}
          \grule[labels]{\olbl}{}
          \grule[stack]{\ostack}{
                      [\ostackframe,\ldots]
          }
          \grule[stack frames]{\ostackframe}{
                      \osLR{\opscope,\oglbl}
          }
          \grule[programs]{\oprogram}{
                      [\ostmt,\ldots]
          }
          \grule[clauses]{\ostmt}{\olbl:\oglbl:\odirective}
          % statements
          \grule[directives]{\odirective}{
                      \ovariable \gteq \oexpr % x = e
              \gor    \okw{return} \ovariable % return x
              \gor    \okw{goto} \olbl % goto x
              \gor    \okw{goto} \olbl \okw{if not} \ovariable % goto x if not v
              \gline
              \gor    \okw{raise} \ovariable % raise x
              \gor    \okw{catch} \ovariable % catch x
              \gor    \okw{pass} % pass
          }
          \grule[bindings]{\obinding}{\{\ovariable \mapsto \omem, \ldots\}}
          \grule[heap]{\oheap}{\{\omem \mapsto \ovalue, \ldots\}}

          % value types
          \grule[values]{\ovalue}{
                      \mathbb{Z}
              \gor    \mathbb{S}
              \gor    [\omem, \ldots] % [m, ...]
              \gor    (\omem, \ldots) % (m, ...)
              \gor    \obinding % B
              \gor    \ogenf
              \gor    \ogenm
              % \gor    \osnone
              \gor    \osplat
          }

          % expressions
          \grule[expressions]{\oexpr}{
                      \mathbb{Z} % int
              \gor    \mathbb{S} % string
              %\gor    \osnone % None
              \gor    \ovariable % x
              \gor    \okw{def} (\ovariable,\ldots)\{ \oprogram \} % def x(x, ...) = {S}
              \gor    \ovariable(\ovariable, \ldots) % x(x, ...)
              \gor    \ovariable.\ovariable % x.x
              \gor    [\ovariable, \ldots] % [x, ...]
              \gor    (\ovariable, \ldots) % (x, ...)
              \gor    \ovariable \okw{is} \ovariable
          }
          \grule[microcode stack]{\omstack}{[\omcode,\ldots]}
          \grule[microcode literal stack]{\olstack}{[\olcode,\ldots]}
          \grule[microcode instructions]{\omcode}{
                      \osMC{Store}
              \gor    \osMC{Wrap}
              \gor    \osMC{Bind}
              \gor    \osMC{LookUp}
              \gor    \osMC{List} \;n
              \gor    \osMC{Tuple} \;n
              \gline
              \gor    \osMC{Advance}
              \gor    \osMC{Pop}
              \gor    \osMC{Push} \;\olbl
              \gor    \osMC{Raise}
              \gor    \osMC{Goto} \;\olbl
              \gor    \osMC{Gotoifn} \;\olbl
              \gline
              \gor    \osMC{Call} \;n
              \gor    \osMC{Convert} \;n
              \gor    \osMC{Retrieve}
              \gor    \osMC{Get}
              \gor    \osMC{Assign}
              \gor    \osMC{Eq}
              \gor    \osMC{Dup}
              \gline
              \gor    \osMC{AllocNameError}
              \gor    \osMC{AllocTypeError}
              \gor    \osMC{AllocAttrError}
          }
          \grule[microcode literals]{\olcode}{
                      \ovariable
              \gor    \omem
              \gor    \ovalue
          }
          \grule[general memory locations]{\ogmem}{
                      \omem
              \gor    \opscope
              \gor    \osplat
          }
          \grule[memory locations]{\opscope, \omem}{
                      \osType{<address>}
          }
          \grule[general functions]{\ogenf}{
                      \osLR{ \opscope,\okw{def}(\ovariable, \ldots) \ofuncarr \olbl } % < scope, def (x) -> S >
              \gor    \omagicf
              \gor    \omagicm
          }
          \grule[general methods]{\ogenm}{
                      \osLR{ \omem, \ogenf } % < m, F >
          }
          \grule[magic functions]{\omagicf, \omagicm}{
                      \osMagic{CallFunc}
              \gor    \osMagic{Type}
              \gor    \osMagic{IntAdd}
              \gor    \osMagic{IntNeg}
              \gor    \osMagic{StrAdd}
              \gor    \osMagic{StrContains}
              \gline
              \gor    \osMagic{LstIter}
              \gor    \osMagic{LstContains}
              \gor    \osMagic{LstGetitem}
              \gor    \osMagic{TplIter}
              \gor    \osMagic{TplContains}
              \gline
              \gor    \osMagic{TplGetitem}
          }
          \grule[integers]{n}{}

        \end{grammar}

      \begin{definition} Initialization
        \begin{flalign*}
        \osI{\osInit{\oheap}}{
            \{
                  \osInit{\opscope} \mapsto \osInit{\obinding},
                  \omem_{\osnone} \mapsto \{\;\},
                  \omem_{\texttt{AttrError}} \mapsto \{\;\},
                  \omem_{\texttt{FunType}} \mapsto \{\;\},
                  \omem_{\texttt{MetType}} \mapsto \{\;\}, \\
                  &
                  \omem_{\texttt{IntType}} \mapsto \{\;\},
                  \omem_{\texttt{StrType}} \mapsto \{\;\},
                  \omem_{\texttt{LstType}} \mapsto \{\;\},
                  \omem_{\texttt{TplType}} \mapsto \{\;\},
                  \osMem{GetAttribute} \mapsto \obinding, \\
                  &
                  \osMem{SetAttr} \mapsto \obinding,
            \}
        } \\
        \osI{\osInit{\obinding}}{
            \{
                  \star\osnone \mapsto \omem_{\osnone},
                  \osType{AttributeError} \mapsto \osMem{AttrError},
                  \osType{FunctionType} \mapsto \osMem{FunType}, \\
                  &
                  \osType{MethodType} \mapsto \osMem{MetType},
                  \osType{IntType} \mapsto \osMem{IntType},
                  \osType{StringType} \mapsto \osMem{StrType}, \\
                  &
                  \osType{ListType} \mapsto \osMem{LstType},
                  \osType{TupleType} \mapsto \osMem{TplType},
            \}
        } \\
        \osI{\osInit{\ostackframe}}{\osLR{\osInit{\opscope}, \osInit{\olbl}, \osInit{\oprogram}}} \\
        \osI{\osInit{\ostack}}{[\osInit{\ostackframe}]} \\
        \end{flalign*}
      \text{\tnote{We need to specify what GetAttribute and booleans are.}} \\
      \end{definition}

  \subsection{Micro-Instruction Rules}
          \begin{mathpar}
            \relationRule{Alloc}{
                \omem \notin \oheap
            }{
                \osInStack{\osMC{Alloc}}, \ostack, \oheap \osTransition
                \osInStack{\omem}, \ostack, \oheap
            }
          \end{mathpar}

          \begin{mathpar}
          \relationRule{Store \ovalue}{
              \oheap' = \oheap[\omem \mapsto \ovalue]
          }{
              \osInStack{\omem, \ovalue, \osMC{Store}}, \ostack, \oheap \osTransition
              \osInStack{\omem}, \ostack, \oheap'
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Wrap \ovalue \, in \omem}{
              \omem'', \ovalue' = \osWrap(\omem_{\texttt{obj}}, \omem, \ovalue)
          }{
              \osInStack{\omem_{\texttt{obj}}, \omem, \ovalue, \osMC{Wrap}}, \ostack, \oheap \osTransition
              \osInStack{\omem'', \ovalue'}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Bind \omem \! to \ovariable}{
              \obinding = \oheap[\opscope] \\
              \obinding' = \obinding[\ovariable \mapsto \omem] \\
              \oheap' = \oheap[\opscope \mapsto \obinding']
          }{
              \osInStack{\omem, \ovariable, \osMC{Bind}}, \ostack, \oheap \osTransition
              \osInStack{}, \ostack, \oheap'
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Look up \ovariable \,(bound)}{
              \osLookup(\oheap, \opscope, \ovariable) = \omem
          }{
              \osInStack{\ovariable, \osMC{LookUp}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \osInStack{\omem}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Look up \ovariable \,(NameError)}{
              \osLookup(\oheap, \opscope, \ovariable) = \osplat
          }{
              \osInStack{\ovariable, \osMC{LookUp}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              [\osMC{AllocNameError}, \osMC{Raise}], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Push \olbl}{
              \oheap' = \oheap[\opscope' \mapsto \{\ostarvalue{parent} \mapsto \opscope\}],  \opscope' \notin \oheap
          }{
              \osInStack{\opscope, \osMC{Push} \;\olbl}, \ostack, \oheap \osTransition
              \osInStack{}, [\osLR{\opscope', \olbl}] \listConcat \ostack, \oheap'
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Pop}{
          }{
              \osInStack{\osMC{Pop}}, \ostackframe \listConcat \ostack, \oheap \osTransition
              \osInStack{}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Advance}{
              \olbl \osBefore{\oprogram} \olbl'
          }{
              \osInStack{\osMC{Advance}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \osInStack{}, [\osLR{\opscope, \olbl'}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Advance (end of function)}{
              \olbl \osBefore{\oprogram} \osplat \\
              \ostackframe = \osLR{ \opscope', \olbl' } \\
              \oprogram(\olbl') = \olbl':\oglbl'': \ovariable \gteq \oexpr \\
              \omstack' = [\osMC{Pop}, \omem_{\osnone}, \ovariable, \osMC{Bind},  \osMC{Advance}]
          }{
              \osInStack{\osMC{Advance}}, [\osLR{\opscope, \olbl}, \ostackframe] \listConcat \ostack, \oheap \osTransition
              \olstack \listConcat \omstack' \listConcat \omstack, [\osLR{\opscope, \olbl}, \ostackframe] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Advance (EOF)}{
              \ostack = [\osLR{\opscope, \olbl}] \\
              \olbl \osBefore{\oprogram} \osplat \\
              \omstack' = [\osMC{Pop}]
          }{
              \osInStack{\osMC{Advance}}, \ostack, \oheap \osTransition
              \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Make List}{
              \ovalue = [\omem_1, \ldots, \omem_n]
          }{
              \osInStack{\omem_1, \ldots, \omem_n, \osMC{List}\;n}, \ostack, \oheap \osTransition
              \osInStack{\ovalue}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Make Tuple}{
              \ovalue = (\omem_1, \ldots, \omem_n)
          }{
              \osInStack{\omem_1, \ldots, \omem_n, \osMC{Tuple}\;n}, \ostack, \oheap \osTransition
              \osInStack{\ovalue}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Raise \,(no exception label)}{
              \oprogram(\olbl) = \olbl:\osplat: \odirective \\
          }{
              \osInStack{\osMC{Raise}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \osInStack{\osMC{Pop}, \osMC{Raise}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Raise \,(caught)}{
              \oprogram(\olbl) = \olbl:\olbl_0: \odirective \\
              \oprogram(\olbl_0) = \olbl_0:\olbl_1: \okw{catch} \ovariable \\
              \omstack' = [\ovariable, \osMC{Bind}, \osMC{Advance}]
          }{
              \osInStack{\osMC{Raise}}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \olstack \listConcat \omstack' \listConcat \omstack, [\osLR{\opscope, \olbl_0}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Goto \olbl}{
              \oprogram(\olbl) = \olbl:\oglbl': \odirective
          }{
              \osInStack{\osMC{Goto}\;\olbl}, [\osLR{\opscope, \olbl'}] \listConcat \ostack, \oheap \osTransition
              \osInStack{}, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Gotoifn \olbl \,(success)}{
              \ovalue = \osfalse \\
              \oprogram(\olbl) = \olbl:\oglbl': \odirective
          }{
              \osInStack{\ovalue, \osMC{Gotoifn}\;\olbl}, \ostack, \oheap \osTransition
              \osInStack{\osMC{Goto}\;\olbl}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Gotoifn \olbl \,(failure)}{
              \ovalue = \ostrue
          }{
              \osInStack{\ovalue, \osMC{Gotoifn}\;\olbl}, \ostack, \oheap \osTransition
              \osInStack{\osMC{Advance}}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Convert Function \ovalue}{
              \ovalue = \ogenf \\
          }{
              \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \ostack, \oheap \osTransition
              \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Convert Method \ovalue}{
              \ovalue = \osLR{ \omem_0, \ogenf } \\
              \ovalue' = \ogenf \\
          }{
              \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \ostack, \oheap \osTransition
              \osInStack{\ovalue', \omem_0, \omem_1, \ldots, \omem_n, \osMC{Call} \;n+1}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Call function \omem}{
            \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl } \\
            \omstack' = [\opscope, \osMC{Push} \;\olbl, \omem_1, \ovariable_1, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
          }{
            \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap \osTransition
            \osInStack{\omstack'}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Call function (wrong args)}{
            \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \olbl }, q \neq n
          }{
            \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap \osTransition
            [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
          }
        \end{mathpar}


        \begin{mathpar}
          \relationRule{Retrieve \ovariable \, from \ovalue}{
              \omem = \ovalue[\ovariable] \\
              \omstack' = [\osMC{Alloc}, \omem, \osMC{Dup}, \osMC{Get}, \osMC{Wrap}, \osMC{Store}]
          }{
              \osInStack{\ovalue, \ovariable, \osMC{Retrieve}}, \ostack, \oheap \osTransition
              \osInStack{\omstack'}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Retrieve \ovariable \,(AttributeError)}{
              \osplat = \ovalue[\ovariable]
          }{
              \osInStack{\ovalue, \ovariable, \osMC{Retrieve}}, \ostack, \oheap \osTransition
              [\osMC{AllocAttrError}, \osMC{Raise}], \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Get \omem}{
              \ovalue = \oheap[\omem]
          }{
              \osInStack{\omem, \osMC{Get}}, \ostack, \oheap \osTransition
              \osInStack{\ovalue}, \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Assign \ovalue \! to \ovariable}{
              \omstack' = [\osMC{Alloc}, \osMC{Alloc}, \ovalue, \osMC{Store}, \ovalue, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}]
          }{
              \osInStack{\ovalue, \ovariable, \osMC{Assign}}, \ostack, \oheap \osTransition
              \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
          }

      \end{mathpar}

      \begin{mathpar}
        \relationRule{Eq \omem \! and \omem}{
            \ovalue =
            \begin{cases}
              \ostrue, & \text{if}\; \omem = \omem' \cr
              \osfalse, & \text{otherwise}
            \end{cases}
        }{
            \osInStack{\omem, \omem', \osMC{Eq}}, \ostack, \oheap \osTransition
            \osInStack{\ovalue}, \ostack, \oheap
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Dup \olcode}{
        }{
            \osInStack{\olcode, \osMC{Dup}}, \ostack, \oheap \osTransition
            \osInStack{\olcode, \olcode}, \ostack, \oheap
        }
      \end{mathpar}

      \subsection{Rules}

      \begin{mathpar}

          \relationRule{Literal Assignment}{
              \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr,\,\oexpr \text{ is of form } \mathbb{Z}, \mathbb{S}\\
              \ovalue = \oexpr \\
              \omstack = [\ovalue, \ovariable, \osMC{Assign}, \osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }

          \tnote{TODO: make literal category (ints, str, bool)}
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Name Assignment}{
              \oprogram(\olbl) = \olbl:\oglbl': \ovariable_1 \gteq \ovariable_2 \\
              \omstack = [\ovariable_2, \osMC{Lookup}, \ovariable_1, \osMC{Bind}, \osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{List Assignment}{
              \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq [\ovariable_1, \ldots, \ovariable_n] \\
              \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{List} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Tuple Assignment}{
              \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq (\ovariable_1, \ldots, \ovariable_n) \\
              \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Tuple} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{FunctionDef Assignment}{
              \oprogram(\olbl) = \olbl:\olbl': \ovariable \gteq \okw{def} (\ovariable_1, \ldots, \ovariable_n)\{\oprogram'\} \\
              \oprogram' = [\olbl'':\olbl''':\odirective, \ldots] \\
              \ovalue = \osLR{ \opscope, \okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl'' } \\
              \omstack = [\ovalue, \ovariable, \osMC{Assign}, \osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Attribute Assignment}{
              \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_1.\ovariable_2 \\
              \omstack = [\osMC{Alloc}, \ovariable_1, \osMC{LookUp}, \osMC{Get}, \ovariable_2, \osMC{Retrieve}, \osMC{Dup}, \osMC{Get}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Call Assignment}{
              \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
              \omstack = [\ovariable_0, \osMC{LookUp}, \osMC{Get}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, \ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Convert} \;n]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Is Assignment}{
              \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_1 \okw{is} \ovariable_2\\
              \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{LookUp}, \osMC{Eq}, \ovariable, \osMC{Assign}, \osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Raise}{
              \oprogram(\olbl) = \olbl:\oglbl': \okw{raise} \ovariable \\
              \omstack = [\ovariable, \osMC{LookUp}, \osMC{Raise}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Pass}{
              \oprogram(\olbl) = \olbl:\oglbl': \okw{pass} \\
              \omstack = [\osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Return}{
              \oprogram(\olbl) = \olbl:\oglbl': \okw{return} \ovariable \\
              \ostack = [\osLR{ \opscope', \olbl''}] \listConcat \ostack' \\
              \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable' \gteq \oexpr \\
              \omstack = [\ovariable, \osMC{LookUp}, \osMC{Pop}, \ovariable', \osMC{Bind},\osMC{Advance}]
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{Goto}{
              \oprogram(\olbl) = \olbl:\oglbl': \okw{goto} \olbl'' \\
              \omstack = [\osMC{Goto} \;\olbl'']
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }
        \end{mathpar}

        \begin{mathpar}
          \relationRule{GotoIfNot}{
              \oprogram(\olbl) = \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
              \omstack = [\ovariable, \osMC{Lookup}, \osMC{Get}, \osMC{Gotoifn} \;\olbl'']
          }{
              [\;], [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap \osTransition
              \omstack, [\osLR{\opscope, \olbl}] \listConcat \ostack, \oheap
          }

      \end{mathpar}

  \subsection{Magic}
      \input{magic}

  \subsection{Helper Functions}

      % Lookup
      \begin{definition}
        Let $ \obinding = \oheap[\opscope] $ in
        \begin{equation}
          \osLookup(\oheap,\opscope,\ovariable) =
            \begin{cases}
              \omem, & \text{if}\; \omem = \obinding[\ovariable] \\
              \osLookup(\oheap,\opscope',\ovariable), & \text{if}\; \osplat = \obinding[\ovariable], \opscope' = \obinding[\ostarvalue{parent}] \\
              \osplat, & \text{if}\; \osplat = \obinding[\ovariable], \osplat = \obinding[\ostarvalue{parent}]
            \end{cases}
          \end{equation}
      \end{definition}

      % GetObj
      \begin{definition}
        Let $ \obinding_{\texttt{obj}} = \{
            \ostarvalue{value} \mapsto \omem', \text{\osClown{getattribute}} \mapsto \osMem{Getattribute} \} % the base object
        $ in
          \begin{equation}
            \osWrap (\omem, \omem', \ovalue) =
            \begin{cases}
              \omem', \obinding, & \text{if}\; \ovalue = \obinding \\
              % \obinding = \obinding_{\texttt{obj}}[\text{\osClown{class}} \mapsto \osMem{FunType}], & \text{if}\; \ovalue = \ogenf \\
              \omem, \osFunc{FillMet}(\obinding_{\texttt{obj}}, \omem), & \text{if}\; \ovalue = \ogenm \\
              \omem, \osFunc{FillInt}(\obinding_{\texttt{obj}}, \omem), & \text{if}\; \ovalue = \mathbb{Z} \\
              \omem, \osFunc{FillStr}(\obinding_{\texttt{obj}}, \omem), & \text{if}\; \ovalue = \mathbb{S} \\
              \omem, \osFunc{FillLst}(\obinding_{\texttt{obj}}, \omem), & \text{if}\; \ovalue = [\omem_1, \omem_2, \ldots] \\
              \omem, \osFunc{FillTpl}(\obinding_{\texttt{obj}}, \omem), & \text{if}\; \ovalue = (\omem_1, \omem_2, \ldots) \\
            \end{cases}
          \end{equation}
          \begin{multicols}{2}
            \begin{flalign*}
                \osFunc{FillMet}
                & (\obinding_{\texttt{obj}}, \omem) = \obinding_{\texttt{obj}} \\
                & [\osClown{class} \mapsto \osMem{MetType}] \\
            \end{flalign*}
            \begin{flalign*}
                \osFunc{FillInt}
                & (\obinding_{\texttt{obj}}, \omem) = \obinding_{\texttt{obj}} \\
                & [\osClown{class} \mapsto \osMem{IntType}, \\
                & \osClown{add} \mapsto \osWrap(\omem, \osMagic{IntAdd}), \\
                & \osClown{neg} \mapsto \osMagic{IntNeg}] \\
            \end{flalign*}
            \begin{flalign*}
                \osFunc{FillStr}
                & (\obinding_{\texttt{obj}}, \omem) = \obinding_{\texttt{obj}} \\
                & [\osClown{class} \mapsto \osMem{StrType}, \\
                & \osClown{add} \mapsto \osMagic{StrAdd}, \\
                & \osClown{neg} \mapsto \osMagic{StrContains}] \\
            \end{flalign*}
            \begin{flalign*}
                \osFunc{FillLst}
                & (\obinding_{\texttt{obj}}, \omem) = \obinding_{\texttt{obj}} \\
                & [\osClown{class} \mapsto \osMem{LstType}, \\
                & \osClown{iter} \mapsto \osMagic{LstIter}, \\
                & \osClown{contains} \mapsto \osMagic{LstContains}, \\
                & \osClown{getitem} \mapsto \osMagic{LstGetitem}] \\
            \end{flalign*}
            \begin{flalign*}
                \osFunc{FillTpl}
                & (\obinding_{\texttt{obj}}, \omem) = \obinding_{\texttt{obj}} \\
                & [\osClown{class} \mapsto \osMem{TupType}, \\
                & \osClown{iter} \mapsto \osMagic{TupIter}, \\
                & \osClown{contains} \mapsto \osMagic{TupContains}, \\
                & \osClown{getitem} \mapsto \osMagic{TupGetitem}] \\
            \end{flalign*}
          \end{multicols}
      \end{definition}
      \tnote{setattr}

    \section{Graph Semantics}

      \subsection{Grammar}

      \begin{grammar}
        \grule[graph]{\ggraph}{ \{\gedge, \ldots\} }
        \grule[edges]{\gedge}{
                    \gnode \gsBefore \gnode
            \gor    \gnode \gsSkip \gnode
        }
        \grule[nodes]{\gnode}{
                    \gsstart
            \gor    \gsend
            \gor    \gsLR{\olbl, \omstack, \gtime}
            \gor    \gsLR{\genter \olbl, \gtime}
            \gor    \gsLR{\gleave \olbl, \gtime}
        }
        \grule[time stamps]{\gtime}{\mathbb{N}}

      \end{grammar}

      \begin{theorem}[Bisimulation]
        If $\osLR{\omstack, \ostack, \oheap} \approx \ggraph$ and $\osLR{\omstack, \ostack, \oheap} \osTransition \osLR{\omstack', \ostack', \oheap'}$, then $\ggraph \gsTransition \ggraph'$ such that $\osLR{\omstack', \ostack', \oheap'} \approx \ggraph'$.
      \end{theorem}

      \subsection{Micro-Instruction Rules}

      \begin{mathpar}
        \relationRule{Store}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \osMC{Store}}, \gtime} \\
            \omem = \gsFunc{Alloc}(\gnode_2)
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omem}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Wrap}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem, \ovalue, \osMC{Wrap}}, \gtime} \\
            \ovalue = \gsFunc{GetObj}(\omem, \ovalue)
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omem}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Bind}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem, \ovariable, \osMC{Bind}}, \gtime} \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Lookup}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovariable, \osMC{LookUp}}, \gtime} \\
            \gsFunc{Lookup}(\ggraph, \gnode_2, \ovariable) \ni \omem
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omem}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Lookup (NameError)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovariable, \osMC{LookUp}}, \gtime} \\
            \gsFunc{Lookup}(\ggraph, \gnode_2, \ovariable) \niton \omem
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\osMC{AllocNameError}, \osMC{Raise}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Push}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\opscope, \osMC{Push}\;\olbl'}, \gtime} \\
            \gnode_3 = \gsLR{\genter \olbl, \gtime + 1}
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gnode_3, \gnode_3 \gsBefore \gsLR{\olbl', \osInStack{}, \gtime + 2}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Pop}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Pop}}, \gtime} \\
            \gnode_3 = \gsLR{\gleave \olbl', \gtime + 1} \\
            \gsLR{\genter \olbl', \gtime'} = \gnode_0' = \gsFunc{Startof}(\gnode_2) \\
            \gnode_1' = \gsBefore \gnode_0' \\
            \gnode_4 = \gsLR{\olbl', \osInStack{}, \gtime + 2}
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gnode_3, \gnode_3 \gsBefore \gnode_4, \gnode_1' \gsSkip \gnode_4}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Advance}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Advance}}, \gtime} \\
            \olbl \osBefore{\oprogram} \olbl'
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Advance (end of function)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Advance}}, \gtime} \\
            \olbl \osBefore{\oprogram} \osplat \\
            % \gnode_3 = \gsLR{\gleave \olbl', \gtime + 1} \\
            \gsLR{\genter \olbl', \gtime'} = \gnode_0' = \gsFunc{Startof}(\gnode_2) \\
            \gsLR{\olbl'', \omstack, \gtime' - 1} = \gnode_1' = \gsBefore \gnode_0' \\
            \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable \gteq \oexpr \\
            \omstack' = [\osMC{Pop}, \omem_{\osnone}, \ovariable, \osMC{Bind},  \osMC{Advance}]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{\omstack'}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Advance (EOF)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Advance}}, \gtime} \\
            \olbl \osBefore{\oprogram} \osplat \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsend}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Make List}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem_1, \ldots, \omem_n, \osMC{List}\;n}, \gtime} \\
            \ovalue = [\omem_1, \ldots, \omem_n]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Make Tuple}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem_1, \ldots, \omem_n, \osMC{Tuple}\;n}, \gtime} \\
            \ovalue = (\omem_1, \ldots, \omem_n)
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Raise (no exception label)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Raise}}, \gtime} \\
            \oprogram(\olbl) = \olbl:\osplat: \odirective \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\osMC{Pop}, \osMC{Raise}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Raise (caught)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Raise}}, \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl': \odirective \\
            \oprogram(\olbl') = \olbl':\oglbl'': \okw{catch} \ovariable
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{\ovariable, \osMC{Bind}, \osMC{Advance}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Goto}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\osMC{Goto}\;\olbl'}, \gtime} \\
            \oprogram(\olbl') = \olbl':\oglbl'': \odirective
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Gotoifn \olbl \,(success)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \osMC{Gotoifn}\;\olbl'}, \gtime} \\
            \ovalue = \osfalse \\
            \oprogram(\olbl') = \olbl:\oglbl': \odirective
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{\osMC{Goto}\;\olbl}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Gotoifn \olbl \,(failure)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \osMC{Gotoifn}\;\olbl'}, \gtime} \\
            \ovalue = \ostrue
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl', \osInStack{\osMC{Advance}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Convert Function}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \gtime} \\
            \ovalue = \ogenf \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Convert Method}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n}, \gtime} \\
            \ovalue = \osLR{ \omem_0, \ogenf } \\
            \ovalue' = \ogenf \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue', \omem_0, \omem_1, \ldots, \omem_n, \osMC{Call} \;n+1}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Call function}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \gtime} \\
            \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl } \\
            \omstack' = [\opscope, \osMC{Push} \;\olbl, \omem_1, \ovariable_1, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omstack'}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Call function (wrong args)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \gtime} \\
            \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \olbl }, q \neq n
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\osMC{AllocTypeError}, \osMC{Raise}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Retrieve \ovariable}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \ovariable, \osMC{Retrieve}}, \gtime} \\
            \omem = \ovalue[\ovariable]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omem}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Retrieve \ovariable \,(AttributeError)}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \ovariable, \osMC{Retrieve}}, \gtime} \\
            \osplat = \ovalue[\ovariable]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\osMC{AllocAttrError}, \osMC{Raise}}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Get \omem}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem, \osMC{Get}}, \gtime} \\
            \gsFunc{Get}(\ggraph, \gnode_2, \omem) \ni \ovalue
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Assign}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\ovalue, \ovariable, \osMC{Assign}}, \gtime} \\
            \omstack' = [\ovalue, \osMC{Store}, \ovalue, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}]
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\omstack'}, \gtime + 1}}
        }

      \end{mathpar}

      \begin{mathpar}
        \relationRule{Eq \omem \! and \omem}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\omem, \omem', \osMC{Eq}}, \gtime} \\
            \ovalue =
            \begin{cases}
              \ostrue, & \text{if}\; \omem = \omem' \cr
              \osfalse, & \text{otherwise}
            \end{cases}
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\ovalue}, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Dup \olcode}{
            \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
            \gnode_2 = \gsLR{\olbl, \osInStack{\olcode, \osMC{Dup}}, \gtime} \\
        }{
            \gsAddEdge{\gnode_2 \gsBefore \gsLR{\olbl, \osInStack{\olcode,\olcode}, \gtime + 1}}
        }
      \end{mathpar}

      \subsection{Rules}

      \begin{mathpar}
        \relationRule{Start}{
            \oprogram = [\ostmt, \ldots] \\
            \ostmt = \olbl:\oglbl':\odirective
        }{
            \gsAddEdge{\gsstart \gsBefore \gsLR{\olbl, [\;], 0}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Literal Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable_1 \gteq \oexpr, \oexpr \text{ is of form } \mathbb{Z}, \mathbb{S}\\
            \ovalue = \oexpr \\
            \omstack = [\ovalue, \ovariable_1, \osMC{Assign}, \osMC{Advance}]
        } {
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Name Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable_1 \gteq \ovariable_2 \\
            \omstack = [\ovariable_2, \osMC{LookUp}, \ovariable_1, \osMC{Bind}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{List Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq [\ovariable_1, \ldots, \ovariable_n] \\
            \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{List} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Tuple Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl':\ovariable \gteq (\ovariable_1, \ldots, \ovariable_n) \\
            \omstack = [\ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Tuple} \; n, \ovariable, \osMC{Assign}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{FunctionDef Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl': \ovariable \gteq \okw{def} (\ovariable_1, \ldots, \ovariable_n)\{\oprogram'\} \\
            \oprogram' = [\olbl'':\olbl''':\odirective, \ldots] \\
            \ovalue = \osLR{ \opscope, \okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \olbl'' } \\
            \omstack = [\ovalue, \ovariable, \osMC{Assign}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Attribute Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_1.\ovariable_2 \\
            \omstack = [\ovariable_1, \osMC{LookUp}, \osMC{Get}, \ovariable_2, \osMC{Retrieve}, \osMC{Dup}, \osMC{Get}, \osMC{Wrap}, \ovariable, \osMC{Bind}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Call Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
            \omstack = [\ovariable_0, \osMC{LookUp}, \osMC{Get}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, \ovariable_1, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Convert} \;n]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Is Assignment}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl':\ovariable \gteq \ovariable_1 \okw{is} \ovariable_2\\
            \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{LookUp}, \osMC{Eq}, \ovariable, \osMC{Assign}, \osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Raise}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{raise} \ovariable \\
            \omstack = [\ovariable, \osMC{LookUp}, \osMC{Raise}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Pass}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{pass} \\
            \omstack = [\osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Return}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{return} \ovariable \\
            \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable' \gteq \oexpr \\
            \omstack = [\ovariable, \osMC{LookUp}, \osMC{Pop}, \ovariable', \osMC{Bind},\osMC{Advance}]
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{Goto}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\oglbl': \okw{goto} \olbl'' \\
            \omstack = [\osMC{Goto} \;\olbl'']
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \begin{mathpar}
        \relationRule{GotoIfNot}{
            \gnode \gsBefore \gsLR{\olbl, [\;], \gtime} \\
            \oprogram(\olbl) = \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
            \omstack = [\ovariable, \osMC{Lookup}, \osMC{Get}, \osMC{Gotoifn} \;\olbl'']
        }{
            \gsAddEdge{\gnode \gsBefore \gsLR{\olbl, \omstack, \gtime + 1}}
        }
      \end{mathpar}

      \subsection{Helper Functions}

      \begin{definition}[Alloc Memory]
          Let $\gsFunc{Alloc}(\gsLR{\olbl,\omstack,\chi})$ be an injective map $M: \gsSet{\olbl, \ldots} \mapsto \gsSet{\omem, \ldots}$.
      \end{definition}

      \begin{definition}[Lookup Variable]
          Let $ \gsFunc{Lookup}(\ggraph, \gnode_0, \ovariable) = \gsSet{\ogmem, \ldots} = \gresult $ be the function returning the least set satisfying the following rules:

          \begin{itemize}
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph,
                      \gnode_1 = \gstart$,
                  then $ \gresult \supseteq \gsSet{\osplat}$.
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph,
                      \gnode_1 = \gsLR{\olbl, \osInStack{\omem, \ovariable, \osMC{Bind}}, \gtime}$,
                  then $\gresult \supseteq \gsSet{\omem}$.
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph,
                      \gnode_1 = \gsLR{\olbl, \osInStack{}, \gtime},
                      \omstack = [\omcode_0, \ldots],
                      \omcode_0 \in \gsSet{\osMC{Store}, \osMC{Wrap}, \osMC{LookUp}, \osMC{Advance}}$,
                  then $\gresult \supseteq \gsFunc{Lookup}(\ggraph, \gnode_0, \ovariable)$.
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph,
                      \gnode_1 = \gsLR{\olbl, \osInStack{\omem, \ovariable', \osMC{Bind}}, \gtime},
                      \ovariable \neq \ovariable'$,
                  then $\gresult \supseteq \gsFunc{Lookup}(\ggraph, \gnode_0, \ovariable)$.
          \end{itemize}
      \end{definition}

      \begin{definition}[Get Value]
          Let $ \gsFunc{Get}(\ggraph, \gnode_0, \omem) = \gsSet{\ovalue, \ldots} = \gvset $ be the function returning the least set satisfying the following rules:

          \begin{itemize}
            \item If $\gnode_1 \gsBefore \gnode_0 \in \ggraph,
                      \gnode_1 = \gsLR{\olbl, \osInStack{\ovalue, \osMC{Store}}, \gtime},
                      \omem = \gsFunc{Alloc}(\gnode_1)$,
                  then $\gvset \supseteq \gsSet{\ovalue}$.
          \end{itemize}
      \end{definition}

      \begin{definition}[Start of Function]
          \begin{flalign*}
            \gnode_1 \gsPrecede \gnode_2 & \iff \gnode_1 \gsBefore \gnode_2 \text{ or } \gnode_1 \gsSkip \gnode_2 \\
            \gsFunc{Startof}(\gnode_n) = \gnode_0 & \iff \gsSet{\gnode_0 \gsPrecede \gnode_1 \gsPrecede \ldots \gsPrecede \gnode_n} \in \ggraph, \text{where } \nexists \; \gnode_i \text{ of form } \gsLR{\genter \olbl', \gtime} \text{ or } \gsLR{\gleave \olbl', \gtime'}
          \end{flalign*}
      \end{definition}
\end{document}
