\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

% TODO: Fix program state representation.

\begin{document}


        \begin{figure}\center
              \begin{grammar}
                \grule[variables]{\ovariable}{\osType{alphanumeric} \gor \star \osType{alphanumeric}}
                \grule[general labels]{\oglbl}{\olbl \gor \osplat}
                \grule[labels]{\olbl}{}
                \grule[stack]{\ostack}{
                            [\ostackframe,\ldots]
                }
                \grule[stack frames]{\ostackframe}{
                            \osLR{\opscope,\oglbl,\oprogram}
                }
                \grule[programs]{\oprogram}{
                            [\ostmt,\ldots]
                }
                \grule[clauses]{\ostmt}{\olbl:\oglbl:\odirective}
                % statements
                \grule[directives]{\odirective}{
                            \ovariable \gteq \oexpr % x = e
                    \gor    \okw{return} \ovariable % return x
                    \gor    \okw{goto} \olbl % goto x
                    \gor    \okw{goto} \olbl \okw{if not} \ovariable % goto x if not v
                    \gline
                    \gor    \okw{raise} \ovariable % raise x
                    \gor    \okw{catch} \ovariable % catch x
                    \gor    \okw{pass} % pass
                }
                \grule[bindings]{\obinding}{\{\ovariable \mapsto \omem, \ldots\}}
                \grule[heap]{\oheap}{\{\omem \mapsto \ovalue, \ldots\}}

                % value types
                \grule[values]{\ovalue}{
                            \mathbb{Z}
                    \gor    \mathbb{S}
                    \gor    [\omem, \ldots] % [m, ...]
                    \gor    (\omem, \ldots) % (m, ...)
                    \gor    \obinding % B
                    \gor    \ogenf
                    \gor    \ogenm
                    % \gor    \osnone
                    \gor    \osplat
                }

                % expressions
                \grule[expressions]{\oexpr}{
                            \mathbb{Z} % int
                    \gor    \mathbb{S} % string
                    %\gor    \osnone % None
                    \gor    \ovariable % x
                    \gor    \okw{def} (\ovariable,\ldots) \gteq \{ \oprogram \} % def x(x, ...) = {S}
                    \gor    \ovariable(\ovariable, \ldots) % x(x, ...)
                    \gor    \ovariable.\ovariable % x.x
                    \gor    [\ovariable, \ldots] % [x, ...]
                    \gor    (\ovariable, \ldots) % (x, ...)
                }
                \grule[microcode stack]{\omstack}{[\omcode,\ldots]}
                \grule[microcode literal stack]{\olstack}{[\olcode,\ldots]}
                \grule[microcode instructions]{\omcode}{
                            \osMC{Store}
                    \gor    \osMC{Wrap}
                    \gor    \osMC{Bind}
                    \gor    \osMC{LookUp}
                    \gor    \osMC{List} \;n
                    \gor    \osMC{Tuple} \;n
                    \gline
                    \gor    \osMC{Advance}
                    \gor    \osMC{Pop}
                    \gor    \osMC{Push} \;\oprogram
                    \gor    \osMC{Raise}
                    \gor    \osMC{Goto} \;\olbl
                    \gor    \osMC{Gotoifn} \;\olbl
                    % \gor    \osMC{Ignore}
                    \gline
                    \gor    \osMC{Call} \;n
                    % \gor    \osMC{GetCall} \;n
                    \gor    \osMC{Convert} \;n
                    \gor    \osMC{Retrieve}
                    \gor    \osMC{Get}
                    \gline
                    \gor    \osMC{AllocNameError}
                    \gor    \osMC{AllocTypeError}
                    \gor    \osMC{AllocAttrError}
                }
                \grule[microcode literals]{\olcode}{
                            \ovariable
                    \gor    \omem
                    \gor    \ovalue
                }
                % \grule[parental map]{\oparent}{\omem \mapsto \omem}
                \grule[general memory locations]{\ogmem}{
                            \omem
                    \gor    \opscope
                    \gor    \osplat
                }
                \grule[memory locations]{\opscope, \omem}{
                            \osType{<address>}
                    % \gor    \osnone
                }
                \grule[general functions]{\ogenf}{
                            \osLR{ \opscope,\okw{def}(\ovariable, \ldots) \ofuncarr \oprogram } % < scope, def (x) -> S >
                    \gor    \omagicf
                    \gor    \omagicm
                }
                \grule[general methods]{\ogenm}{
                            \osLR{ \omem, \ogenf } % < m, F >
                }
                \grule[magic functions]{\omagicf, \omagicm}{
                            \osMagic{CallFunc}
                    \gor    \osMagic{Type}
                }
                \grule[integers]{n}{}

              \end{grammar}
              \caption{Expression Grammar}
              \label{fig_langExpr}
          \end{figure}

          \begin{definition} Initialization
            \begin{flalign*}
            \osI{\osInit{\oheap}}{
                \{
                      \osInit{\opscope} \mapsto \osInit{\obinding},
                      \omem_{\osnone} \mapsto \{\;\},
                      \omem_{\texttt{AttrError}} \mapsto \{\;\},
                      \omem_{\texttt{FunType}} \mapsto \{\;\}, \\
                      &
                      \osMem{GetAttribute} \mapsto \obinding,
                      \osMem{SetAttr} \mapsto \obinding,
                \}
            } \\
            \osI{\osInit{\obinding}}{
                \{
                      \star\osnone \mapsto \omem_{\osnone},
                      \osType{AttributeError} \mapsto \osMem{AttrError},
                      \osType{FunctionType} \mapsto \osMem{FunType} \\
                \}
            } \\
            \osI{\osInit{\ostackframe}}{\osLR{\osInit{\opscope}, \osInit{\olbl}, \osInit{\oprogram}}} \\
            \osI{\osInit{\ostack}}{[\osInit{\ostackframe}]} \\
            % \osI{\osInit{\oparent}}{\{\;\}} \\
            % \osI{\omagicf}{\{\;\}} \\
            % \osI{\omagicm}{\{\;\}} \\
            % \osI{\osFunc{GetCall}}{\osLR{\opscope, \okw{def}(f) \ofuncarr
          \end{flalign*}
          \text{\tnote{"if \$1 == None then return getattribute(o.\osClown{class},a) else return \$1"}} \\
          \tnote{todo: add builtin mappings $\omem \mapsto \ogenf$}
          \end{definition}

      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Store \ovalue}{
                  \omem \notin \oheap \\
                  \oheap' = \oheap[\omem \mapsto \ovalue]
              }{
                  \olstack \listConcat [\ovalue, \osMC{Store}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\omem] \listConcat \omstack, \ostack, \oheap'
              }

              \relationRule{Wrap \ovalue \! in \omem}{
                  \ovalue' = \osGetObj(\omem, \ovalue)
              }{
                  \olstack \listConcat [\omem, \ovalue, \osMC{Wrap}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\ovalue'] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Bind \omem \! to \ovariable}{
                  \obinding = \oheap[\opscope] \\
                  \obinding' = \obinding[\ovariable \mapsto \omem] \\
                  \oheap' = \oheap[\opscope \mapsto \obinding']
              }{
                  \olstack \listConcat [\omem, \ovariable, \osMC{Bind}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack, \ostack, \oheap'
              }

              \relationRule{Advance}{
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective \\
                  \olbl \osBefore{\oprogram} \oglbl''
              }{
                  \olstack \listConcat [\osMC{Advance}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack, [\osLR{\opscope, \oglbl'', \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Pop}{
                  % \opscope' = \oparent[\opscope]
              }{
                  \olstack \listConcat [\osMC{Pop}] \listConcat \omstack, \ostackframe \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Push \oprogram}{
                  % \oparent' = \oparent[\opscope' \mapsto \opscope], \opscope' \notin \oparent \\
                  \oheap' = \oheap[\opscope' \mapsto \{\ostarvalue{parent} \mapsto \opscope\}],  \opscope' \notin \oheap \\
                  \oprogram = [\olbl:\oglbl':\odirective, \ldots]
              }{
                  \olstack \listConcat [\opscope, \osMC{Push} \;\oprogram] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack, [\osLR{\opscope', \olbl, \oprogram}] \listConcat \ostack, \oheap'
              }

              \relationRule{Look up \ovariable \,(bound)}{
                  % \obinding = \oheap[\opscope] \\
                  \osLookup(\oheap, \opscope, \ovariable) = \omem
              }{
                  \olstack \listConcat [\ovariable, \osMC{LookUp}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat [\omem] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Look up \ovariable \,(NameError)}{
                  \osLookup(\oheap, \opscope, \ovariable) = \osplat
              }{
                  \olstack \listConcat [\ovariable, \osMC{LookUp}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  [\osMC{AllocNameError}, \osMC{Raise}], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Make List}{
                  \ovalue = [\omem_1, \ldots, \omem_n]
              }{
                  \olstack \listConcat [\omem_1, \ldots, \omem_n, \osMC{List}\;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Make Tuple}{
                  \ovalue = (\omem_1, \ldots, \omem_n)
              }{
                  \olstack \listConcat [\omem_1, \ldots, \omem_n, \osMC{Tuple}\;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

            \end{mathpar}
            \caption{Microcommands}
            \label{fig_langMicro}
          \end{figure}

          \begin{figure}\center
              \begin{mathpar}

              \relationRule{Raise \,(no exception label)}{
                  \oprogram(\olbl) = \olbl:\osplat: \odirective \\
              }{
                  \olstack \listConcat [\osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat [\osMC{Pop}, \osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Raise \,(caught)}{
                  \oprogram(\olbl) = \olbl:\olbl_0: \odirective \\
                  \oprogram(\olbl_0) = \olbl_0:\olbl_1: \okw{catch} x \\
                  \omstack' = [\ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \olstack \listConcat [\osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack' \listConcat \omstack, [\osLR{\opscope, \olbl_0, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto \olbl}{
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \olstack \listConcat [\osMC{Goto}\;\olbl] \listConcat \omstack, [\osLR{\opscope, \olbl', \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \olstack \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(success)}{
                  \oheap[\omem] = \osfalse \\
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \olstack \listConcat [\omem, \osMC{Gotoifn}\;\olbl] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\osMC{Goto}\;\olbl] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(failure)}{
                  \oheap[\omem] = \ostrue
              }{
                  \olstack \listConcat [\omem, \osMC{Gotoifn}\;\olbl] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\osMC{Advance}] \listConcat \omstack, \ostack, \oheap
              }

              % \relationRule{Ignore \olcode}{
              % }{
              %     \oparent, \olstack \listConcat [\omem, \osMC{Ignore}] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, \olstack \listConcat \omstack, \ostack, \oheap
              % }

              \relationRule{Convert Function \ovalue}{
                  \ovalue = \ogenf \\
              }{
                  \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Convert Method \ovalue}{
                  \ovalue = \osLR{ \omem_0, \ogenf } \\
                  \ovalue' = \ogenf \\
              }{
                  \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\ovalue', \omem_0, \omem_1, \ldots, \omem_n, \osMC{Call} \;n+1] \listConcat \omstack, \ostack, \oheap
              }

              % \relationRule{Get Call \omem}{
              %     \ovalue = \oheap[\omem_0][\ostarvalue{value}], \text{\;\ovalue\, is of form \ogenm, \omagicm \;or \omagicf} \\ % F,M
              %     \omstack' = [\ovalue, \omem_1, \ldots, \omem_n]
              % }{
              %     \olstack \listConcat [\omem_0, \ldots, \omem_n, \osMC{GetCall} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              % }

              % \relationRule{Get Call (TypeError)}{
              %     \ovalue = \oheap[\omem_0][\ostarvalue{value}], \text{\;\ovalue\, is not of form \ogenm, \omagicm \;or \omagicf} % *
              % }{
              %     \olstack \listConcat [\omem_0, \ldots, \omem_n, \osMC{GetCall} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
              %     [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              % }
          \end{mathpar}
          \caption{Microcommands (cont.)}
          \label{fig_langMicro}
      \end{figure}

      \begin{figure}\center
          \begin{mathpar}
              \relationRule{Call function \omem}{
                % \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                \omstack' = [\opscope, \osMC{Push}\;\oprogram, \omem_1, \ovariable_1, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
              }{
                \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Call function (wrong args)}{
                \ovalue = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \oprogram }\\  q \neq n
                % \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \oprogram }, q \neq n
              }{
                \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              }


              % \relationRule{Convert Object \ovalue}{
              %     \ovalue = \osLR{ \omem_0, \ogenf } \\
              %     \ovalue' = \ogenf \\
              % }{
              %     \oparent, \olstack \listConcat [\ovalue, \omem_1, \ldots, \omem_n, \osMC{Convert} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, \olstack \listConcat [\ovalue', \omem_0, \omem_1, \ldots, \omem_n, \osMC{Call} \;n+1] \listConcat \omstack, \ostack, \oheap
              % }

              % \relationRule{Call method \omem}{
              %     \oheap[\omem] = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
              %     \omstack' = [\opscope, \osMC{Push}\;\oprogram, \omem_0, \ovariable_0, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
              % }{
              %     \oparent, \olstack \listConcat [\omem, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              % }
              %
              % \relationRule{Call method (wrong args)}{
              %     \oheap[\omem] = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_q) \ofuncarr \oprogram }, q \neq n
              % }{
              %     \oparent, \olstack \listConcat [\omem, \omem_1, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              % }

              \relationRule{Retrieve \ovariable}{
                  % \osFunc{LookupObj}(\oparent, \oheap, \omem, \ovariable) = \omem'
                  \omem' = \oheap[\omem][\ovariable] \\
                  %\omstack' = [\ovalue, \osMC{Store}]
              }{
                  \olstack \listConcat [\omem, \ovariable, \osMC{Retrieve}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\omem'] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Retrieve \ovariable \,(AttributeError)}{
                  % \osFunc{LookupObj}(\oparent, \oheap, \omem, \ovariable) = \osplat
                  \osplat = \oheap[\omem][\ovariable]
              }{
                  \olstack \listConcat [\omem, \ovariable, \osMC{Retrieve}] \listConcat \omstack, \ostack, \oheap \osTransition
                  [\osMC{AllocAttrError}, \osMC{Raise}], \ostack, \oheap
              }

              \relationRule{Get \omem}{
                  \ovalue = \oheap[\omem]
              }{
                  \olstack \listConcat [\omem, \osMC{Get}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

          \end{mathpar}
          \caption{Microcommands (cont.)}
          \label{fig_langMicro}
      \end{figure}


      \begin{figure}\center
          \begin{mathpar}
            % \relationRule{\_\_getattribute\_\_}{
            %     \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \ovariable'.\_\_getattribute\_\_(\ovariable'') \\
            %     \omstack = [\ovariable', \osMC{Lookup}, \ovariable'', \osMC{Retrieve}, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
            % }{
            %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
            %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
            % }
          \end{mathpar}
          \caption{Magic Functions}
          \label{fig_langMagic}
      \end{figure}

      \begin{figure}\center
          \begin{mathpar}

              % \relationRule{None Assignment}{
              %     \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \osnone \\
              %     \omstack = [\omem_{\osnone}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              % }{
              %     [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }

              \relationRule{Literal Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \oexpr,\,\oexpr \text{ is of form } \mathbb{Z}, \mathbb{S}\\
                  \ovalue = \oexpr \\
                  \omstack = [\ovalue, \osMC{Store}, \ovalue, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \tnote{TODO: make literal category (ints, str, bool)}

              \relationRule{Name Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable_1 = \ovariable_2 \\
                  \omstack = [\ovariable_2, \osMC{Lookup}, \ovariable_1, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{List Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable = [\ovariable_1, \ldots, \ovariable_n] \\
                  \omstack = [(\ovariable_1, \osMC{LookUp}), \ldots, (\ovariable_n, \osMC{LookUp}), \osMC{List} \; n, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \tnote{Parentheses in \omstack group instructions together for convenience of reading.}

              \relationRule{Tuple Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable = [\ovariable_1, \ldots, \ovariable_n] \\
                  \omstack = [(\ovariable_1, \osMC{LookUp}), \ldots, (\ovariable_n, \osMC{LookUp}), \osMC{Tuple} \; n, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{FunctionDef Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl': \ovariable = \okw{def} (\ovariable_1, \ldots, \ovariable_n) = \{\oprogram'\} \\
                  \ovalue = \osLR{ \opscope, \okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram' } \\
                  \omstack = [\ovalue, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Attribute Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_1.\ovariable_2 \\
                  % \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{Retrieve}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
                  \omstack = [\ovariable_1, \osMC{LookUp}, \ovariable_2, \osMC{Retrieve}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Call Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
                  % \omstack = [\ovariable_0, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{GetCall} \;n, \osMC{Convert} \;n]
                  \omstack = [\ovariable_0, \osMC{LookUp}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, [\ovariable_0, \osMC{LookUp}, \ldots, \ovariable_n, \osMC{LookUp}, \osMC{Convert} \;n]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

          \end{mathpar}
          \caption{Operational Semantics: Assignment}
          \label{fig_langOS}
      \end{figure}

      % \begin{figure}\center
      %     \begin{mathpar}
              %
              % \relationRule{Method Call}{
              %     \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_1.\ovariable_0(\ovariable_2,\ldots,\ovariable_n) \\
              %     \omstack = [\ovariable_1, \osMC{Lookup}, \ovariable_0, \osMC{Retrieve}, \ovariable_2, \osMC{Lookup}, \ldots, \ovariable_n, \osMC{Lookup},  \osMC{Call} \;n]
              % }{
              %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }
      %     \end{mathpar}
      %     \caption{Operational Semantics: Call}
      %     \label{fig_langOS}
      % \end{figure}

      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Raise}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{raise} \ovariable \\
                  \omstack = [\ovariable, \osMC{LookUp}, \osMC{Raise}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Pass}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{pass} \\
                  \omstack = [\osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Return}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{return} \ovariable \\
                  \ostack = [\osLR{ \opscope', \olbl'',\oprogram' }] \listConcat \ostack' \\
                  \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable' = \oexpr \\
                  \omstack = [\ovariable, \osMC{LookUp}, \osMC{Pop}, \ovariable', \osMC{Bind},\osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{goto} \olbl'' \\
                  \omstack = [\osMC{Goto} \;\olbl'']
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{GotoIfNot}{
                  \oprogram(\olbl) = \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
                  \omstack = [\ovariable, \osMC{Lookup}, \osMC{Gotoifn} \;\olbl'']
              }{
                  [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              % \relationRule{Name Statement}{
              %     \oprogram(\olbl) = \olbl:\olbl' : \ovariable \\
              %     \omstack = [\ovariable_1, \osMC{Lookup}, \osMC{Ignore}, \osMC{Advance}]
              % }{
              %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }

              \relationRule{End of Function}{
                  \ostackframe = \osLR{ \opscope', \olbl, \oprogram' } \\
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \oexpr \\
                  \omstack = [\osMC{Pop}, \omem_{\osnone}, \ovariable, \osMC{Bind},  \osMC{Advance}]
              }{
                  [\;], [\osLR{\opscope, \osplat, \oprogram}, \ostackframe] \listConcat \ostack, \oheap \osTransition
                  \omstack, [\osLR{\opscope, \osplat, \oprogram}, \ostackframe] \listConcat \ostack, \oheap
              }

              \tnote{$\omem_{\osnone}$ is a memory location reserved for \osnone.}

              \relationRule{End of Program}{
                  \ostack = [\osLR{\opscope, \osplat, \oprogram}] \\
                  \omstack = [\osMC{Pop}]
              }{
                  [\;], \ostack, \oheap \osTransition
                  \omstack, \ostack, \oheap
              }

          \end{mathpar}
          \caption{Operational Semantics: Flow}
          \label{fig_langOS}
      \end{figure}

      \begin{figure}

          % TODO: add lookup rule
          % Lookup
          \begin{definition}
            $$
              \obinding = \oheap[\opscope]
            $$
            \begin{equation}
              \osLookup(\oheap,\opscope,\ovariable) =
                \begin{cases}
                  \omem, & \text{if}\; \omem = \obinding[\ovariable] \\
                  \osLookup(\oheap,\opscope',\ovariable), & \text{if}\; \osplat = \obinding[\ovariable], \opscope' = \obinding[\ostarvalue{parent}] \\
                  \osplat, & \text{if}\; \osplat = \obinding[\ovariable], \osplat = \obinding[\ostarvalue{parent}]
                \end{cases}
              \end{equation}
          \end{definition}

          % LookupObj
          % \begin{definition}
          %   $$
          %     \osFunc{LookupObj}(\oparent,\oheap,\omem,\ovariable) =
          %     \tnote{todo}
          %   $$
          % \end{definition}

          % GetObj
          \begin{definition}
            $$
            \obinding_{\texttt{obj}} = \{
                \ostarvalue{value} \mapsto \omem, \text{\osClown{getattribute}} \mapsto \osMem{Getattribute} \} % the base object
            $$
              \begin{equation}
                \osGetObj (\omem, \ovalue) =
                  \begin{cases}
                    \obinding, & \text{if}\; \ovalue = \obinding \\
                    \obinding = \obinding_{\texttt{obj}}[\text{\osClown{class}} \mapsto \osMem{funType}], & \text{if}\; \ovalue = \ogenf \\
                  \end{cases}
                \end{equation}
          \end{definition}
          \tnote{getobj takes (H,m,memory location of getattribute)}
          \tnote{setattr}

          % GetCall
          % \begin{definition}
          %   $$
          %   \oheap[\omem] = \obinding
          %   , \obinding[\ostarvalue{value}] = \ovalue
          %   $$
          %     \begin{equation}
          %       \osGetCall (\oheap, \omem) =
          %         \begin{cases}
          %           % % CASE method
          %           % \osLR{\osLR{ \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram }, [\omem_0]}
          %           % , & \text{if }\ \ovalue = \osLR{ \omem_0, \opscope, \okw{def}(\ovariable_0, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
          %           %
          %           % CASE function & method
          %           \ovalue, & \text{if } \ovalue = \ogenf \;|\; \ogenm \\
          %           % CASE otherwise
          %           \osplat, & \text{otherwise}
          %         \end{cases}
          %       \end{equation}
          % \end{definition}

        \caption{Helper Functions}
        \label{fig_langhelper}
    \end{figure}
\end{document}
