\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

% TODO: Fix program state representation.

\begin{document}


        \begin{figure}\center
              \begin{grammar}
                \grule[variables]{\ovariable}{\osType{alphanumeric} \gor \star \osType{alphanumeric}}
                \grule[general labels]{\oglbl}{\olbl \gor \osplat}
                \grule[labels]{\olbl}{}
                \grule[stack]{\ostack}{
                            [\ostackframe,\ldots]
                }
                \grule[stack frames]{\ostackframe}{
                            \osLR{\opscope,\oglbl,\oprogram}
                }
                \grule[programs]{\oprogram}{
                            [\ostmt,\ldots]
                }
                \grule[clauses]{\ostmt}{\olbl:\oglbl:\odirective}
                % statements
                \grule[directives]{\odirective}{
                            \ovariable \gteq \oexpr % x = e
                    \gor    \okw{return} \ovariable % return x
                    \gor    \okw{goto} \olbl % goto x
                    \gor    \okw{goto} \olbl \okw{if not} \ovariable % goto x if not v
                    \gline
                    \gor    \okw{raise} \ovariable % raise x
                    \gor    \okw{catch} \ovariable % catch x
                    \gor    \okw{pass} % pass
                }
                \grule[bindings]{\obinding}{\{\ovariable \mapsto \omem, \ldots\}}
                \grule[heap]{\oheap}{\{\omem \mapsto \ovalue, \ldots\}}
                % value types
                \grule[values]{\ovalue}{
                            \mathbb{Z}
                    \gor    [\omem, \ldots] % [m, ...]
                    \gor    (\omem, \ldots) % (m, ...)
                    \gor    \obinding % B
                    \gor    \ogenf
                    \gor    \ogenm
                    % \gor    \osnone
                    \gor    \osplat
                }
                % expressions
                \grule[expressions]{\oexpr}{
                            \ovalue
                    \gor    \ovariable % x
                    \gor    \okw{def} \ovariable(\ovariable,\ldots) \gteq \{ \oprogram \} % def x(x, ...) = {S}
                    \gor    \ovariable(\ovariable, \ldots) % x(x, ...)
                    \gor    \ovariable.\ovariable % x.x
                    \gor    [\ovariable, \ldots] % [x, ...]
                    \gor    (\ovariable, \ldots) % (x, ...)
                }
                \grule[microcode stack]{\omstack}{[\omcode,\ldots]}
                \grule[microcode literal stack]{\olstack}{[\olcode,\ldots]}
                \grule[microcode commands]{\omcode}{
                            \osMC{Store}
                    \gor    \osMC{Wrap}
                    \gor    \osMC{Bind}
                    \gor    \osMC{LookUp}
                    \gor    \osMC{List} \;n
                    \gor    \osMC{Tuple} \;n
                    \gline
                    \gor    \osMC{Advance}
                    \gor    \osMC{Pop}
                    \gor    \osMC{Push} \;\oprogram
                    \gor    \osMC{Raise}
                    \gor    \osMC{Goto} \;\olbl
                    \gor    \osMC{Gotoifn} \;\olbl
                    % \gor    \osMC{Ignore}
                    \gline
                    \gor    \osMC{Call} \;n
                    \gor    \osMC{Retrieve}
                    \gor    \osMC{AllocNameError}
                    \gor    \osMC{AllocTypeError}
                }
                \grule[microcode literals]{\olcode}{
                            \ovariable
                    \gor    \omem
                    \gor    \ovalue
                }
                \grule[parental map]{\oparent}{\omem \mapsto \omem}
                \grule[general memory locations]{\ogmem}{
                            \omem
                    \gor    \opscope
                    \gor    \osplat
                }
                \grule[memory locations]{\opscope, \omem}{
                            \osType{<address>}
                    % \gor    \osnone
                }
                \grule[general functions]{\ogenf}{
                            \osLR{ \opscope,\okw{def}(\ovariable) \ofuncarr \oprogram } % < scope, def (x) -> S >
                    \gor    \omagicf
                }
                \grule[general methods]{\ogenm}{
                            \osLR{ \opscope,\opscope,\okw{def}(\ovariable) \ofuncarr \oprogram } % < scope, obj, def (x) -> S >
                    \gor    \osLR{ \opscope, \omagicm }
                }
                \grule[magic functions]{\omagicf}{}
                \grule[magic methods]{\omagicm}{}
                \grule[integers]{n}{}

              \end{grammar}
              \caption{Expression Grammar}
              \label{fig_langExpr}
          \end{figure}


      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Store \ovalue}{
                  \omem \notin \oheap \\
                  \oheap' = \oheap[\omem \mapsto \ovalue]
              }{
                  \oparent, \olstack \listConcat [\ovalue, \osMC{Store}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\omem] \listConcat \omstack, \ostack, \oheap'
              }

              \relationRule{Wrap \omem}{
                  \ovalue = \osGetObj(\oheap, \omem)
              }{
                  \oparent, \olstack \listConcat [\omem, \osMC{Wrap}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Bind \omem \! to \ovariable}{
                  \obinding = \oheap[\opscope] \\
                  \obinding' = \obinding[\ovariable \mapsto \omem] \\
                  \oheap' = \oheap[\opscope \mapsto \obinding']
              }{
                  \oparent, \olstack \listConcat [\omem, \ovariable, \osMC{Bind}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, \ostack, \oheap'
              }

              \relationRule{Advance}{
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective \\
                  \olbl \osBefore{\oprogram} \oglbl''
              }{
                  \oparent, \olstack \listConcat [\osMC{Advance}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, [\osLR{\opscope, \oglbl'', \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Pop}{
                  % \opscope' = \oparent[\opscope]
              }{
                  \oparent, \olstack \listConcat [\osMC{Pop}] \listConcat \omstack, \ostackframe \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Push \oprogram}{
                  \oparent' = \oparent[\opscope' \mapsto \opscope], \opscope' \notin \oparent \\
                  \oprogram = [\olbl:\oglbl':\odirective, \ldots]
              }{
                  \oparent, \olstack \listConcat [\opscope, \osMC{Push} \;\oprogram] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent', \olstack \listConcat \omstack, [\osLR{\opscope', \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Look up \ovariable \,(bound)}{
                  % \obinding = \oheap[\opscope] \\
                  \osLookup(\oparent, \oheap, \ostack, \ovariable) = \omem
              }{
                  \oparent, \olstack \listConcat [\ovariable, \osMC{LookUp}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\omem] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Look up \ovariable \,(NameError)}{
                  \osLookup(\oparent, \oheap, \ostack, \ovariable) = \osplat
              }{
                  \oparent, \olstack \listConcat [\ovariable, \osMC{LookUp}] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, [\osMC{AllocNameError}, \osMC{Raise}], \ostack, \oheap
              }

              \relationRule{Make List}{
                  \ovalue = [\omem_1, \ldots, \omem_n]
              }{
                  \oparent, \olstack \listConcat [\omem_1, \ldots, \omem_n, \osMC{List}\;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Make Tuple}{
                  \ovalue = (\omem_1, \ldots, \omem_n)
              }{
                  \oparent, \olstack \listConcat [\omem_1, \ldots, \omem_n, \osMC{Tuple}\;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\ovalue] \listConcat \omstack, \ostack, \oheap
              }

            \end{mathpar}
            \caption{Microcommands}
            \label{fig_langMicro}
          \end{figure}

          \begin{figure}\center
              \begin{mathpar}

              \relationRule{Raise \,(no exception label)}{
                  \oprogram(\olbl) = \olbl:\osplat: \odirective \\
              }{
                  \oparent, \olstack \listConcat [\osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\osMC{Pop}, \osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Raise \,(caught)}{
                  \oprogram(\olbl) = \olbl:\olbl_0: \odirective \\
                  \oprogram(\olbl_0) = \olbl_0:\olbl_1: \okw{catch} x \\
                  \omstack' = [\ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, \olstack \listConcat [\osMC{Raise}] \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack' \listConcat \omstack, [\osLR{\opscope, \olbl_0, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto \olbl}{
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \oparent, \olstack \listConcat [\osMC{Goto}\;\olbl] \listConcat \omstack, [\osLR{\opscope, \olbl', \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(success)}{
                  \oheap[\omem] = \osfalse \\
                  \oprogram(\olbl) = \olbl:\oglbl': \odirective
              }{
                  \oparent, \olstack \listConcat [\omem, \osMC{Gotoifn}\;\olbl] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\osMC{Goto}] \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Gotoifn \olbl \,(failure)}{
                  \oheap[\omem] = \ostrue
              }{
                  \oparent, \olstack \listConcat [\omem, \osMC{Gotoifn}\;\olbl] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat [\osMC{Advance}] \listConcat \omstack, \ostack, \oheap
              }

              % \relationRule{Ignore \olcode}{
              % }{
              %     \oparent, \olstack \listConcat [\omem, \osMC{Ignore}] \listConcat \omstack, \ostack, \oheap \osTransition
              %     \oparent, \olstack \listConcat \omstack, \ostack, \oheap
              % }

              \relationRule{Call \omem}{
                  \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                  \omstack' = [\opscope, \osMC{Push}\;\oprogram, \omem_1, \ovariable_1, \osMC{Bind}, \ldots, \omem_n, \ovariable_n, \osMC{Bind}]
              }{
                  \oparent, \olstack \listConcat [\omem_0, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, \olstack \listConcat \omstack' \listConcat \omstack, \ostack, \oheap
              }

              \relationRule{Call (wrong args)}{
                  \oheap[\omem_0] = \osLR{ \opscope,\okw{def}(\ovariable_1, \ldots, \ovariable_q) \ofuncarr \oprogram }, q \neq n
              }{
                  \oparent, \olstack \listConcat [\omem_0, \ldots, \omem_n, \osMC{Call} \;n] \listConcat \omstack, \ostack, \oheap \osTransition
                  \oparent, [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
              }

          \end{mathpar}
          \caption{Microcommands (cont.)}
          \label{fig_langMicro}
      \end{figure}

      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Literal Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \mathbb{Z} \\
                  % \osFunc{Valueofliteral}(\oexpr) = \ovalue \\
                  \omstack = [\ovalue, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \tnote{TODO: make literal category (ints, str, bool, None)}

              \relationRule{Name Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable_1 = \ovariable_2 \\
                  \omstack = [\ovariable_2, \osMC{Lookup}, \ovariable_1, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{List Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable = [\ovariable_1, \ldots, \ovariable_n] \\
                  \omstack = [(\ovariable_1, \osMC{Lookup}), \ldots, (\ovariable_n, \osMC{Lookup}), \osMC{List} \; n, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \tnote{Parentheses in \omstack group instructions together for convenience of reading.}

              \relationRule{Tuple Assignment}{
                  \oprogram(\olbl) = \olbl:\oglbl':\ovariable = [\ovariable_1, \ldots, \ovariable_n] \\
                  \omstack = [(\ovariable_1, \osMC{Lookup}), \ldots, (\ovariable_n, \osMC{Lookup}), \osMC{Tuple} \; n, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{FunctionDef Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl': \ovariable = \okw{def} (\ovariable_1, \ldots, \ovariable_n) = \{\oprogram'\} \\
                  \ovalue = \osLR{ \opscope, \okw{def}(\ovariable_1, \ldots, \ovariable_n) \ofuncarr \oprogram' } \\
                  \omstack = [\ovalue, \osMC{Store}, \osMC{Wrap}, \osMC{Store}, \ovariable, \osMC{Bind}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Attribute Assignment}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_1.\ovariable_2 \\
                  \omstack = [\ovariable_1, \osMC{Lookup}, \osMC{Call} \;n+1]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

          \end{mathpar}
          \caption{Operational Semantics: Assignment}
          \label{fig_langOS}
      \end{figure}

      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Function Call}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
                  \omstack = [\ovariable_0, \osMC{Lookup}, \ldots, \ovariable_n, \osMC{Lookup}, \osMC{Call} \;n+1]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Method Call}{
                  \oprogram(\olbl) = \olbl:\olbl':\ovariable = \ovariable_0(\ovariable_1,\ldots,\ovariable_n) \\
                  \omstack = [\ovariable_0, \osMC{Lookup}, \ldots, \ovariable_n, \osMC{Lookup}, \osMC{Call} \;n+1]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

          \end{mathpar}
          \caption{Operational Semantics: Call}
          \label{fig_langOS}
      \end{figure}

      \begin{figure}\center
          \begin{mathpar}

              \relationRule{Pass}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{pass} \\
                  \omstack = [\osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Return}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{return} \ovariable \\
                  \ostack = [\osLR{ \opscope', \olbl'',\oprogram' }] \listConcat \ostack' \\
                  \oprogram(\olbl'') = \olbl'':\oglbl''': \ovariable' = \oexpr \\
                  \omstack = [\ovariable, \osMC{LookUp}, \osMC{Pop}, \ovariable', \osMC{Bind},\osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{Goto}{
                  \oprogram(\olbl) = \olbl:\oglbl': \okw{goto} \olbl'' \\
                  \omstack = [\osMC{Goto} \;\olbl'']
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              \relationRule{GotoIfNot}{
                  \oprogram(\olbl) = \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
                  \omstack = [\ovariable, \osMC{Lookup}, \osMC{Gotoifn} \;\olbl'']
              }{
                  \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              }

              % \relationRule{Name Statement}{
              %     \oprogram(\olbl) = \olbl:\olbl' : \ovariable \\
              %     \omstack = [\ovariable_1, \osMC{Lookup}, \osMC{Ignore}, \osMC{Advance}]
              % }{
              %     \oparent, [\;], [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap \osTransition
              %     \oparent, \omstack, [\osLR{\opscope, \olbl, \oprogram}] \listConcat \ostack, \oheap
              % }

              \relationRule{End of Function}{
                  \ostackframe = \osLR{ \olbl,\oprogram' } \\
                  \oprogram(\olbl) = \olbl:\oglbl': \ovariable = \oexpr \\
                  \omstack = [\omem_{\osnone}, \ovariable, \osMC{Bind}, \osMC{Pop}, \osMC{Advance}]
              }{
                  \oparent, [\;], [\osLR{\opscope, \osplat, \oprogram}, \ostackframe] \listConcat \ostack, \oheap \osTransition
                  \oparent, \omstack, [\osLR{\opscope, \osplat, \oprogram}, \ostackframe] \listConcat \ostack, \oheap
              }

              \tnote{$\omem_{\osnone}$ is a memory location reserved for \osnone.}

              \relationRule{End of Program}{
              }{
                  \oparent, [\;], [\osLR{\opscope, \osplat, \oprogram}], \oheap \osTransition
                  \oparent, [\;], [\;], \oheap
              }

          \end{mathpar}
          \caption{Operational Semantics: Flow}
          \label{fig_langOS}
      \end{figure}
\end{document}
