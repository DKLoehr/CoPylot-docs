\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}


\begin{document}
    \section{CoPylot}

    \subsection{Grammar}



        \begin{figure}\center
              \begin{grammar}
                \grule[variables]{\ovariable}{\osalphanumeric \gor \star \osalphanumeric}
                \grule[labels]{\oglbl}{\olbl \gor \osend}
                \grule[stack]{\ostack}{
                            [\ostackframe,\ldots]
                }
                \grule[stack frames]{\ostackframe}{\oglbl \times \oprogram}
                \grule[programs]{\oprogram}{
                            [\ostmt,\ldots]
                }
                % statements
                \grule[directives]{\odirective}{
                            \ovariable \gteq \oexpr % x = e
                    \gor    \okw{def} \ovariable(\ovariable,\ldots) \gteq \{ \oprogram \}
                            % def x(x, ...) = {S}
                    \gor    \okw{return} \ovariable % return x
                    \gor    \okw{goto} \olbl % return x
                    \gor    \okw{goto} \olbl \okw{if not} \ovariable % return x
                }
                \grule[bindings]{\obinding}{\{\ovariable \mapsto \omem, \ldots\}}
                \grule[heap]{\oheap}{\{\omem \mapsto \ovalue, \ldots\}}
                % value types
                \grule[values]{\ovalue}{
                            \mathbb{Z}
                    \gor    \osLR{ \omem,\okw{def}(\ovariable) \ofuncarr \oprogram } % < scope, def (x) -> S >
                    \gor    \osLR{ \omem,\omem,\okw{def}(\ovariable) \ofuncarr \oprogram } % < scope, obj, def (x) -> S >
                    \gor    [\omem, \ldots] % [m, ...]
                    \gor    (\omem, \ldots) % (m, ...)
                    \gor    \obinding % B
                    \gor    \omagicf
                    \gor    \osLR{ \omem, \omagicm }
                }
                % expressions
                \grule[expressions]{\oexpr}{
                            \ovalue
                    \gor    \ovariable % x
                    \gor    \ovariable(\ovariable, \ldots) % x(x, ...)
                    \gor    [\ovariable, \ldots] % [x, ...]
                    \gor    (\ovariable, \ldots) % (x, ...)
                }
                \grule[parental map]{\oparent}{\omem \mapsto \omem}
                \grule[memory locations]{\omem}{}
                \grule[magic functions]{\omagicf}{}
                \grule[magic methods]{\omagicm}{}

              \end{grammar}

              \begin{definition}
                $$
                  \osBind (\oheap,\omem_0,\ovariable,\omem) \gteq \oheap' \text{ such that } \obinding \gteq \oheap[\omem_0], \obinding' \gteq \obinding[\ovariable \mapsto \omem], \oheap' \gteq \oheap[\omem_0 \mapsto \obinding']
                $$
              \end{definition}

              \begin{definition}
                $$
                  \osBind (\oheap,\omem_0,\ovariable_1,\omem_1,\ldots,\ovariable_n,\omem_n) \gteq \osBind (\ldots ((\osBind ((\osBind (\oheap, \omem_0, \ovariable_1, \omem_1)), \omem_0, \ovariable_2, \omem_2), \ldots), \omem_0, \ovariable_n, \omem_n)
                $$
              \end{definition}

              % TODO: add lookup rule
              \begin{definition}
                $$
                  \osLookup(\omem_0,\oparent,\oheap,\ovariable_2) \gteq
                $$
              \end{definition}

              \begin{definition}
                  \begin{equation}
                      \osCatch (\osLR{\olbl,\oprogram}) \gteq
                      \begin{cases}
                        \olbl', \ovariable, & \text{if}\ \odirective \gteq \okw{catch} \ovariable \\
                        \okw{undefined}, & \text{otherwise}
                      \end{cases}
                      , \olbl:\olbl':\odirective \in \oprogram
                    \end{equation}
              \end{definition}

              \begin{definition}
                  \begin{equation}
                    \osGetObj (\omem) \gteq
                      \begin{cases}
                        \obinding, & \text{if}\ \ovalue \gteq \obinding \\
                        \obinding[\ostarvalue{value} \mapsto \ovalue], & \text{otherwise}
                      \end{cases}
                      , \oheap[\omem] \gteq \ovalue
                    \end{equation}
              \end{definition}

              \begin{mathpar}
              \relationRule{Literal Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable \gteq \ovalue \\
                  \obinding_{\texttt{obj}} \gteq \{\ostarvalue{value} \mapsto \omem\} \\
                  \oheap' \gteq \oheap[\omem \mapsto \ovalue, \omem' \mapsto \obinding_{\texttt{obj}}] \\
                  \omem,\omem' \notin \oheap \\
                  \osBind (\oheap',\omem_0,\ovariable,\omem') \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }

              \relationRule{Name Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable_1 \gteq \ovalue_2 \\
                  \omem \gteq \osLookup (\omem_0,\oparent,\oheap,\ovariable_2)\\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable_1 \mapsto \omem] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap,\omem_0,\ovariable_1,\omem) \gteq \oheap' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap',\oparent,\omem_0
              }

              \relationRule{List Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable \gteq [\ovariable_1,\ldots,\ovariable_n] \\
                  \forall i \in \{1,\ldots,n\}, \omem_i \gteq \osLookup(\omem_0,\oparent,\oheap,\ovariable_i) \\
                  \ovalue \gteq [\omem_1,\ldots,\omem_n] \\
                  \obinding_{\texttt{obj}} \gteq \{\ostarvalue{value} \mapsto \omem\} \\
                  \oheap' \gteq \oheap[\omem \mapsto \ovalue, \omem' \mapsto \obinding_{\texttt{obj}}] \\
                  \omem,\omem' \notin \oheap \\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable \mapsto \omem'] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap',\omem_0,\ovariable,\omem') \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  \osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }

            \end{mathpar}
            \caption{Operational Semantics}
            \label{fig_languageOS}
            \end{figure}

            \begin{figure}\center
              \ContinuedFloat
                \begin{mathpar}

              \relationRule{Tuple Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable \gteq (\ovariable_1,\ldots,\ovariable_n) \\
                  \forall i \in \{1,\ldots,n\}, \omem_i \gteq \osLookup(\omem_0,\oparent,\oheap,\ovariable_i) \\
                  \ovalue \gteq (\omem_1,\ldots,\omem_n) \\
                  \obinding_{\texttt{obj}} \gteq \{\ostarvalue{value} \mapsto \omem\} \\
                  \oheap' \gteq \oheap[\omem \mapsto \ovalue, \omem' \mapsto \obinding_{\texttt{obj}}] \\
                  \omem,\omem' \notin \oheap \\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable \mapsto \omem'] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap',\omem_0,\ovariable,\omem') \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  \osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }

              \relationRule{Function Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl': \ovariable_1 \gteq \okw{def} (\ovariable_2, \ldots, \ovariable_n) \gteq \{\oprogram\} \\
                  \ovalue \gteq \osLR{ \omem_0, \okw{def}(\ovariable_2, \ldots, \ovariable_n) \ofuncarr \oprogram } \\
                  \obinding_{\texttt{obj}} \gteq \{\ostarvalue{value} \mapsto \omem\} \\
                  \oheap' \gteq \oheap[\omem \mapsto \ovalue, \omem' \mapsto \obinding_{\texttt{obj}}] \\
                  \omem,\omem' \notin \oheap \\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable_1 \mapsto \omem] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap',\omem_0,\ovariable_1,\omem') \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }

              \relationRule{Method Assignment}{
                  % TODO
              }{
              }

              \relationRule{Function Call Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable_1 \gteq \ovariable_2(\ovariable_3,\ldots,\ovariable_n) \\
                  \omem \gteq \osLookup (\omem_0,\oparent,\oheap,\ovariable_2)\\
                  \oheap[\omem][\ostarvalue{obj}] \gteq \osLR{ \omem_0',\okw{def}(\ovariable_3',\ldots,\ovariable_n') \mapsto \oprogram' } \\
                  \omem_0'' \notin \oheap \\
                  \oheap' \gteq \oheap[\omem_0'' \mapsto \{\;\}] \\
                  \forall i, 3 \leq i \leq n, \omem_i' \gteq \osLookup (\omem_0,\oparent,\oheap,\ovariable_i) \\
                  % \obinding' \gteq \obinding [\ovariable_4 \mapsto \omem'] \\
                  % \oenv' \gteq \oenv[\omem_0'' \mapsto \obinding'] \\
                  \osBind (\oheap',\omem_0'',\ovariable_1',\omem_1',\ldots,\ovariable_n',\omem_n') \gteq \oheap'' \\
                  \oparent' \gteq \oparent \cup \{\omem_0'' \mapsto \omem_0'\} \\
                  \oprogram' \gteq [\olbl'':\olbl''':\odirective, \ldots]
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \olbl'',\oprogram' },\osLR{ l,S }] \listConcat \ostack,\oheap'',\oparent',\omem_0''
              }


              \relationRule{Attribute Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable_1 \gteq \ovariable_2.\ovariable_3 \\
                  \omem \gteq \osLookup(\omem_0,\oparent,\oheap,\ovariable_2) \\
                  \oheap[\omem] \gteq \obinding \\
                  \obinding[\ovariable_3] \gteq \omem' \\
                  % \omem' \notin \oheap \\
                  % \oheap[\omem'] = \ovalue \\
                  % TODO: determine whether is object, wrap accordingly
                  \obinding_{\texttt{obj}} \gteq \osGetObj (\omem') \\
                  \omem'' \notin \oheap \\
                  \oheap' \gteq \oheap[\omem'' \mapsto \obinding_{\texttt{obj}}] \\
                  \osBind (\oheap',\omem_0,\ovariable_1,\omem'') \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl'
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl',\oprogram }] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }

            \end{mathpar}
            \caption{Operational Semantics (cont.)}
            \label{fig_languageOS}
        \end{figure}

        \begin{figure}\center
          \ContinuedFloat
            \begin{mathpar}

              \relationRule{Raise Exception Caught}{
                  \oprogram(\olbl) \gteq \olbl:\olbl': \okw{raise} \ovariable \\
                  \ostack \gteq [\osLR{\olbl_1,\oprogram_1},\ldots,\osLR{\olbl_n,\oprogram_n}] \\
                  \olbl_1 \gteq \olbl' \\
                  \forall i, 1 \leq i \leq k, k \le n, \osCatch (\osLR{\olbl_i,\oprogram_i}) \gteq \okw{undefined} \\
                  \osCatch(\osLR{\olbl_{k+1},\oprogram_{k+1}}) \gteq \olbl', \ovariable' \\
                  \omem = \osLookup(\omem_0,\oparent,\oheap,\ovariable) \\
                  \osBind(\oheap,\omem_0,\ovariable',\omem) \gteq \oheap' \\
                  \olbl_(k+1)' \osBefore{S_{k+1}} \oglbl''
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'',\oprogram_{k+1} }] \listConcat \ostack,\oheap',\oparent,\omem_0
              }

              \relationRule{Raise Exception Escaped}{
                  \oprogram(\olbl) \gteq \olbl:\olbl': \okw{raise} \ovariable \\
                  \ostack \gteq [\osLR{\olbl_1,\oprogram_1},\ldots,\osLR{\olbl_n,\oprogram_n}] \\
                  \olbl_1 \gteq \olbl' \\
                  \forall i, 1 \leq i \leq n, \osCatch (\osLR{\olbl_i,\oprogram_i}) \gteq \okw{undefined} \\
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\;],\oheap,\oparent,\omem_0
              }

              \relationRule{Pass}{
                  \oprogram(\olbl) \gteq \olbl:\olbl': \okw{pass} \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0
              }

              % \relationRule{Return}{
              %     \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{return}  \\
              %     \ostack \gteq [\ostackframe,\osLR{ \olbl'',\oprogram' }] \listConcat \ostack' \\
              %     \omem_0' \gteq \oparent[\omem_0] \\
              %     \olbl'' \osBefore{S'} \oglbl''' \\
              % }{
              %     [\ostackframe,\osLR{ \olbl'',\oprogram' }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
              %     [\osLR{ \oglbl''',\oprogram' }] \listConcat \ostack',\oheap,\oparent,\omem_0'
              % }

              % Used to be "return with arguments"
              \relationRule{Return}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{return}  \ovariable \\
                  \ostack \gteq [\ostackframe,\osLR{ \olbl'',\oprogram' }] \listConcat \ostack' \\
                  \omem \gteq \osLookup(\omem_0,\oparent,\oheap,\ovariable) \\
%
                  \omem_0' \gteq \oparent[\omem_0] \\
                  % \obinding \gteq \oenv(\omem_0') \\
                  % \obinding' \gteq \obinding[\ovariable_1 \mapsto \omem] \\
                  % \oenv' \gteq \oenv[\omem_0' \mapsto \obinding'] \\
                  \osBind (\oheap,\omem_0',\ovariable_1,\omem) \gteq \oheap' \\
%
                  \olbl'' \osBefore{S'} \oglbl'''' \\
              }{
                  [\ostackframe,\osLR{ \olbl'',\oprogram' }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \oglbl'''',\oprogram' }] \listConcat \ostack,\oheap',\oparent,\omem_0'
              }

              \relationRule{Goto}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{goto} \olbl'' \\
                  (\olbl'':\olbl''':\odirective) \in \oprogram
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \olbl'',\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0
              }

              \relationRule{GotoIfNot}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
                  \omem = \osLookup(\omem_0,\oparent,\oheap,\ovariable) \\
                  \oheap[\omem][\ostarvalue{value}] \gteq \osfalse \\
                  (\olbl'':\olbl''':\odirective) \in \oprogram
              }{
                  [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\osLR{ \olbl'',\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0
              }

            \relationRule{GotoIfNot Failed}{
                \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
                \omem = \osLookup(\omem_0,\oparent,\oheap,\ovariable) \\
                \oheap[\omem][\ostarvalue{value}] \gteq \ostrue \\
                \olbl \osBefore{S'} \oglbl'' \\
            }{
                [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0
            }

            \relationRule{Name Statement}{
                \oprogram(\olbl) \gteq \olbl:\olbl' : \oexpr \\
                \forall \ovariable \in \oexpr \exists \obinding[\ovariable] \\
                %%% \ovariable | \ovalue | \ovariable(\ovariable_1,\ldots,\ovariable_n) | \ovariable.\ovariable' | [\ovariable_1,\ldots,\ovariable_n] | (\ovariable_1,\ldots,\ovariable_n)
                \olbl \osBefore{S'} \oglbl'' \\
            }{
                [\osLR{ \olbl,\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                [\osLR{ \oglbl'',\oprogram }] \listConcat \ostack,\oheap,\oparent,\omem_0
            }

        \end{mathpar}
        \caption{Operational Semantics (cont.)}
        \label{fig_languageOS}
    \end{figure}

    \begin{figure}\center
      \ContinuedFloat
        \begin{mathpar}

            \relationRule{End of Function}{
                \ostack \gteq [\osLR{ \osend,\oprogram },\osLR{ \olbl,\oprogram' }]\listConcat \ostack' \\
                \omem_0' \gteq \oparent[\omem_0] \\
                \olbl \osBefore{S'} \oglbl'
            }{
                [\osLR{ \osend,\oprogram },\osLR{ \olbl,\oprogram' }] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                [\osLR{ \olbl',\oprogram' }] \listConcat \ostack',\oheap,\oparent,\omem_0'
            }

            \relationRule{End of Program}{
                \ostack = [(\osend,\ostackframe)] \\
            }{
                \ostack,\oheap,\oparent,\omem_0 \osTransition
                [\;],\oheap,\oparent,\omem_0
            }
        \end{mathpar}
        \caption{Operational Semantics (cont.)}
        \label{fig_languageOS}
    \end{figure}

    \begin{figure}\center
        \begin{grammar}
            \grule[abstract programs]{\aprogram}{
                        [\astmt,\ldots]
            }
            \grule[abstract statements]{\astmt}{
                        \xstmt{\albl}{\albl}{\adirective}
            }
            \grule[abstract directives]{\adirective}{
                        \avariable \gteq \avalue
                \gor    \avariable \gteq \avariable
            }
            \grule[abstract values]{\avalue}{
                        \gtintplus
                \gor    \gtintminus
                \gor    \gtintzero
            }
            \grule[abstract variables]{\avariable}{}
            \grule[abstract labels]{\albl}{}

        \end{grammar}
        \caption{Normalized Python Language Grammar}
        \label{fig_languageGrammar}
    \end{figure}

    The grammar of the language to be analyzed appears in Figure~\ref{fig_languageGrammar}.

    We assume throughout the rest of this document that a fixed program $\aprogram$ is under analysis.  \znote{TODO: describe here the idea of a bijection between labels and statements in this fixed program.}

    \subsection{Control Flow}

    The grammar of control flow graphs appears in Figure~\ref{fig_cfgGrammar}.  \znote{Discuss construction of initial graph.}

    \begin{figure}\center
        \begin{grammar}
            \grule[control flow graphs]{\cfg}{
                        \{\cfgedge, \ldots\}
            }
            \grule[control flow graph edge]{\cfgedge}{
                        \cfgnode \lexicallyBefore \cfgnode
                \gor    \cfgnode \before \cfgnode
            }
            \grule[control flow graph nodes]{\cfgnode}{
                        \gstart
                \gor    \gend
                \gor    \astmt
            }
        \end{grammar}
        \caption{Control Flow Graph Grammar}
        \label{fig_cfgGrammar}
    \end{figure}



    We write $\cfgnode \islexicallyBefore \cfgnode'$ to denote $(\cfgnode \lexicallyBefore \cfgnode' \in \cfg$ when $\cfg$ is understood from context.  Likewise, we write $\cfgnode \isbefore \cfgnode'$ to denote $(\cfgnode \before \cfgnode' \in \cfg$ when $\cfg$ is understood from context.

    We define a relation $\cfgClosureStep$ to perform control flow graph closure.

    \begin{definition}
        Let $\cfg \cfgClosureStep \cfg'$ be the least relation satisfying the rules appearing in Figure~\ref{fig_cfgClosure}.  Throughout these rules, the predicates $\isbefore$ and $\islexicallyBefore$ refer to graph $\cfg$.
    \end{definition}

    \begin{figure}
        \begin{mathpar}
            \relationRule{Lexical Start}{
                \gstart \islexicallyBefore \cfgnode
            }{
                \cfg \cfgClosureStep \cfg \cup \{\gstart \before \cfgnode\}
            }

            \relationRule{Literal Assignment}{
                \cfgnode_1 = (\avariable \gteq \avalue) \\
                \cfgnode_1 \islexicallyBefore \cfgnode_2
            }{
                \cfg \cfgClosureStep \cfg \cup \{\cfgnode_1 \before \cfgnode_2\}
            }

            \relationRule{Variable Accessible}{
                \cfgnode_1 = (\avariable \gteq \avariable') \\
                \cfgnode_1 \islexicallyBefore \cfgnode_2 \\
                \avalue \in \valueLookup{\cfgnode_1}{[\avariable']} \\
                \avalue \neq {\text{\textsmaller{\sc Undefined}}}
            }{
                \cfg \cfgClosureStep \cfg \cup \{\cfgnode_1 \before \cfgnode_2\}
            }
        \end{mathpar}
        \caption{Control Flow Graph Closure}
        \label{fig_cfgClosure}
    \end{figure}

    \subsection{Value Lookup}

    The value lookup function uses the additional grammar in Figure~\ref{fig_valueLookupGrammar}.

    \begin{figure}
        \begin{grammar}
            \grule[lookup stacks]{\astack}{
                        [\astackelement, \ldots]
            }
            \grule[lookup stack elements]{\astackelement}{
                        \avariable
                \gor    \avalue % subject to change to e.g. heap fragments
                \gor    \kcapture{\mathbb{N}}
                \gor    \kjump{\cfgnode}
            }
        \end{grammar}
        \caption{Value Lookup Grammar}
        \label{fig_valueLookupGrammar}
    \end{figure}

    \begingroup
        \newenvironment{enumerateClauses}%
            {\begin{enumerate}[label=(\alph*),ref=\arabic{enumi}\alph*]}%
            {\end{enumerate}}
        \newenvironment{enumerateSubclauses}%
            {\begin{enumerate}[label=\roman*.,ref=\arabic{enumi}\alph{enumii}(\roman*)]}%
            {\end{enumerate}}
        \newcommand{\clauseSectionTitle}[1]{\textbf{#1}}
        \newcommand{\clauseSubsectionTitle}[1]{\underline{\smash{#1}}}
        \newcommand{\rulename}[1]{%
            \begingroup%
                \setlength{\fboxsep}{1.5pt}%
                \fcolorbox{black}{gray!15!white}{%
                    \textsc{\textsmaller{#1}}%
                }%
                \vspace*{1pt}%
            \endgroup%
            \\%
        }
        \begin{definition}
            Given a control-flow graph $\cfg$, let $\valueLookup[\cfg]{\cfgnode_0}{\astack}$ be the function returning the least set $\avalues$ which satisfies the following conditions:

            \begin{enumerate}
                \item \clauseSectionTitle{Value Manipulation}
                \begin{enumerateClauses}
                    \item \rulename{Result}
                        If
                            $\astack = [\avalue]$,
                        then
                            $\avalue \in \avalues$.
                \end{enumerateClauses}

                \item \clauseSectionTitle{Variable Lookup}
                \begin{enumerateClauses}
                    \item \rulename{Value Discovery}
                        If
                            $\cfgnode_1 \isbefore \cfgnode_0$,
                            $\cfgnode_1 =
                                \xstmt{\albl_1}{\albl_2}{\avariable \gteq \avalue}$, and
                            $\astack = [\avariable] \listConcat \astack'$,
                        then
                            $\valueLookup{\cfgnode_1}{[\avalue] \listConcat \astack'} \subseteq \avalues$.

                    \item \rulename{Value Skip}
                        If
                            $\cfgnode_1 \isbefore \cfgnode_0$,
                            $\cfgnode_1 =
                                \xstmt{\albl_1}{\albl_2}{\avariable' \gteq \avalue}$,
                            $\astack = [\avariable] \listConcat \astack'$, and
                            $\avariable \neq \avariable'$,
                        then
                            $\valueLookup{\cfgnode_1}{\astack} \subseteq \avalues$.
                    \item \rulename{Value Aliasing}
                        If
                            $\cfgnode_1 \isbefore \cfgnode_0$,
                            $\cfgnode_1 =
                                \xstmt{\albl_1}{\albl_2}{\avariable \gteq \avariable'}$, and
                            $\astack = [\avariable] \listConcat \astack'$,
                        then
                            $\valueLookup{\cfgnode_1}{[\avariable'] \listConcat \astack} \subseteq \avalues$.
                \end{enumerateClauses}


            \end{enumerate}
        \end{definition}
        \endgroup
\end{document}
