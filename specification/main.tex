\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

\begin{document}
  \section{Operational Semantics}

  \subsection{Lamia Language Grammar}

  \begin{grammar}
    \grule[labels]{\olbl}{}
    \grule[value variables]{\ovalvariable}{}
    \grule[memory variables]{\omemvariable}{}
    \grule[blocks]{\ostmts}{
                \ostmt \gtsemi \ldots
    }
    \grule[statements]{\ostmt}{
                \olbl \gtcolon \odirective
    }
    \grule[blocks]{\otstmts}{
                \otstmt \gtsemi \ldots
    }
    \grule[statements]{\otstmt}{
                \odirective \text{ such that all \ostmts \, are replaced with \otstmts}
        \gor    \gtobrc \osBlock{while} \gtcbrc
        % \gor    \gtobrc \osBlock{try} \gtcbrc
        \gline
        \gor    \gtobrc \osBlock{if} \gtcbrc
        \gor    \gtlet \omemvariable \gteq \gtobrc \osBlock{fun} \gtcbrc
    }
    \grule[directive]{\odirective}{
                \gtlet \ovalvariable \gteq \oexpr \gline
        \gor    \gtlet \omemvariable \gteq \gtalloc \gline
        % \gor    \gtlet \ovalvariable \gteq \gtmethodbind \omemvariable \; \ovalvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ovalvariable \gline
        \gor    \gtlet \omemvariable \gteq \omemvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtarrow \omemvariable \gtcbrc \gline
        \gor    \gtlet \omemvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtcbrc \gline
        \gor    \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable \gtcomma \ldots \gtcpar \gline
        \gor    \gtlet \omemvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcbrk \gline
        \gor    \gtlet \ovalvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcolon \ovalvariable \gtcbrk \gline
        \gor    \gtstore \omemvariable\ \ovalvariable \gline
        \gor    \gtlet \ovalvariable \gteq \gtget \omemvariable \gline
        \gor    \gtlet \ovalvariable \gteq \omemvariable \gtis \omemvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ounop \ovalvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ovalvariable \obinop \ovalvariable \gline
        \gor    \gtifresult \ovalvariable \gline
        \gor    \gtifresult \omemvariable \gline
        \gor    \gtreturn \omemvariable \gline
        \gor    \gtraise \omemvariable \gline
        \gor    \gttry \gtobrc \ostmts \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts \gtcbrc \gline
        \gor    \gtlet \ovalvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts \gtcbrc \gtelse \gtobrc \ostmts \gtcbrc \gline
        \gor    \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts \gtcbrc \gtelse \gtobrc \ostmts \gtcbrc \gline
        \gor    \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc
    }
    \grule[unary operators]{\ounop}{
                \gtnot
        \gor    \gtisfunc
        \gor    \gtisint
        \gor    \gtisbool
    }
    \grule[binary operators]{\obinop}{
                \gtintplus
        \gor    \gtintminus
        % \gor    \gtand
        % \gor    \gtor
        \gor    \gthaskey
        \gor    \gtlstconcat
        \gor    \gtcmp
    }
    \grule[value expressions]{\oexpr}{
                \mathbb{Z}
        \gor    \mathbb{S}
        \gor    \mathbb{B}
        \gor    \gtdef \gtopar \ovalvariable, \ldots \gtcpar \gtobrc \ostmts \gtcbrc
        \gor    \gtobrk \omemvariable, \ldots \gtcbrk
        \gor    \gtobrk \omemvariable, \ldots \gtcpar
        \gor    \gtobrc \gtcbrc
        \gor    \osnone
    }
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
    \grule[heap]{\oheap}{
                \gtobrc \ovalvariable \mapsto \ovalue, \ldots \gtcbrc
        \cup    \gtobrc \omemvariable \mapsto \omem, \ldots \gtcbrc
        \cup    \gtobrc \omem \mapsto \ovalue, \ldots \gtcbrc
    }
  \end{grammar}

  \subsection{Lamia Evaluation Grammar}

  \begin{grammar}
    \grule[memory addresses]{\omem,\opscope}{\osFunc{Alloc}(\gsLR{\gnode, \gtime})}
    \grule[values]{\ovalue}{
                \mathbb{Z}
        \gor    \mathbb{S}
        \gor    \mathbb{B}
        \gor    [\omem, \ldots]_k % [m, ...]
        \gor	  \osBag{\omem, \ldots}
        % \gor    (\omem, \ldots) % (m, ...)
        \gor    \obinding % B
        \gor    \ogenf
        % \gor    \ogenm
        \gor    \osnone
    }
    \grule[binding records]{\obinding}{
                \{ \mathbb{S} \mapsto \omem, \ldots \}
    }
    \grule[functions]{\ogenf}{
                \gtfun \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtarrow \otstmts
    }
    % \grule[methods]{\ogenm}{
    %             \osLR{\gtfun \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtarrow \otstmts, \omem_0}
    % }

  \end{grammar} \\
  \tnote{We need some type implementation. }


  \subsection{Lamia Language Rules}

  \begin{mathpar}
    \relationRule{Value Assignment}{
      \ovalue = \osFunc{Valueof}(\oexpr) \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \oexpr \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Memory Alloc}{
      \omem = \osFunc{Alloc}() \\
      \oheap' = \oheap[\omemvariable \mapsto \omem]
    }{
      [\gtlet \omemvariable \gteq \gtalloc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  % \begin{mathpar}
  %   \relationRule{Method Assignment}{
  %     \omem = \oheap[\omemvariable] \\
  %     \ovalue = \oheap[\ovalvariable'] = \ogenf \\
  %     \ovalue' = \osLR{\ovalue, \omem} \\
  %     \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
  %   }{
  %     [\gtlet \ovalvariable \gteq \gtmethodbind \omemvariable \; \ovalvariable'] \listConcat \otstmts, \oheap \osTransition
  %     \otstmts, \oheap'
  %   }
  % \end{mathpar}

  \begin{mathpar}
    \relationRule{Value Alias}{
      \oheap' = \oheap[\ovalvariable_2 \mapsto \oheap[\ovalvariable_1]]
    }{
      [\gtlet \ovalvariable_1 \gteq \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Memory Alias}{
      \oheap' = \oheap[\omemvariable_2 \mapsto \oheap[\omemvariable_1]]
    }{
      [\gtlet \omemvariable_1 \gteq \omemvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Bind}{
      \obinding = \oheap[\ovalvariable_1] \\
      \ovalue = \oheap[\ovalvariable_2] \\
      \omem = \oheap[\omemvariable] \\\\
      \obinding' = \obinding[\ovalue \gtarrow \omem] \\
      \oheap' = \oheap[\ovalvariable_1 \mapsto \obinding']
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtarrow \omemvariable \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Retrieve}{
      \obinding = \oheap[\ovalvariable_1] \\
      \omem = \obinding[\ovalvariable_2] \\
      \oheap' = \oheap[\omemvariable \mapsto \omem]
    }{
      [\gtlet \omemvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Index}{
      \ovalue_1 = \oheap[\ovalvariable_1] = [\omem_0, \ldots, \omem_n]_k \\
      \ovalue_2 = \oheap[\ovalvariable_2] = i \in \mathbb{Z^+} \\
      \omem = \text{the memloc stored in the $i^{th}$ position of $\ovalue_1$} \\
      \oheap' = \oheap[\omemvariable \mapsto \omem]
    }{
      [\gtlet \omemvariable \gteq \ovalvariable_1 \gtobrk \ovalvariable_2 \gtcbrk \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

    \begin{mathpar}
    \relationRule{Index (imprecise)}{
      \ovalue_1 = \oheap[\ovalvariable_1] = \osBag{\omem_1, \ldots, \omem_n} \\
      \ovalue_2 \in \ovalue_1 \\
      \oheap' = \oheap[\omem \mapsto \ovalue_2] \\
      \oheap'' = \oheap'[\omemvariable \mapsto \omem]
    }{
      [\gtlet \omemvariable \gteq \ovalvariable_1 \gtobrk \ovalvariable_2 \gtcbrk \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Slice}{
      \ovalue = \oheap[\ovalvariable'] = [\omem_0, \ldots, \omem_n] \\
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] \\
      p =
      \begin{cases}
        \ovalue_1, & \text{if } \ovalue_1 \in \mathbb{Z} \cr
        0, & \text{if } \ovalue_1 = \osnone
      \end{cases} \\
      q =
      \begin{cases}
        \ovalue_2 - 1, & \text{if } \ovalue_2 \in \mathbb{Z} \cr
        n, & \text{if } \ovalue_2 = \osnone
      \end{cases} \\
      \ovalue' = [\omem_p, \ldots, \omem_q] \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable' \gtobrk \ovalvariable_1 \gtcolon \ovalvariable_2 \gtcbrk \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Slice (imprecise)}{
      \ovalue = \oheap[\ovalvariable'] = \osBag{\omem_1, \ldots, \omem_n} \\ % TODO: of the same type
      \ovalue' \subseteq \ovalue \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable' \gtobrk \ovalvariable_1 \gtcolon \ovalvariable_2 \gtcbrk \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Store}{
      \omem = \oheap[\omemvariable] \\
      \ovalue = \oheap[\ovalvariable] \\
      \oheap' = \oheap[\omem \mapsto \ovalue]
    }{
      [\gtstore \omemvariable\ \ovalvariable \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Get}{
      \omem = \oheap[\omemvariable] \\
      \ovalue = \oheap[\omem] \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \gtget \omemvariable \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Is}{
      \omem_1 = \oheap[\omemvariable_1] \\
      \omem_2 = \oheap[\omemvariable_2] \\
      \ovalue =
      \begin{cases}
        \ostrue, & \text{if } \omem_1 = \omem_2 \cr
        \osfalse, & \text{if } \omem_1 \neq \omem_2
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \omemvariable_1 \gtis \omemvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \subsubsection{While}

  \begin{mathpar}
    \relationRule{While Block}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtobrc \osBlock{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtobrc \osBlock['']{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{While Block Empty}{
      \\
    }{
      [\gtobrc [\;]_{\texttt{while}} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{While False}{
      \oheap[\omemvariable] = \omem \\
      \oheap[\omem] = \osfalse
    }{
      [\gtwhile \omemvariable \gtdo \gtobrc \otstmts \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{While True}{
      \oheap[\omemvariable] = \omem \\
      \oheap[\omem] = \ostrue
    }{
      [\gtwhile \omemvariable \gtdo \gtobrc \otstmts \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtobrc \osBlock{while} \gtcbrc \gtsemi, \gtwhile \omemvariable \gtdo \gtobrc \otstmts \gtcbrc \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \subsubsection{Function}

  \begin{mathpar}
    \relationRule{Function Block}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock['']{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Call}{
      \oheap[\ovalvariable_0] = \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1 \\
      \otstmts'_2 = [\gtlet \ovalvariable'_1 \gteq \ovalvariable_1, \ldots, \gtlet \ovalvariable'_n \gteq \ovalvariable_n] \listConcat \otstmts'_1 \\
      \otstmts'_3 = \osFunc{$\alpha$}(\otstmts'_2)
    }{
      [\gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock['_3]{fun} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  % \begin{mathpar}
  %   \relationRule{Method Call}{
  %     \oheap[\ovalvariable_0] = \osLR{\gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1, \omem_0}\\
  %     \oheap[\ovalvariable_1] = [\omem_1, \ldots, \omem_n] \\
  %     \otstmts'_2 = [\gtlet \ovalvariable'_1 \gteq [\omem_0, \omem_1, \ldots, \omem_n], \gtlet \ovalvariable'_2 \gteq \ovalvariable_2, \ldots, \gtlet \ovalvariable'_n \gteq \ovalvariable_n] \listConcat \otstmts'_1 \\
  %     \otstmts'_3 = \osFunc{$\alpha$}(\otstmts'_2)
  %   }{
  %     [\gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtsemi] \listConcat \otstmts, \oheap \osTransition
  %     [\gtlet \omemvariable \gteq \gtobrc \osBlock['_3]{fun} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
  %   }
  % \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return}{
      \\
    }{
      [\gtlet \omemvariable \gteq \gtobrc [\gtreturn \omemvariable' \gtsemi] \listConcat \osBlock{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from While}{
      \\
    }{
      [\gtobrc [\gtreturn \omemvariable \gtsemi] \listConcat \osBlock{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from If (\ovalvariable)}{
      \\
    }{
      [\gtlet \ovalvariable \gteq \gtobrc [\gtreturn \omemvariable \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from If (\omemvariable)}{
      \\
    }{
      [\gtlet \omemvariable \gteq \gtobrc [\gtreturn \omemvariable' \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtreturn \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from Try}{
      \\
    }{
      [\gttry \gtobrc [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts_1 \gtcbrc \gtexcept \omemvariable' \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts, \oheap'
    }
  \end{mathpar}

  \subsubsection{If}

  \begin{mathpar}
    \relationRule{If Block (\ovalvariable)}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock['']{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If False (\ovalvariable)}{
      \oheap[\ovalvariable'] = \ovalue \\
      \ovalue = \osfalse
    }{
      [\gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock[_2]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If True (\ovalvariable)}{
      \oheap[\ovalvariable'] = \ovalue \\
      \ovalue = \ostrue
    }{
      [\gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock[_1]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\ovalvariable)}{
      \\
    }{
      [\gtlet \ovalvariable \gteq \gtobrc [\gtifresult \ovalvariable' \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \ovalvariable \gteq \ovalvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Block (\omemvariable)}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock['']{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If False (\omemvariable)}{
      \oheap[\omemvariable'] = \ovalue \\
      \ovalue = \osfalse
    }{
      [\gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock[_2]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If True (\omemvariable)}{
      \oheap[\omemvariable'] = \ovalue \\
      \ovalue = \ostrue
    }{
      [\gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock[_1]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\omemvariable)}{
      \\
    }{
      [\gtlet \omemvariable \gteq \gtobrc [\gtifresult \ovalvariable' \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \ovalvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \subsubsection{Exceptions}

  \begin{mathpar}
    \relationRule{Try Block}{
      \otstmts_1, \oheap \osTransition \otstmts'_1, \oheap'
    }{
      [\gttry \gtobrc \otstmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gttry \gtobrc \otstmts'_1 \gtcbrc \gtexcept \omemvariable \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Try Block Empty}{
      \\
    }{
      [\gttry \gtobrc [\;] \gtcbrc \gtexcept \omemvariable \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Caught}{
      \otstmts_1 = [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts'_1
    }{
      [\gttry \gtobrc \otstmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \omemvariable' \gtsemi] \listConcat \otstmts_2 \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Pop}{
      \otstmts = [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts''
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise in If (\ovalvariable)}{
      \otstmts = [\gtraise \omemvariable \gtsemi] \listConcat \otstmts''
    }{
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise in If (\omemvariable)}{
      \otstmts = [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts''
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise in While}{
      \otstmts = [\gtraise \omemvariable \gtsemi] \listConcat \otstmts''
    }{
      [\gtobrc \osBlock{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \subsubsection{Unops and Binops}

  \begin{mathpar}
    \relationRule{Not}{
      \ovalue = \oheap[\ovalvariable'] \\
      \ovalue' =
      \begin{cases}
        \ostrue, & \text{if } \ovalue = \osfalse \cr
        \osfalse, & \text{if } \ovalue = \ostrue
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \gtnot \ovalvariable' \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Is Function}{
      \ovalue = \oheap[\ovalvariable'] \\
      \ovalue' =
      \begin{cases}
        \ostrue, & \text{if } \ovalue \text{ is a function} \cr
        \osfalse, & \text{if } \ovalue \text{ is not a function}
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \gtisfunc \ovalvariable' \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Is Int}{
      \ovalue = \oheap[\ovalvariable'] \\
      \ovalue' =
      \begin{cases}
        \ostrue, & \text{if } \ovalue \in \mathbb{Z} \cr
        \osfalse, & \text{if } \ovalue \notin \mathbb{Z}
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \gtisint \ovalvariable' \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Is Bool}{
      \ovalue = \oheap[\ovalvariable'] \\
      \ovalue' =
      \begin{cases}
        \ostrue, & \text{if } \ovalue \in \mathbb{B} \cr
        \osfalse, & \text{if } \ovalue \notin \mathbb{B}
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \gtisbool \ovalvariable' \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Int+}{
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] \\
      \ovalue = \text{the sum of }\ovalue_1 \text{ and } \ovalue_2 \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtintplus \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Int-}{
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] \\
      \ovalue = \ovalue_2 \text{ subtracted from } \ovalue_1 \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtintminus \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  % \begin{mathpar}
  %   \relationRule{And}{
  %     \ovalue_1 = \oheap[\ovalvariable_1] \\
  %     \ovalue_2 = \oheap[\ovalvariable_2] \\
  %     \ovalue = \ovalue_1 \land \ovalue_2 \\
  %     \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
  %   }{
  %     [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtand \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
  %     \otstmts, \oheap'
  %   }
  % \end{mathpar}
  %
  % \begin{mathpar}
  %   \relationRule{Or}{
  %     \ovalue_1 = \oheap[\ovalvariable_1] \\
  %     \ovalue_2 = \oheap[\ovalvariable_2] \\
  %     \ovalue = \ovalue_1 \lor \ovalue_2 \\
  %     \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
  %   }{
  %     [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtor \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
  %     \otstmts, \oheap'
  %   }
  % \end{mathpar}

  \begin{mathpar}
    \relationRule{Haskey}{
      \obinding= \oheap[\ovalvariable_1] \\
      \ovalue = \oheap[\ovalvariable_2] \\
      \ovalue' =
      \begin{cases}
        \ostrue, & \text{if } \ovalue \mapsto \omem \in \obinding \cr
        \osfalse, & \text{otherwise}
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gthaskey \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{List Concatenation (within bound)}{
      \ovalue_1 = \oheap[\ovalvariable_1] = [\omem_1, \ldots, \omem_i]_k \\
      \ovalue_2 = \oheap[\ovalvariable_2] = [\omem_1', \ldots, \omem_j']_k\\
      i+j \leq k \\
      \ovalue = [\omem_1, \ldots, \omem_i, \omem_1', \ldots, \omem_j']_k \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtlstconcat \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{List Concatenation (out of bound)}{
      \ovalue_1 = \oheap[\ovalvariable_1] = [\omem_1, \ldots, \omem_i]_k \\
      \ovalue_2 = \oheap[\ovalvariable_2] = [\omem_1', \ldots, \omem_j']_k\\
      i+j > k \\
      \ovalue = \osBag{\omem_1, \ldots, \omem_i, \omem_1', \ldots, \omem_j'}  \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtlstconcat \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{List Concatenation (one is imprecise)}{
      \ovalue_1 = \osBag{\omem_1, \ldots, \omem_i}  \\
      \ovalue_2 = [\omem_1', \ldots, \omem_j']_k \text{ or vice versa }\\
      \ovalue = \osBag{\omem_1, \ldots, \omem_i, \omem_1', \ldots, \omem_j'}  \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtlstconcat \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{List Concatenation (imprecise)}{
      \ovalue_1 = \osBag{\omem_1, \ldots, \omem_i}  \\
      \ovalue_2 = \osBag{\omem_1', \ldots, \omem_j'} \\
      \ovalue = \osBag{\omem_1, \ldots, \omem_i, \omem_1', \ldots, \omem_j'}  \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtlstconcat \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Equal}{
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] \\
      \ovalue =
      \begin{cases}
        \ostrue, & \text{if } \ovalue_1 = \ovalue_2 \cr
        \osfalse, & \text{if } \ovalue_1 \neq \ovalue_2
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtcmp \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \subsection{Helper Functions}

  \begin{definition}[Value of]
    \begin{align*}
      \osFunc{Valueof}(\oexpr) =
    \end{align*}
  \end{definition}

  \begin{definition}[Alloc]
    \begin{align*}
      \osFunc{Alloc}() =
    \end{align*}
  \end{definition}

  \begin{definition}[Alpha Rename]
    \begin{align*}
      \osFunc{$\alpha$}(\ogenf) =
    \end{align*}
  \end{definition}

  \section{Graph-Based Semantics}

  \subsection{Graph Grammar}

  \begin{grammar}
    \grule[graph]{\ggraph}{\gsSet{\gedge, \ldots}}
    \grule[edges]{\gedge}{\gnode \gsBefore \gnode}
    \grule[nodes]{\gnode}{\gsLR{\gstate, \gtime}}
    \grule[states]{\gstate}{
                \gsstart
        \gor    \gsend
        \gor    \ostmt
        \gor    \gsadvance[\ostmt]
        \gor    \gsifresult[\ostmt]
        \gor    \gsreturn[\ostmt]
        \gline
        \gor    \gsraise[\ostmt]
    }
    \grule[general statements]{\gstmt}{
                \ostmt
        \gor    \osplat
    }
    \grule[time stack]{\gtime}{[n, \ldots]}
    \grule[memory addresses]{\omem, \opscope}{\gsLR{\ostmt, \gtime}}
  \end{grammar}

  \begin{definition}[Skippable statements]
    $\ostmt = \olbl \gtcolon \odirective$ is skippable if and only if
    \begin{flalign*}
      \odirective \in & \gsSet{\gtlet \ovalvariable \gteq \oexpr, \gtlet \omemvariable \gteq \gtalloc, \gtlet \ovalvariable \gteq \ovalvariable, \gtlet \omemvariable \gteq \omemvariable, \\
      & \gtlet \ovalvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtarrow \omemvariable \gtcbrc, \gtlet \omemvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtcbrc, \gtlet \omemvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcbrk, \\
      & \gtlet \ovalvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcolon \ovalvariable \gtcbrk, \gtstore \omemvariable \; \ovalvariable, \gtlet \ovalvariable \gteq \gtget \omemvariable, \gtlet \ovalvariable \gteq \omemvariable \gtis \omemvariable, \gtlet \ovalvariable \gteq \ounop \ovalvariable, \\
      & \gtlet \ovalvariable \gteq \ovalvariable \obinop \ovalvariable}
    \end{flalign*}
  \end{definition}

  \begin{notation} [Statement relations]
    \begin{flalign*}
      \ostmt \osBefore \ostmt' & \iff \text{\ostmt \! is lexically before \ostmt'} \\
      \ostmt \osUnder \ostmt' & \iff \text{\ostmt' \! is the lexical parent of \ostmt} \\
      \ostmt \osStartof \ostmt' & \iff \text{\ostmt \! is the first statement of the block where \ostmt' lives} \\
    \end{flalign*}
  \end{notation}

  \begin{notation} [Graph node relations]
    \begin{flalign*}
      \gnode \gsBeforeIn \gnode' & \iff \gnode \gsBefore \gnode' \in \ggraph \\
    \end{flalign*}
  \end{notation}

  \begin{notation} [Time stack operations]
    \begin{flalign*}
      ([n] \listConcat \gtime) \tplus & \iff [n+1] \listConcat \gtime &\osNote{time count +1}\\
      ([n] \listConcat \gtime) \tminus & \iff [n-1] \listConcat \gtime &\osNote{time count -1}\\
      ([0] \listConcat \gtime) \tminus & \iff \gtime &\osNote{time count 0, pop stack}\\
      \gtime \tpush & \iff [0] \listConcat \gtime &\osNote{push stack and reset count}\\
      ([p, q] \listConcat \gtime) \tpop & \iff [q+1] \listConcat \gtime &\osNote{pop stack and increment count by 1}\\
      ([n] \listConcat \gtime) \treset & \iff [0] \listConcat \gtime &\osNote{reset count}\\
    \end{flalign*}
  \end{notation}

  \subsection{Lookup Grammar}

  \begin{grammar}
    \grule[lookup stack]{\lstack}{[\lstackelt, \ldots]}
    \grule[lookup stack elements]{\lstackelt}{
                \ovalvariable
        \gor    \ovalue
        \gor    \omemvariable
        \gor    \omem
        \gor    \linstr
    }
    \grule[lookup results]{\lresult}{
                \ovalue
        \gor    \omem
    }
    \grule[lookup result set]{\lresults}{\gsSet{\lresult, \ldots}}
    \grule[lookup stack instructions]{\linstr}{
                \lInstr{Capture}_ n
        \gor    \lInstr{Jump} \; \gnode
        \gor    \lInstr{Bind}
        \gor    \lInstr{Project}
        \gor    \lInstr{Index}
        \gline
        \gor    \lInstr{Slice}
        \gor    \lInstr{Alias?}
        \gor    \lInstr{!}
        \gor    \lInstr{Unop}
        \gor    \lInstr{Binop}
        \gor    \lInstr{Answer}
        \gor    \lInstr{Is}
        \gline
        \gor    \lInstr{Drop}
    }
  \end{grammar}

  \subsection{Graph Rules}

  \begin{mathpar}
    \relationRule{Start}{
      \ostmts = [\ostmt, \ldots]
    }{
      \gsAddEdge{\gsLR{\gsstart, [0]} \gsBefore \gsLR{\ostmt, [1]}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Skip}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt \text{ is skippable}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt], \gtime \tplus}}
    }
  \end{mathpar}

  \subsubsection{While}

  \begin{mathpar}
    \relationRule{While-True Start}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc \\
      \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, [\omemvariable, \lInstr{!}]) \\
      \ostmts = [\ostmt', \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tpush}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{While-False}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc \gtsemi \\
      \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, [\omemvariable, \lInstr{!}])
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt], \gtime \tplus}}
    }
  \end{mathpar}

  \subsubsection{If}

  \begin{mathpar}
    \relationRule{If-True Start (\ovalvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
      \ostmts_1 = [\ostmt_1, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime \tpush}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If-False Start (\ovalvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
      \ostmts_2 = [\ostmt_2, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime \tpush}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\ovalvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtifresult \ovalvariable
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt], \gtime \tplus}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If-True Start (\omemvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
      \ostmts_1 = [\ostmt_1, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime \tpush}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If-False Start (\omemvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
      \ostmts_2 = [\ostmt_2, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime \tpush}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\omemvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtifresult \omemvariable \\
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt], \gtime \tplus}}
    }
  \end{mathpar}

  \subsubsection{Function}

  \begin{mathpar}
    \relationRule{Function Call}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \\
      \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \ostmts' \in \osFunc{Lookup}(\ggraph, \gnode_2, [\ovalvariable_0]) \\
      \ostmts' = [\ostmt', \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tpush}}
    }
  \end{mathpar}

  \tnote{We don't need param list here. This is done in lookup.}

  \begin{mathpar}
    \relationRule{Function Return}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtreturn \omemvariable
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsreturn[\ostmt], \gtime \tplus}}
    }
  \end{mathpar}

  \subsubsection{Exception}

  \begin{mathpar}
    \relationRule{Try}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
      \ostmts_1 = [\ostmt_1, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime \tpush}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Exception}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtraise \omemvariable
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt], \gtime \tplus}}
    }
  \end{mathpar}

  \subsubsection{Flow}

  \begin{mathpar}
    \relationRule{Advance}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \ostmt'
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tplus}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Advance End of While}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \osplat \\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is a while statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tpop}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Advance End of Try and Except}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \osplat \\
      % \ostmt \osUnder \ostmt' \\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is a try statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt'][\tpop \tminus], \gtime \tpop}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Advance EOF}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \osplat \\
      \ostmt \osUnder \osplat
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsend, \gtime \tplus}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Ifresult}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsifresult[\ostmt]['], \gtime}\\
      % \ostmt \osUnder \ostmt' \\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is an if statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt'][\tpop \tminus], \gtime \tpop}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Ifresult Through Blocks}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsifresult[\ostmt]['], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is a while or try statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt'][\tpop \tminus], \gtime \tpop}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Return}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsreturn[\ostmt]['], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is a funcdef} \\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset} \\
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt_0][_0], \gtime \tpop}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Return Through Blocks}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsreturn[\ostmt]['], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is not a funcdef} \\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset} \\
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsreturn[\ostmt_0][_0], \gtime \tplus}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise in Try Statment}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsraise[\ostmt]['], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
      \ostmt \in \ostmts_1 \\
      \ostmts_2 = [\ostmt_2, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime \tplus \tpop \tpush}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise From Exception Block}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsraise[\ostmt]['], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
      \ostmt \in \ostmts_2 \\
      \ostmt_1 \osStartof \ostmt \\
      % \gsLR{\ostmt', \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt'][_0 \tpop \tminus], \gtime \tpop}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Through Blocks}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsraise[\ostmt]['], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is an if statement, while statement or funcdef} \\
      \ostmt_1 \osStartof \ostmt \\
      % \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt'][_0 \tpop \tminus], \gtime \tpop}}
    }
  \end{mathpar}

  % \tnote{todo: add raise at top level}

  \subsection{Helper Functions}

  \begin{definition}[Lookup]
    Let \osFunc{Lookup}($\ggraph, \gnode_0, \lstack$) be the function returning the least set \lresults \;such that the following rules hold for $\gnode_1 \gsBefore \gnode_0$ :
    \begin{enumerate}%[label=(\alph*)]
      \item \textbf{Store}
      \begin{enumerate}[label=(\alph*)]
        \item \rulename{Singleton stack}
        If $\lstack = [\ovalue]$,
        then \formalRuleLine $\ovalue \in \lresults$.

        \item \rulename{Expression Assignment}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \oexpr, \gtime}$,
           $\lstack = [\ovalvariable] \listConcat \lstack'$, and
           $\ovalue = \osFunc{Valueof}(\oexpr)$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

        \item \rulename{List Assignment}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \gtobrk \omemvariable_1, \ldots, \omemvariable_n \gtcbrk, \gtime}$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_n, \lInstr{!}, \lInstr{Capture}_{3n-1}, \lInstr{Jump}\;\gnode_1, \ldots, \omemvariable_1, \lInstr{!}, \lInstr{Capture}_{2}, \lInstr{Jump}\;\gnode_1,  \lInstr{List}_n] \listConcat \lstack')$.

        \item \rulename{Memory Allocation}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtalloc, \gtime}$,
           $\lstack = [\omemvariable] \listConcat \lstack'$, and
           $\omem = \osFunc{Alloc}(\gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtalloc, \gtime})$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem] \listConcat \lstack')$.
      \end{enumerate}

      \item \textbf{Heap search}
      \begin{enumerate}[label=(\alph*)]
        \item \rulename{Value Alias}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable_1 \gteq \ovalvariable_2, \gtime}$, and
           $\lstack = [\ovalvariable_1] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_2] \listConcat \lstack')$.

        \item \rulename{Memory Alias}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable_1 \gteq \omemvariable_2, \gtime}$, and
           $\lstack = [\omemvariable_1] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_2] \listConcat \lstack')$.

        \item \rulename{Bind}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtarrow \omemvariable \gtcbrc, \gtime}$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_8, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_6, \lInstr{Jump}\;\gnode_1, \omemvariable, \lInstr{Capture}_4, $ \\
        $\lInstr{Jump}\;\gnode_1, \lInstr{Bind}] \listConcat \lstack')$.

        \item \rulename{Retrieve}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtcbrc, \gtime}$, and
           $\lstack = [\omemvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Project}] \listConcat \lstack')$.

        \item \rulename{List Indexing}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_1 \gtobrk \ovalvariable_2 \gtcbrk, \gtime}$, and
           $\lstack = [\omemvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Index}] \listConcat \lstack')$.

        \item \rulename{List Slicing}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable' \gtobrk \ovalvariable_1 \gtcolon \ovalvariable_2 \gtcbrk, \gtime}$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable', \lInstr{Capture}_8, \lInstr{Jump}\;\gnode_1, \ovalvariable_1, \lInstr{Capture}_6, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_4, $ \\
        $\lInstr{Jump}\;\gnode_1, \lInstr{Slice}] \listConcat \lstack')$.

        \item \rulename{Store}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$, and
           $\lstack = [\omem, \lInstr{!}] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable, \lInstr{Capture}_2, \lInstr{Jump} \; \gnode_0, \lInstr{Alias?}] \listConcat \lstack)$.

        \item \rulename{Get}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \gtget \omemvariable}$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable, \lInstr{Capture}_1, \lInstr{Jump} \; \gnode_0, \lInstr{!}] \listConcat \lstack')$.

        \item \rulename{Is}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \omemvariable_1 \gtis \omemvariable_2 , \gtime}$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \omemvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Is}] \listConcat \lstack')$.
      \end{enumerate}

      \item \textbf{Operations}
      \begin{enumerate}[label=(\alph*)]
        \item \rulename{Unary Operation}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ounop \ovalvariable' , \gtime}$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable', \lInstr{Capture}_2, \lInstr{Jump}\;\gnode_0, \lInstr{Unop}] \listConcat \lstack')$.

        \item \rulename{Binary Operation}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable_1 \obinop \ovalvariable_2 , \gtime}$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_0, \lInstr{Binop}] \listConcat \lstack')$.
      \end{enumerate}

      \item \textbf{Leave Block}
      \begin{enumerate}[label=(\alph*)]
        % \item \rulename{Skip While}
        % If $\gnode_1 = \gsLR{\ostmt, \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc$, and
        %    $\gnode_0 = \gsLR{\gsadvance [\ostmt] [_1], \gtime_0}$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime_1}, \lstack)$.

        \item \rulename{Leave If/While/Try}
        If $\gnode_1 = \gsLR{\ostmt, \gtime_1}$ where $\ostmt$ %= \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc$,
           is an if/while/try statement,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        % \item \rulename{If Block Top (unbound \ovalvariable)}
        % If $\gnode_1 = \gsLR{\ostmt, \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$,
        %    $\gsLR{\gstate, \gtime_1 \tminus} \osBefore \gnode_1$, and
        %    $\lstack = [\ovalvariable] \listConcat \lstack'$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \tnote{In the cases where we lookup memloc, just follow the cfg loop.}

        % \item \rulename{Ifresult \ovalvariable \;(bound)}
        % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
        %    $\gnode_0 = \gsLR{\gsadvance [\olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$, and
        %    $\lstack = [\ovalvariable] \listConcat \lstack'$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.
        %
        % \item \rulename{Ifresult \ovalvariable \;(unbound)}
        % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
        %    $\gnode_0 = \gsLR{\gsadvance [\olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$,
        %    $\lstack = [\ovalvariable''] \listConcat \lstack'$, and
        %    $\ovalvariable'' \neq \ovalvariable$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc, \gtime'}, \lstack)$.
        %
        % \item \rulename{Ifresult \omemvariable \;(bound)}
        % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
        %    $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$, and
        %    $\lstack = [\omemvariable] \listConcat \lstack'$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.
        %
        % \item \rulename{Ifresult \omemvariable \;(unbound)}
        % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
        %    $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$,
        %    $\lstack = [\omemvariable'] \listConcat \lstack'$, and
        %    $\omemvariable' \neq \omemvariable$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc, \gtime'}, \lstack)$.

        \item \rulename{Function Variable Search \;(argument)}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar, \gtime_1}$,
           $\gnode_0 = \gsLR{\ostmt, \gtime_0}$, \\
           $\ostmt \osUnder \olbl \gtcolon \gtlet \ovalvariable' \gteq \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1$, and
           $\lstack = [\ovalvariable'_i] \listConcat \lstack'$ where $1 \leq i \leq n$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_i] \listConcat \lstack')$.

        \item \rulename{Function Variable Search \;(heap lookup)}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar, \gtime_1}$,
           $\gnode_0 = \gsLR{\ostmt, \gtime_0}$, \\
           $\ostmt \osUnder \olbl \gtcolon \gtlet \ovalvariable' \gteq \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1$, and
           $\lstack = [\omem] \listConcat \lstack'$
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Function Variable Search \;(free variable)}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar, \gtime_1}$,
           $\gnode_0 = \gsLR{\ostmt, \gtime_0}$, \\
           $\ostmt \osUnder \olbl \gtcolon \gtlet \ovalvariable' \gteq \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1$,
           $\lstack \neq [\ovalvariable'_i] \listConcat \lstack'$ where $1 \leq i \leq n$ and $\lstack \neq [\omem] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable, \lInstr{Capture}_1, \lInstr{Drop}] \listConcat \lstack)$.
      \end{enumerate}

      \item \textbf{Enter Block}
      \begin{enumerate}[label=(\alph*)]

        \item \rulename{Enter If block \ovalvariable}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

        \item \rulename{Enter If block \omemvariable}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$, and
           $\lstack = [\omemvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

        \item \rulename{Enter function block}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar$, and
           $\lstack = [\omemvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

      \end{enumerate}

      \item \textbf{Stack Instructions}
      \begin{enumerate}[label=(\alph*)]
        \item \rulename{Capture Rule}
        If $\lstack = [\lresult, \lInstr{Capture}_n, \lstackelt_1, \ldots, \lstackelt_n] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lstackelt_1, \ldots, \lstackelt_n, \lresult] \listConcat \lstack')$.

        \item \rulename{Jump Rule}
        If $\lstack = [\lInstr{Jump} \;\gnode] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode, \lstack')$.

        \item \rulename{Drop Rule}
        If $\lstack = [\lInstr{Drop}, \lstackelt] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack')$.

        \item \rulename{Bind Rule}
        If $\lstack = [\lInstr{Bind}, \ovalue_1, \ovalue_2, \omem] \listConcat \lstack'$,
        and
           $\ovalue_1 = \obinding, \ovalue_2 \in \mathbb{S}, \obinding' = \obinding[\ovalue_2 \mapsto \omem]$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\obinding'] \listConcat \lstack')$.

        \item \rulename{Project Rule}
        If $\lstack = [\lInstr{Project}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
           $\ovalue_1 = \obinding, \ovalue_2 \in \mathbb{S}, \omem = \ovalue_1[\ovalue_2]$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem] \listConcat \lstack')$.

        \item \rulename{List Rule}
        If $\lstack = [\lInstr{List}_n, \omem_1, \ldots, \omem_n] \listConcat \lstack'$, and
           $\ovalue = [\omem_1, \ldots, \omem_n]_{n+1}$, 
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

        \item \rulename{Index Rule}
        If $\lstack = [\lInstr{Index}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
          $\ovalue_1 = [\omem_1, \ldots, \omem_n]_k,
          L = $ \\
          $
          \begin{cases}
            [\omem_i] \text{ or } [\;], \omem_i \in \ovalue_1, & \text{if } \ovalue_2 = \gtintplus \cr
            [\;], & \text{if } \ovalue_2 = \gtintminus \cr
            [\omem_1], & \text{if } \ovalue_2 = \gtintzero
          \end{cases},
          $
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, L \listConcat \lstack')$.

        \item \rulename{Index Rule (imprecise)}
        If $\lstack = [\lInstr{Index}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
           $\ovalue_1  = \osBag{\omem_1, \ldots, \omem_n},
           L = $ \\
           $
           \begin{cases}
             [\omem_i] \text{ or } [\;], \omem_i \in \ovalue_1, & \text{if } \ovalue_2 = \gtintplus \cr
             [\;], & \text{if } \ovalue_2 = \gtintminus \cr
             [\omem_i], \omem_i \in \ovalue_1, & \text{if } \ovalue_2 = \gtintzero
           \end{cases},
           $
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, L \listConcat \lstack')$.

        \item \rulename{Slice Rule (precise)}
        If $\lstack = [\lInstr{slice}, \ovalue, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
           $\ovalue = [\omem_1, \ldots, \omem_n]_k,
          %  p =
          %  \begin{cases}
          %    \ovalue_1, & \text{if } \ovalue_1 \in \mathbb{Z} \cr
          %    0, & \text{if } \ovalue_1 = \osnone
          %  \end{cases}, \\
          %  q =
          %  \begin{cases}
          %    \ovalue_2 - 1, & \text{if } \ovalue_2 \in \mathbb{Z} \cr
          %    n, & \text{if } \ovalue_2 = \osnone
          %  \end{cases},
          %  q \le p,
          %  \ovalue' = [\omem_p, \ldots, \omem_q]_k,
          %  k = q-p+1$,
          \ovalue' = \osFunc{PreciseSlice}(\ovalue,\ovalue_1,\ovalue_2)$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue'] \listConcat \lstack')$.

        \item \rulename{Slice Rule (imprecise)}
        If $\lstack = [\lInstr{slice}, \ovalue, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
           $\ovalue = \osBag{\omem_1, \ldots, \omem_n},
          %  \ovalue_1 \le \ovalue_2,
          %  \omem_i, \ldots, \omem_j \in \ovalue,
          %  \ovalue' = \osBag{\omem_i, \ldots, \omem_j}$,
          \ovalue' = \osFunc{ImpreciseSlice}(\ovalue,\ovalue_1,\ovalue_2)$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue'] \listConcat \lstack')$.

        % \item \rulename{List k}
        % If $\lstack = [\omem_p, \ldots, \omem_q, \lInstr{List}_k] \listConcat \lstack'$, and
        % $\ovalue = [\omem_p, \ldots, \omem_q]_k$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.
        %
        % \item \rulename{Bag}
        % If $\lstack = [\omem_i, \ldots, \omem_j, \lInstr{Bag}] \listConcat \lstack'$, and
        % $\ovalue = \osBag{\omem_i, \ldots, \omem_j}$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

        \item \rulename{Is Alias}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$, and
           $\lstack = [\lInstr{Alias?}, \omem, \omem, \lInstr{!}] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable] \listConcat \lstack')$.

        \item \rulename{Not Alias}
        If $\gnode_1 = \gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$,
           $\lstack = [\lInstr{Alias?}, \omem, \omem', \lInstr{!}] \listConcat \lstack'$, and
           $\omem \neq \omem'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem', \lInstr{!}] \listConcat \lstack')$.

        \item \rulename{Unop Rule \ovalue}
        If $\lstack = [\lInstr{Unop}, \ovalue] \listConcat \lstack'$,
           $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ounop \ovalvariable' , \gtime}$, and
           $\ovalue' = \osFunc{UnaryOperation}(\ounop, \ovalue)$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue'] \listConcat \lstack')$.

        \item \rulename{Binop Rule \ovalue}
        If $\lstack = [\lInstr{Binop}, \ovalue_1, \ovalue_2] \listConcat \lstack'$,
           $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable_1 \obinop \ovalvariable_2, \gtime}$, and
           $\ovalue = \osFunc{BinaryOperation}(\obinop, \ovalue_1, \ovalue_2)$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

        \item \rulename{Trace Answer}
        If $\lstack = [\lInstr{Answer}] \listConcat \lstack'$, and
           $\gnode_1 = \gsLR{\gsreturn[\ostmt], \gtime'} \;|\; \gsLR{\gsifresult[\ostmt], \gtime'} \;|\;$ \\ $\gsLR{\gsraise[\ostmt], \gtime'}$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Get Answer \ovalvariable}
        If $\lstack = [\lInstr{Answer}] \listConcat \lstack'$, and
           $\gnode_1 = \gsLR{\olbl \gtcolon \gtifresult \ovalvariable, \gtime}$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable] \listConcat \lstack')$.

        \item \rulename{Get Answer \omemvariable}
        If $\lstack = [\lInstr{Answer}] \listConcat \lstack'$, and
           $\gnode_1 = \gsLR{\olbl \gtcolon \gtreturn \omemvariable, \gtime} \;|\; \gsLR{\olbl \gtcolon \gtraise \omemvariable, \gtime} \;|\; $ \\
           $\gsLR{\olbl \gtcolon \gtifresult \omemvariable, \gtime}$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable] \listConcat \lstack')$.

        \item \rulename{Start Tracing Raise}
        If $\gnode_1 = \gsLR{\gsraise[\ostmt]['], \gtime_1}$,
           $\gnode_0 = \gsLR{\ostmt', \gtime_0}$, and
           $\lstack = [\omemvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

        \item \rulename{Start Tracing Raise (unbound)}
        If $\gnode_1 = \gsLR{\gsraise[\ostmt]['], \gtime_1}$,
           $\gnode_0 = \gsLR{\ostmt', \gtime_0}$, and
           $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \! is not of form \omemvariable,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Is Rule \omem}
        If $\lstack = [\lInstr{Is}, \omem_1, \omem_2] \listConcat \lstack'$, and
           \begin{flalign*}
             \ovalue =
             \begin{cases}
               \ostrue, & \text{if } \omem_1 = \omem_2 \\
               \osfalse, & \text{if } \omem_1 \neq \omem_2,
             \end{cases}
           \end{flalign*}
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.
      \end{enumerate}

      \item \textbf{Skip}
      \begin{enumerate}
        \item \rulename{Skip \ovalvariable \;assignments with \omemvariable}
        If $\gnode_1$ is an \ovalvariable \! assignment clause, and
           $\lstack = [\omemvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Skip \omemvariable \;assignments with \ovalvariable}
        If $\gnode_1$ is an \omemvariable \! assignment clause, and
           $\lstack = [\ovalvariable] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Skip \ovalvariable \;assignments with \ovalvariable'}
        If $\gnode_1$ is an \ovalvariable \! assignment clause, and
           $\lstack = [\ovalvariable'] \listConcat \lstack'$ where $\ovalvariable \neq \ovalvariable'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Skip \omemvariable \;assignments with \omemvariable'}
        If $\gnode_1$ is an \omemvariable \! assignment clause, and
           $\lstack = [\omemvariable'] \listConcat \lstack'$ where $\omemvariable \neq \omemvariable'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Dereference}
        If $\gnode_1$ is not of form $\gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$, and
           $\lstack = [\omem, \lInstr{!}] \listConcat \lstack'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Skip Advance}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt$ does not create a new block,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Skip Advance If \ovalvariable}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$,
        and
           $\lstack = [\ovalvariable'] \listConcat \lstack'$ where $\ovalvariable \neq \ovalvariable'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.

        \item \rulename{Skip Advance If \omemvariable}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$, and
           $\lstack = [\omemvariable'] \listConcat \lstack'$ where $\omemvariable \neq \omemvariable'$,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.

        \item \rulename{Skip while}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc$, and
           $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \;is not of form \omem,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Skip function}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar$,
           $\lstack = [\lstackelt] \listConcat \lstack'$ where $\lstackelt \neq \omemvariable$, and
           \lstackelt \;is not of form \omem,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        \item \rulename{Skip advance from while}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$,
           $\gnode_0 = \gsLR{\olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc, \gtime_1}$, and
           $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \;is not of form \omem,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

        % \tnote{Add a lot more, and delete the Ifresult, etc. rules}

        \item \rulename{Skip Try/except}
        If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc$, and
           $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \;is not of form \omem,
        then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.
        %
        % \item \rulename{Enter Try/except with \omemvariable}
        % If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc$, and
        %    $\lstack = [\omemvariable] \listConcat \lstack'$,
        % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.
      \end{enumerate}
    \end{enumerate}
  \end{definition}

  \begin{definition}[Unary Operation]
    $\osFunc{UnaryOperation}(\ounop, \ovalue) = V$ for each of the following rows:
    \begin{flalign*}
    \begin{array}[t]{ c c | c }
     \ounop & \ovalue & V \\
     \hline
     % not
     \gtnot & \ostrue & \osfalse \\
     \gtnot & \osfalse & \ostrue \\
     % isfunc
     \gtisfunc & \text{function} & \ostrue \\
     \gtisfunc & \text{not function} & \osfalse \\
     % isint
     \gtisint & \in \mathbb{Z} & \ostrue \\
     \gtisint & \notin \mathbb{Z} & \osfalse \\
     % isbool
     \gtisbool & \in \mathbb{B} & \ostrue \\
     \gtisbool & \notin \mathbb{B} & \osfalse \\
    \end{array}
    \end{flalign*}
  \end{definition}

  \begin{definition}[Binary Operation]
    $\osFunc{BinaryOperation}(\obinop, \ovalue_1, \ovalue_2) = V$ for each of the following rows:
    \begin{flalign*}
    \begin{array}[t]{ c c c | l }
     \obinop & \ovalue_1 & \ovalue_2 & V \\
     \hline
     \gtintplus & \in \mathbb{Z} & \in \mathbb{Z} & \ovalue_1 + \ovalue_2 \\
     \gtintminus & \in \mathbb{Z} & \in \mathbb{Z} & \ovalue_1 - \ovalue_2 \\
     \gthaskey & \gsSet{\ovalue_2 \mapsto \ovalue, \ldots} & \in \mathbb{S} & \ostrue \\
     \gthaskey & \obinding \niton \ovalue_2 \mapsto \ovalue & \in \mathbb{S} & \osfalse \\
     \gtlstconcat & [\omem_m, \ldots, \omem_n] & [\omem_p, \ldots, \omem_q] & [\omem_m, \ldots, \omem_n, \omem_p, \ldots, \omem_q] \\
     \gtcmp & \ovalue & \ovalue & \ostrue \\
     \gtcmp & \ovalue & \ovalue' \neq \ovalue & \osfalse \\
    \end{array}
    \end{flalign*}
  \end{definition}

  \begin{definition}[Precise Slice]
    $\osFunc{PreciseSlice}(\ovalue, \ovalue_1, \ovalue_2)$ returns the content of row $\ovalue_1$, column $\ovalue_2$ for $\ovalue=[\omem_1,\ldots,\omem_n]_k$:
    \begin{flalign*}
    \begin{array}[t]{ c | c c c c }
     & \gtintplus & \gtintminus & \gtintzero & \osnone \\
     \hline
     \gtintplus & [\omem_i,\ldots,\omem_j]_k, 1 \le i \le j \le n & \text{---} & \text{---} & [\omem_i,\ldots,\omem_n]_k, 1 \le i \le n\\
     \gtintminus & \text{---} & \text{---} & \text{---} & \text{---} \\
     \gtintzero & [\omem_1,\ldots,\omem_i]_k, 1 \le i \le n & \text{---} & [\omem_1]_k & \ovalue \\
     \osnone & [\omem_1,\ldots,\omem_i]_k, 1 \le i \le n & \text{---} & [\omem_1]_k & \ovalue \\
    \end{array}
    \end{flalign*}
  \end{definition}

  \begin{definition}[Imprecise Slice]
    $\osFunc{ImpreciseSlice}(\ovalue, \ovalue_1, \ovalue_2)$ returns the content of row $\ovalue_1$, column $\ovalue_2$:
    \begin{flalign*}
    \begin{array}[t]{ c | c c c c }
     & \gtintplus & \gtintminus & \gtintzero & \osnone \\
     \hline
     \gtintplus & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue & \text{---} & \text{---} & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue \\
     \gtintminus & \text{---} & \text{---} & \text{---} & \text{---} \\
     \gtintzero & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue & \text{---} & \osBag{\omem_1} & \ovalue \\
     \osnone & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue & \text{---} & \osBag{\omem_1} & \ovalue \\
    \end{array}
    \end{flalign*}
  \end{definition}
  \tnote{In real life, we simply take the entire list. Slice does not exist. "None" is not supported now. }
\end{document}
