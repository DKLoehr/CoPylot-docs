\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}

\begin{document}
  \section{Operational Semantics}

  \subsection{Lamia Language Grammar}

  \begin{grammar}
    \grule[labels]{\olbl}{}
    \grule[value variables]{\ovalvariable}{}
    \grule[memory variables]{\omemvariable}{}
    \grule[blocks]{\ostmts}{
                \ostmt \gtsemi \ldots
    }
    \grule[statements]{\ostmt}{
                \olbl \gtcolon \odirective
    }
    \grule[blocks]{\otstmts}{
                \otstmt \gtsemi \ldots
    }
    \grule[statements]{\otstmt}{
                \odirective \text{ such that all \ostmts \, are replaced with \otstmts}
        \gor    \gtobrc \osBlock{while} \gtcbrc
        % \gor    \gtobrc \osBlock{try} \gtcbrc
        \gline
        \gor    \gtobrc \osBlock{if} \gtcbrc
        \gor    \gtlet \omemvariable \gteq \gtobrc \osBlock{fun} \gtcbrc
    }
    \grule[directive]{\odirective}{
                \gtlet \ovalvariable \gteq \oexpr \gline
        \gor    \gtlet \omemvariable \gteq \gtalloc \gline
        % \gor    \gtlet \ovalvariable \gteq \gtmethodbind \omemvariable \; \ovalvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ovalvariable \gline
        \gor    \gtlet \omemvariable \gteq \omemvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtarrow \omemvariable \gtcbrc \gline
        \gor    \gtlet \omemvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtcbrc \gline
        \gor    \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable \gtcomma \ldots \gtcpar \gline
        \gor    \gtlet \omemvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcbrk \gline
        \gor    \gtstore \omemvariable\ \ovalvariable \gline
        \gor    \gtlet \ovalvariable \gteq \gtget \omemvariable \gline
        \gor    \gtlet \ovalvariable \gteq \omemvariable \gtis \omemvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ounop \ovalvariable \gline
        \gor    \gtlet \ovalvariable \gteq \ovalvariable \obinop \ovalvariable \gline
        \gor    \gtifresult \ovalvariable \gline
        \gor    \gtifresult \omemvariable \gline
        \gor    \gtreturn \omemvariable \gline
        \gor    \gtraise \omemvariable \gline
        \gor    \gttry \gtobrc \ostmts \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts \gtcbrc \gline
        \gor    \gtlet \ovalvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts \gtcbrc \gtelse \gtobrc \ostmts \gtcbrc \gline
        \gor    \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts \gtcbrc \gtelse \gtobrc \ostmts \gtcbrc \gline
        \gor    \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc
    }
    \grule[unary operators]{\ounop}{
                \gtnot
        \gor    \gtisfunc
    }
    \grule[binary operators]{\obinop}{
                \gtintplus
        \gor    \gtintminus
        % \gor    \gtand
        % \gor    \gtor
        \gor    \gthaskey
        \gor    \gtlstconcat
    }
    \grule[value expressions]{\oexpr}{
                \mathbb{Z}
        \gor    \mathbb{S}
        \gor    \mathbb{B}
        \gor    \gtdef \gtopar \ovalvariable, \ldots \gtcpar \gtobrc \ostmts \gtcbrc
        \gor    \gtobrk \omemvariable, \ldots \gtcbrk
        % \gor    \gtopar \omemvariable, \ldots \gtcpar
        \gor    \gtobrc \gtcbrc
        \gor    \osnone
    }
    \grule[strings]{\mathbb{S}}{}
    \grule[booleans]{\mathbb{B}}{
                \ostrue
        \gor    \osfalse
    }
    \grule[heap]{\oheap}{
                \gtobrc \ovalvariable \mapsto \ovalue, \ldots \gtcbrc
        \cup    \gtobrc \omemvariable \mapsto \omem, \ldots \gtcbrc
        \cup    \gtobrc \omem \mapsto \ovalue, \ldots \gtcbrc
    }
  \end{grammar}

  \subsection{Lamia Evaluation Grammar}

  \begin{grammar}
    \grule[memory addresses]{\omem,\opscope}{\osFunc{Alloc}(\gsLR{\gnode, \gtime})}
    \grule[values]{\ovalue}{
                \mathbb{Z}
        \gor    \mathbb{S}
        \gor    \mathbb{B}
        \gor    [\omem, \ldots] % [m, ...]
        % \gor    (\omem, \ldots) % (m, ...)
        \gor    \obinding % B
        \gor    \ogenf
        % \gor    \ogenm
        \gor    \osnone
    }
    \grule[binding records]{\obinding}{
                \{ \mathbb{S} \mapsto \omem, \ldots \}
    }
    \grule[functions]{\ogenf}{
                \gtfun \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtarrow \otstmts
    }
    % \grule[methods]{\ogenm}{
    %             \osLR{\gtfun \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtarrow \otstmts, \omem_0}
    % }

  \end{grammar}

  \subsection{Lamia Language Rules}

  \begin{mathpar}
    \relationRule{Value Assignment}{
      \ovalue = \osFunc{Valueof}(\oexpr) \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \oexpr \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Memory Alloc}{
      \omem = \osFunc{Alloc}() \\
      \oheap' = \oheap[\omemvariable \mapsto \omem]
    }{
      [\gtlet \omemvariable \gteq \gtalloc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  % \begin{mathpar}
  %   \relationRule{Method Assignment}{
  %     \omem = \oheap[\omemvariable] \\
  %     \ovalue = \oheap[\ovalvariable'] = \ogenf \\
  %     \ovalue' = \osLR{\ovalue, \omem} \\
  %     \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
  %   }{
  %     [\gtlet \ovalvariable \gteq \gtmethodbind \omemvariable \; \ovalvariable'] \listConcat \otstmts, \oheap \osTransition
  %     \otstmts, \oheap'
  %   }
  % \end{mathpar}

  \begin{mathpar}
    \relationRule{Value Alias}{
      \oheap' = \oheap[\ovalvariable_2 \mapsto \oheap[\ovalvariable_1]]
    }{
      [\gtlet \ovalvariable_1 \gteq \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Memory Alias}{
      \oheap' = \oheap[\omemvariable_2 \mapsto \oheap[\omemvariable_1]]
    }{
      [\gtlet \omemvariable_1 \gteq \omemvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Bind}{
      \obinding = \oheap[\ovalvariable_1] \\
      \ovalue = \oheap[\ovalvariable_2] \\
      \omem = \oheap[\omemvariable] \\\\
      \obinding' = \obinding[\ovalue \gtarrow \omem] \\
      \oheap' = \oheap[\ovalvariable_1 \mapsto \obinding']
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtarrow \omemvariable \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Retrieve}{
      \obinding = \oheap[\ovalvariable_1] \\
      \omem = \obinding[\ovalvariable_2] \\
      \oheap' = \oheap[\omemvariable \mapsto \omem]
    }{
      [\gtlet \omemvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Index}{
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] = i \in \mathbb{Z^+} \\
      \omem = \text{the memloc stored in the $i^{th}$ position of $\ovalue_1$} \\
      \oheap' = \oheap[\omemvariable \mapsto \omem]
    }{
      [\gtlet \omemvariable \gteq \ovalvariable_1 \gtobrk \ovalvariable_2 \gtcbrk \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Store}{
      \omem = \oheap[\omemvariable] \\
      \ovalue = \oheap[\ovalvariable] \\
      \oheap' = \oheap[\omem \mapsto \ovalue]
    }{
      [\gtstore \omemvariable\ \ovalvariable \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Get}{
      \omem = \oheap[\omemvariable] \\
      \ovalue = \oheap[\omem] \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \gtget \omemvariable \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}


  \begin{mathpar}
    \relationRule{Is}{
      \omem_1 = \oheap[\omemvariable_1] \\
      \omem_2 = \oheap[\omemvariable_2] \\
      \ovalue =
      \begin{cases}
        \ostrue, & \text{if } \omem_1 = \omem_2 \cr
        \osfalse, & \text{if } \omem_1 \neq \omem_2
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \omemvariable_1 \gtis \omemvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \subsubsection{While}

  \begin{mathpar}
    \relationRule{While Block}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtobrc \osBlock{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtobrc \osBlock['']{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{While False}{
      \oheap[\omemvariable] = \omem \\
      \oheap[\omem] = \osfalse
    }{
      [\gtwhile \omemvariable \gtdo \gtobrc \otstmts \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{While True}{
      \oheap[\omemvariable] = \omem \\
      \oheap[\omem] = \ostrue
    }{
      [\gtwhile \omemvariable \gtdo \gtobrc \otstmts \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtobrc \osBlock{while} \gtcbrc \gtsemi, \gtwhile \omemvariable \gtdo \gtobrc \otstmts \gtcbrc \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \subsubsection{Function and Method}

  \begin{mathpar}
    \relationRule{Function Block}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock['']{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Call}{
      \oheap[\ovalvariable_0] = \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1 \\
      \otstmts'_2 = [\gtlet \ovalvariable'_1 \gteq \ovalvariable_1, \ldots, \gtlet \ovalvariable'_n \gteq \ovalvariable_n] \listConcat \otstmts'_1 \\
      \otstmts'_3 = \osFunc{$\alpha$}(\otstmts'_2)
    }{
      [\gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock['_3]{fun} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  % \begin{mathpar}
  %   \relationRule{Method Call}{
  %     \oheap[\ovalvariable_0] = \osLR{\gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1, \omem_0}\\
  %     \oheap[\ovalvariable_1] = [\omem_1, \ldots, \omem_n] \\
  %     \otstmts'_2 = [\gtlet \ovalvariable'_1 \gteq [\omem_0, \omem_1, \ldots, \omem_n], \gtlet \ovalvariable'_2 \gteq \ovalvariable_2, \ldots, \gtlet \ovalvariable'_n \gteq \ovalvariable_n] \listConcat \otstmts'_1 \\
  %     \otstmts'_3 = \osFunc{$\alpha$}(\otstmts'_2)
  %   }{
  %     [\gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \gtsemi] \listConcat \otstmts, \oheap \osTransition
  %     [\gtlet \omemvariable \gteq \gtobrc \osBlock['_3]{fun} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
  %   }
  % \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return}{
      \\
    }{
      [\gtlet \omemvariable \gteq \gtobrc [\gtreturn \omemvariable' \gtsemi] \listConcat \osBlock{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from While}{
      \\
    }{
      [\gtobrc [\gtreturn \omemvariable \gtsemi] \listConcat \osBlock{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from If (\ovalvariable)}{
      \\
    }{
      [\gtlet \ovalvariable \gteq \gtobrc [\gtreturn \omemvariable \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from If (\omemvariable)}{
      \\
    }{
      [\gtlet \omemvariable \gteq \gtobrc [\gtreturn \omemvariable' \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtreturn \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return from Try}{
      \\
    }{
      [\gttry \gtobrc [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts_1 \gtcbrc \gtexcept \omemvariable' \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtreturn \omemvariable \gtsemi] \listConcat \otstmts, \oheap'
    }
  \end{mathpar}

  \subsubsection{If}

  \begin{mathpar}
    \relationRule{If Block (\ovalvariable)}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock['']{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If False (\ovalvariable)}{
      \oheap[\ovalvariable'] = \ovalue \\
      \ovalue = \osfalse
    }{
      [\gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock[_2]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If True (\ovalvariable)}{
      \oheap[\ovalvariable'] = \ovalue \\
      \ovalue = \ostrue
    }{
      [\gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock[_1]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\ovalvariable)}{
      \\
    }{
      [\gtlet \ovalvariable \gteq \gtobrc [\gtifresult \ovalvariable' \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \ovalvariable \gteq \ovalvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Block (\omemvariable)}{
      \otstmts, \oheap \osTransition \otstmts'', \oheap'
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock['']{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If False (\omemvariable)}{
      \oheap[\omemvariable'] = \ovalue \\
      \ovalue = \osfalse
    }{
      [\gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock[_2]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If True (\omemvariable)}{
      \oheap[\omemvariable'] = \ovalue \\
      \ovalue = \ostrue
    }{
      [\gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \otstmts_1 \gtcbrc \gtelse \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \gtobrc \osBlock[_1]{if} \gtcbrc \gtsemi] \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\omemvariable)}{
      \\
    }{
      [\gtlet \omemvariable \gteq \gtobrc [\gtifresult \ovalvariable' \gtsemi] \listConcat \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtlet \omemvariable \gteq \ovalvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \subsubsection{Exceptions}

  \begin{mathpar}
    \relationRule{Try Block}{
      \otstmts_1, \oheap \osTransition \otstmts'_1, \oheap'
    }{
      [\gttry \gtobrc \otstmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gttry \gtobrc \otstmts_1' \gtcbrc \gtexcept \omemvariable \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Caught}{
      \otstmts_1 = [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts'_1
    }{
      [\gttry \gtobrc \otstmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \otstmts_2 \gtcbrc \gtsemi] \listConcat \otstmts, \oheap \osTransition
      [\gtlet \omemvariable \gteq \omemvariable' \gtsemi] \listConcat \otstmts_2 \listConcat \otstmts, \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Pop}{
      \otstmts = [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts''
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{fun} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise in If (\ovalvariable)}{
      \otstmts = [\gtraise \omemvariable \gtsemi] \listConcat \otstmts''
    }{
      [\gtlet \ovalvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise in If (\omemvariable)}{
      \otstmts = [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts''
    }{
      [\gtlet \omemvariable \gteq \gtobrc \osBlock{if} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable' \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise in While}{
      \otstmts = [\gtraise \omemvariable \gtsemi] \listConcat \otstmts''
    }{
      [\gtobrc \osBlock{while} \gtcbrc \gtsemi] \listConcat \otstmts', \oheap \osTransition
      [\gtraise \omemvariable \gtsemi] \listConcat \otstmts', \oheap
    }
  \end{mathpar}

  \subsubsection{Unops and Binops}

  \begin{mathpar}
    \relationRule{Not}{
      \ovalue = \oheap[\ovalvariable'] \\
      \ovalue' =
      \begin{cases}
        \ostrue, & \text{if } \ovalue = \osfalse \cr
        \osfalse, & \text{if } \ovalue = \ostrue
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \gtnot \ovalvariable' \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Int+}{
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] \\
      \ovalue = \text{the sum of }\ovalue_1 \text{ and } \ovalue_2 \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtintplus \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Int-}{
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] \\
      \ovalue = \ovalue_2 \text{ subtracted from } \ovalue_1 \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtintminus \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  % \begin{mathpar}
  %   \relationRule{And}{
  %     \ovalue_1 = \oheap[\ovalvariable_1] \\
  %     \ovalue_2 = \oheap[\ovalvariable_2] \\
  %     \ovalue = \ovalue_1 \land \ovalue_2 \\
  %     \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
  %   }{
  %     [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtand \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
  %     \otstmts, \oheap'
  %   }
  % \end{mathpar}
  %
  % \begin{mathpar}
  %   \relationRule{Or}{
  %     \ovalue_1 = \oheap[\ovalvariable_1] \\
  %     \ovalue_2 = \oheap[\ovalvariable_2] \\
  %     \ovalue = \ovalue_1 \lor \ovalue_2 \\
  %     \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
  %   }{
  %     [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtor \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
  %     \otstmts, \oheap'
  %   }
  % \end{mathpar}

  \begin{mathpar}
    \relationRule{Haskey}{
      \obinding= \oheap[\ovalvariable_1] \\
      \ovalue = \oheap[\ovalvariable_2] \\
      \ovalue' =
      \begin{cases}
        \ostrue, & \text{if } \ovalue \mapsto \omem \in \obinding \cr
        \osfalse, & \text{otherwise}
      \end{cases} \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue']
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gthaskey \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{List Concatenation}{
      \ovalue_1 = \oheap[\ovalvariable_1] \\
      \ovalue_2 = \oheap[\ovalvariable_2] \\
      \ovalue = \ovalue_1 \listConcat \ovalue_2 \\
      \oheap' = \oheap[\ovalvariable \mapsto \ovalue]
    }{
      [\gtlet \ovalvariable \gteq \ovalvariable_1 \gtlstconcat \ovalvariable_2 \gtsemi] \listConcat \otstmts, \oheap \osTransition
      \otstmts, \oheap'
    }
  \end{mathpar}

  \subsection{Helper Functions}

  \begin{definition}[Value of]
    \begin{align*}
      \osFunc{Valueof}(\oexpr) =
    \end{align*}
  \end{definition}

  \begin{definition}[Alloc]
    \begin{align*}
      \osFunc{Alloc}() =
    \end{align*}
  \end{definition}

  \begin{definition}[Alpha Rename]
    \begin{align*}
      \osFunc{$\alpha$}(\ogenf) =
    \end{align*}
  \end{definition}

  \section{Graph-Based Semantics}

  \subsection{Graph Grammar}

  \begin{grammar}
    \grule[graph]{\ggraph}{\gsSet{\gedge, \ldots}}
    \grule[edges]{\gedge}{\gnode \gsBefore \gnode}
    \grule[nodes]{\gnode}{\gsLR{\gstate, \gtime}}
    \grule[states]{\gstate}{
                \gsstart
        \gor    \gsend
        \gor    \ostmt
        \gor    \gsadvance[\ostmt]
        \gor    \gsifresult[\ostmt]
        \gor    \gsreturn[\ostmt]
        \gor    \gsraise[\ostmt]
    }
    \grule[general statements]{\gstmt}{
                \ostmt
        \gor    \osplat
    }
    \grule[memory addresses]{\omem, \opscope}{\gsLR{\ostmt, \gtime}}
  \end{grammar}

  \begin{definition}[Skippable statements]
    $\ostmt = \olbl \gtcolon \odirective$ is skippable if and only if
    \begin{flalign*}
      \odirective \in & \gsSet{\gtlet \ovalvariable \gteq \oexpr, \gtlet \omemvariable \gteq \gtalloc, \gtlet \ovalvariable \gteq \gtmethodbind \omemvariable \; \ovalvariable, \gtlet \ovalvariable \gteq \ovalvariable, \gtlet \omemvariable \gteq \omemvariable, \\
      & \gtlet \ovalvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtarrow \omemvariable \gtcbrc, \gtlet \omemvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtcbrc, \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable \gtcomma \ldots \gtcpar, \gtlet \omemvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcbrk, \\
      & \gtstore \omemvariable\ \ovalvariable, \gtlet \ovalvariable \gteq \gtget \omemvariable, \gtlet \ovalvariable \gteq \omemvariable \gtis \omemvariable, \gtlet \ovalvariable \gteq \ounop \ovalvariable, \gtlet \ovalvariable \gteq \ovalvariable \obinop \ovalvariable}
    \end{flalign*}
  \end{definition}

  \begin{notation} [Statement relations]
    \begin{flalign*}
      \ostmt \osBefore \ostmt' & \iff \tnote{todo} \\
      \ostmt \osUnder \ostmt' & \iff \tnote{todo} \\
      \ostmt \osStartof \ostmt' & \iff \tnote{todo} \\
    \end{flalign*}
  \end{notation}

  \begin{notation} [Graph node relations]
    \begin{flalign*}
      \gnode \gsBeforeIn \gnode' & \iff \gnode \gsBefore \gnode' \in \ggraph \\
    \end{flalign*}
  \end{notation}

  \subsection{Lookup Grammar}

  \begin{grammar}
    \grule[lookup stack]{\lstack}{[\lstackelt, \ldots]}
    \grule[lookup stack elements]{\lstackelt}{
                \ovalvariable
        \gor    \ovalue
        \gor    \omemvariable
        \gor    \omem
        \gor    \linstr
    }
    \grule[lookup results]{\lresult}{
                \ovalue
        \gor    \omem
    }
    \grule[lookup result set]{\lresults}{\gsSet{\lresult, \ldots}}
    \grule[lookup stack instructions]{\linstr}{
                \lInstr{Capture} \; n
        \gor    \lInstr{Jump} \; \gnode
        \gor    \lInstr{Project}
    }
  \end{grammar}

  \subsection{Graph Rules}

  \begin{mathpar}
    \relationRule{Start}{
      \ostmts = [\ostmt, \ldots]
    }{
      \gsAddEdge{\gsLR{\gsstart, 0} \gsBefore \gsLR{\ostmt, 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Skip}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt \text{ is skippable}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt], \gtime + 1}}
    }
  \end{mathpar}

  \subsubsection{While}

  \begin{mathpar}
    \relationRule{While-True Start}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc \\
      \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, \omemvariable) \\
      \ostmts = [\ostmt', \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{While-False}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc \gtsemi \\
      \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, \omemvariable)
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt], \gtime + 1}}
    }
  \end{mathpar}

  \subsubsection{If}

  \begin{mathpar}
    \relationRule{If-True Start (\ovalvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, \ovalvariable') \\
      \ostmts_1 = [\ostmt_1, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If-False Start (\ovalvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, \ovalvariable') \\
      \ostmts_2 = [\ostmt_2, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\ovalvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtifresult \ovalvariable
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If-True Start (\omemvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, \ovalvariable') \\
      \ostmts_1 = [\ostmt_1, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If-False Start (\omemvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
      \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, \ovalvariable') \\
      \ostmts_2 = [\ostmt_2, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{If Result (\omemvariable)}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtifresult \omemvariable \\
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt], \gtime + 1}}
    }
  \end{mathpar}

  \subsubsection{Function and Method}

  \begin{mathpar}
    \relationRule{Function Call}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \\
      \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \ostmts' \in \osFunc{Lookup}(\ggraph, \gnode_2, \lstack) \\
      \ostmts' = [\ostmt', \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime + 1}}
    }
  \end{mathpar}

  \tnote{We don't need param list here. This is done in lookup.}

  % \begin{mathpar}
  %   \relationRule{Method Call}{
  %     \gnode_1 \gsBeforeIn \gnode_2 \\
  %     \gnode_2 = \gsLR{\ostmt, \gtime}\\
  %     \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \\
  %     \osLR{\gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \ostmts', \omem_0} \in \osFunc{Lookup}(\ggraph, \gnode_2, \lstack) \\
  %     \ostmts' = [\ostmt', \ldots]
  %   }{
  %     \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime + 1}}
  %   }
  % \end{mathpar}

  \begin{mathpar}
    \relationRule{Function Return}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtreturn \omemvariable
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsreturn[\ostmt], \gtime + 1}}
    }
  \end{mathpar}

  \subsubsection{Exceptions}

  \begin{mathpar}
    \relationRule{Try}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
      \ostmt = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
      \ostmts_1 = [\ostmt_1, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Exception}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\ostmt, \gtime}\\
      \ostmt = \olbl \gtcolon \gtraise \omemvariable
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt], \gtime + 1}}
    }
  \end{mathpar}

  \subsubsection{Flow}

  \begin{mathpar}
    \relationRule{Advance}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \ostmt'
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Advance End of While}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \osplat \\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is a while statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Advance End of Try}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \osplat \\
      % \ostmt \osUnder \ostmt' \\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1,\gtime_1} \\
      \ostmt_0 \text{ is a try statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt_0][_0], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Advance End of Exception}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \osplat \\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1,\gtime_1} \\
      \ostmt_0 \text{ is a try statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt_0][_0], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Advance EOF}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
      \ostmt \osBefore \osplat \\
      \ostmt \osUnder \osplat
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsend, \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Ifresult}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsifresult[\ostmt]['], \gtime}\\
      % \ostmt \osUnder \ostmt' \\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1,\gtime_1} \\
      \ostmt_0 \text{ is an if statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt_0][_0], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Ifresult Through Blocks}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsifresult[\ostmt]['], \gtime}\\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1,\gtime_1} \\
      \ostmt_0 \text{ is a while or try statement}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt_0][_0], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Return}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsreturn[\ostmt][_s], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is a funcdef} \\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1,\gtime_1} \\
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt_0][_0], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Return Through Blocks}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsreturn[\ostmt][_s], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is not a funcdef} \\
      \ostmt_1 \osStartof \ostmt \\
      \gsLR{\ostmt', \gtime'} \gsBeforeIn \gsLR{\ostmt_1,\gtime_1} \\
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsreturn[\ostmt']['], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsraise[\ostmt]['], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
      \ostmts_2 = [\ostmt_2, \ldots]
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Pop}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsraise[\ostmt][_s], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is a funcdef} \\
      \ostmt_1 \osStartof \ostmt' \\
      \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1.\gtime_1}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt_0][_0], \gtime + 1}}
    }
  \end{mathpar}

  \begin{mathpar}
    \relationRule{Raise Through Blocks}{
      \gnode_1 \gsBeforeIn \gnode_2 \\
      \gnode_2 = \gsLR{\gsraise[\ostmt][_s], \gtime}\\
      \ostmt \osUnder \ostmt' \\
      \ostmt' \text{ is an if or while statement} \\
      \ostmt_1 \osStartof \ostmt' \\
      \gsLR{\ostmt', \gtime'} \gsBeforeIn \gsLR{\ostmt_1.\gtime_1}
    }{
      \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt']['], \gtime + 1}}
    }
  \end{mathpar}

  \subsection{Helper Functions}

  \begin{definition}[Lookup]
    Let \osFunc{Lookup}($\ggraph, \gnode_0, \lstack$) be the function returning the least set \lresults \;such that the following rules hold for $\gnode_1 \gsBefore \gnode_0$ :
    \begin{enumerate}[label=(\alph*)]
      \item \rulename{Singleton stack}
      If $\lstack = [\ovalue]$,
      then \formalRuleLine $\ovalue \in \lresults$.

      \item \rulename{Expression Assignment}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \oexpr, \gtime}$,
         $\lstack = [\ovalvariable] \listConcat \lstack'$, and
         $\ovalue = \osFunc{Valueof}(\oexpr)$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

      \item \rulename{Memory Allocation}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtalloc, \gtime}$,
         $\lstack = [\omemvariable] \listConcat \lstack'$, and
         $\omem = \osFunc{Alloc}(\gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtalloc, \gtime})$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem] \listConcat \lstack')$.

      \item \rulename{Value Alias}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable_1 \gteq \ovalvariable_2, \gtime}$, and
         $\lstack = [\ovalvariable_1] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_2] \listConcat \lstack')$.

      \item \rulename{Memory Alias}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable_1 \gteq \omemvariable_2, \gtime}$, and
         $\lstack = [\omemvariable_1] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_2] \listConcat \lstack')$.

      \item \rulename{Bind}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtarrow \omemvariable \gtcbrc, \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_7, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \omemvariable, \lInstr{Capture}_3, $ \\
      $\lInstr{Jump}\;\gnode_1, \lInstr{Bind}] \listConcat \lstack')$.

      \item \rulename{Retrieve}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtcbrc, \gtime}$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Project}] \listConcat \lstack')$.

      \item \rulename{List Indexing}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_1 \gtobrk \ovalvariable_2 \gtcbrk, \gtime}$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Index}] \listConcat \lstack')$.

      \tnote{todo: store and get}

      \item \rulename{Is}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \omemvariable_1 \gtis \omemvariable_2 , \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \omemvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Cmp}] \listConcat \lstack')$.

      \item \rulename{Ifresult \ovalvariable \;(bound)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtifresult \ovalvariable, \gtime}$, \\
         $\gnode_0 = \gsLR{\gsadvance [\olbl \gtcolon \gtlet \ovalvariable' \gteq \gtif \ovalvariable'' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime''}$, and
         $\lstack = [\ovalvariable'] \listConcat \lstack'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable] \listConcat \lstack')$.

      \item \rulename{Ifresult \ovalvariable \;(unbound)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtifresult \ovalvariable, \gtime}$, \\
         $\gnode_0 = \gsLR{\gsadvance [\olbl \gtcolon \gtlet \ovalvariable' \gteq \gtif \ovalvariable'' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime''}$,
         $\lstack = [\ovalvariable'''] \listConcat \lstack'$, and
         $\ovalvariable''' \neq \ovalvariable'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\olbl \gtcolon \gtlet \ovalvariable' \gteq \gtif \ovalvariable'' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc, \gtime'}, \lstack)$.

      \item \rulename{Ifresult \omemvariable \;(bound)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtifresult \omemvariable, \gtime}$, \\
         $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable' \gteq \gtif \ovalvariable'' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime''}$, and
         $\lstack = [\omemvariable'] \listConcat \lstack'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable] \listConcat \lstack')$.

      \item \rulename{Ifresult \omemvariable \;(unbound)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtifresult \omemvariable, \gtime}$, \\
         $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable' \gteq \gtif \ovalvariable'' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime''}$,
         $\lstack = [\omemvariable''] \listConcat \lstack'$, and
         $\omemvariable'' \neq \omemvariable'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\olbl \gtcolon \gtlet \omemvariable' \gteq \gtif \ovalvariable'' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc, \gtime'}, \lstack)$.

      \item \rulename{Function Return \omemvariable \;(bound)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtreturn \omemvariable, \gtime}$, \\
         $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable' \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar] ['], \gtime''}$, and
         $\lstack = [\omemvariable'] \listConcat \lstack'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable] \listConcat \lstack')$.

      \item \rulename{Function Return \omemvariable \;(unbound)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtreturn \omemvariable, \gtime}$, \\
         $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable' \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar] ['], \gtime''}$,
         $\lstack = [\omemvariable''] \listConcat \lstack'$, and
         $\omemvariable' \neq \omemvariable'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\olbl \gtcolon \gtlet \omemvariable' \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar, \gtime'}, \lstack)$.

      \item \rulename{Exception \omemvariable \;(bound)}
      If $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2] ['], \gtime''}$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable] \listConcat \lstack')$.

      \item \rulename{Capture Rule}
      If $\lstack = [\lresult, \lInstr{Capture}, \lstackelt_1, \ldots, \lstackelt_n] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lstackelt_1, \ldots, \lstackelt_n, \lresult] \listConcat \lstack')$.

      \item \rulename{Bind Rule}
      If $\lstack = [\lInstr{Bind}, \ovalue_1, \ovalue_2, \omem] \listConcat \lstack'$,
      and
         $\ovalue_1 = \obinding, \ovalue_2 \in \mathbb{S}, \obinding' = \obinding[\ovalue_2 \mapsto \omem]$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\obinding'] \listConcat \lstack')$.

      \item \rulename{Project Rule}
      If $\lstack = [\lInstr{Project}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
         $\ovalue_1 = \obinding, \ovalue_2 \in \mathbb{S}, \omem = \ovalue_1[\ovalue_2]$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem] \listConcat \lstack')$.

      \item \rulename{Index Rule}
      If $\lstack = [\lInstr{Index}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
         $\ovalue_1 \text{ is a list}, \ovalue_2 \in \mathbb{Z} = i, \omem = \text{the value in the $i^{th}$ position of }\ovalue_1$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem] \listConcat \lstack')$.

      \item \rulename{Cmp Rule}
      If $\lstack = [\lInstr{Index}, \omem_1, \omem_2] \listConcat \lstack'$, and
         \begin{flalign*}
           \ovalue =
           \begin{cases}
             \ostrue, & \text{if } \omem_1 = \omem_2 \\
             \osfalse, & \text{if } \omem_1 \neq \omem_2,
           \end{cases}
         \end{flalign*}
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

    \end{enumerate}
  \end{definition}

\end{document}
