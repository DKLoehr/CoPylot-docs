\documentclass{article}

\input{macros}
\usepackage{enumitem}
\usepackage{caption}


\begin{document}
    \section{CoPylot}

    \subsection{Grammar}



        \begin{figure}\center
              \begin{grammar}
                \grule[labels]{\oglbl}{\olbl \gor \osend}
                \grule[stack]{\ostack}{
                            [\ostackframe,\ldots]
                }
                \grule[stack frame]{\ostackframe}{\oglbl \times \oprogram}
                \grule[programs]{\oprogram}{
                            [\ostmt,\ldots]
                }
                % statements
                \grule[directives]{\odirective}{
                            \ovariable \gteq \oexpr % x = e
                    \gor    \okw{def} \ovariable(\ovariable,\ldots) \gteq \{ \oprogram \}
                            % def x(x, ...) = {S}
                    \gor    \okw{return} \ovariable % return x
                    \gor    \okw{goto} \olbl % return x
                    \gor    \okw{goto} \olbl \okw{if not} \ovariable % return x
                }
                \grule[bindings]{\obinding}{\{\ovariable \mapsto \omem, \ldots\}}
                \grule[heap]{\oheap}{\{\omem \mapsto \ovalue, \ldots\}}
                % value types
                \grule[values]{\ovalue}{
                            \mathbb{Z}
                    \gor    \langle \omem,\okw{def}(\ovariable) \ofuncarr \oprogram \rangle % < scope, def (x) -> S >
                    \gor    \langle \omem,\omem,\okw{def}(\ovariable) \ofuncarr \oprogram \rangle % < scope, obj, def (x) -> S >
                    \gor    [\omem, \ldots] % [m, ...]
                    \gor    (\omem, \ldots) % (m, ...)
                    \gor    \obinding % B
                    %TODO: Magic functions and methods
                }
                % expressions
                \grule[expressions]{\oexpr}{
                            \mathbb{Z}
                    \gor    \ovariable % x
                    \gor    \ovariable(\ovariable, \ldots) % x(x, ...)
                    \gor    [\ovariable, \ldots] % [x, ...]
                    \gor    (\ovariable, \ldots) % (x, ...)
                }
                \grule[parental maps]{\oparent}{\omem \mapsto \omem}

              \end{grammar}

              \begin{mathpar}
              \relationRule{Literal Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable=\ovalue \\
                  \oheap' \gteq \oheap[\omem \mapsto \ovalue] \\
                  \omem \notin \oheap \\
                  \osBind (\oheap',\omem_0,\ovariable,\omem) \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\langle \oglbl'',\oprogram \rangle] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }

              \relationRule{Name Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable_1=\ovalue_2 \\
                  \omem \gteq \osLookup (\omem_0,\oparent,\oheap,\ovariable_2)\\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable_1 \mapsto \omem] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap,\omem_0,\ovariable_1,\omem) \gteq \oheap' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,oparent,\omem_0 \osTransition
                  [\langle \oglbl'',\oprogram \rangle] \listConcat \ostack,\oheap',oparent,\omem_0
              }

              \relationRule{List Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable \gteq [\ovariable_1,\ldots,\ovariable_n] \\
                  \forall i \in \{1,\ldots,n\}, \omem_i \gteq \osLookup(\omem_0,\oparent,\oheap,\ovariable_i) \\
                  \ovalue \gteq [\omem_1,\ldots,\omem_2] \\
                  \oheap' \gteq \oheap[\omem' \mapsto \ovalue] \\
                  \omem' \notin \oheap \\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable \mapsto \omem'] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap',\omem_0,\ovariable,\omem') \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  \langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\langle \oglbl'',\oprogram \rangle] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }

              \relationRule{Tuple Assignment}{
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable \gteq (\ovariable_1,\ldots,\ovariable_n) \\
                  \forall i \in \{1,\ldots,n\}, \omem_i \gteq \osLookup(\omem_0,\oparent,\oheap,\ovariable_i) \\
                  \ovalue \gteq (\omem_1,\ldots,\omem_2) \\
                  \oheap' \gteq \oheap[\omem' \mapsto \ovalue] \\
                  \omem' \notin \oheap \\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable \mapsto \omem'] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap',\omem_0,\ovariable,\omem') \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  \langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\langle \oglbl'',\oprogram \rangle] \listConcat \ostack,\oheap'',\oparent,\omem_0
              }


              \relationRule{Function Definition}{
                  \oprogram(\olbl) \gteq \olbl:\olbl': \okw{def} \ovariable_1(\ovariable_2) \gteq \{\oprogram\} \\
                  \ovalue \gteq \langle \eta, \okw{def}(\ovariable_2) \ofuncarr \oprogram \rangle \\
                  \oheap' \gteq \oheap[\omem \mapsto \ovalue] \\
                  \omem \notin \oheap \\
                  % \obinding \gteq \oenv(\omem_0) \\
                  % \obinding' \gteq \obinding[\ovariable_1 \mapsto \omem] \\
                  % \oenv' \gteq \oenv[\omem_0 \mapsto \obinding'] \\
                  \osBind (\oheap',\omem_0,\ovariable_1,\omem) \gteq \oheap'' \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oparent,\omem_0 \osTransition
                  [\langle \oglbl'',\oprogram \rangle] \listConcat \ostack,\oheap',\oparent,\omem_0
              }



            \end{mathpar}
            \caption{Operation Semantics}
            \label{fig_languageOS}
            \end{figure}

            \begin{figure}\center
              \ContinuedFloat
                \begin{mathpar}

              \relationRule{Function Call}{
              % TODO: multiargs
                  \oprogram(\olbl) \gteq \olbl:\olbl':\ovariable_1=\ovariable_2(\ovariable_3) \\
                  \omem \gteq \osLookup (\omem_0,\oparent,\oenv,\ovariable_2)\\
                  \oheap[\omem] \gteq \langle \omem_0',\okw{def}(\ovariable_4) \mapsto \oprogram' \rangle \\
                  \omem_0'' \notin \oenv \\
                  \omem' \gteq \osLookup (\omem_0,\oparent,\oenv,\ovariable_3) \\
                  \obinding' \gteq \obinding [\ovariable_4 \mapsto \omem'] \\
                  \oenv' \gteq \oenv[\omem_0'' \mapsto \obinding'] \\
                  \oparent' \gteq \oparent \cup \{\omem_0'' \mapsto \omem_0'\} \\
                  \oprogram' \gteq [\olbl'':\olbl''':\odirective] \listConcat \oprogram''
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl'',\oprogram' \rangle,\langle l,S \rangle] \listConcat \ostack,\oheap',\oenv',\oparent',\omem_0''
              }

              \relationRule{Pass}{
                  \oprogram(\olbl) \gteq \olbl:\olbl': pass \\
                  \olbl \osBefore{S} \oglbl''
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl'',\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0
              }

              \relationRule{Return}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{return}  \\
                  \ostack \gteq [\ostackframe,\langle \olbl'',\oprogram' \rangle] \listConcat \ostack' \\
                  \omem_0' \gteq \oparent[\omem_0] \\
                  \olbl'' \osBefore{S'} \oglbl''' \\
              }{
                  [\ostackframe,\langle \olbl'',\oprogram' \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl'',\oprogram' \rangle] \listConcat \ostack',\oheap,\oenv,\oparent,\omem_0'
              }

              % TODO: fix format here
              \relationRule{Return with Arguments}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{return}  \ovariable \\
                  \ostack \gteq [\ostackframe,\langle \olbl'',\oprogram' \rangle] \listConcat \ostack' \\
                  \omem \gteq \osLookup(\omem_0,\oparent,\oenv,\ovariable) \\
%
                  \oprogram'(\olbl'') \gteq \olbl'':\olbl''' : \ovariable_1=\ovariable_2(\ovariable_3) \\ % TODO: multiargs
%
                  \omem_0' \gteq \oparent[\omem_0] \\
                  \obinding \gteq \oenv(\omem_0') \\
                  \obinding' \gteq \obinding[\ovariable_1 \mapsto \omem] \\
                  \oenv' \gteq \oenv[\omem_0' \mapsto \obinding'] \\
%
                  \olbl'' \osBefore{S'} \oglbl'''' \\
              }{
                  [\ostackframe,\langle \olbl'',\oprogram' \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl'',\oprogram' \rangle] \listConcat \ostack,\oheap,\oenv',\oparent,\omem_0'
              }



              \relationRule{Goto}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{goto} \olbl'' \\
                  \oprogram = [\olbl'':\olbl''':\odirective] \listConcat \oprogram'
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl'',\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0
              }

              \relationRule{GotoIfNot}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \okw{goto} \olbl'' \okw{if not} \ovariable \\
                  \omem = \osLookup(\omem_0,\oparent,\oenv,\ovariable) \\
                  \oheap[\omem] \gteq \osfalse \\
                  \oprogram = [\olbl'':\olbl''':\odirective] \listConcat \oprogram'
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl'',\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0
              }

              \relationRule{Name Statement}{
                  \oprogram(\olbl) \gteq \olbl:\olbl' : \oexpr \\
                  \forall \ovariable \in \oexpr \exists \obinding[\ovariable] \\
                  %%% \ovariable | \ovalue | \ovariable(\ovariable_1,\ldots,\ovariable_n) | \ovariable.\ovariable' | [\ovariable_1,\ldots,\ovariable_n] | (\ovariable_1,\ldots,\ovariable_n)
                  \olbl \osBefore{S'} \oglbl'' \\
              }{
                  [\langle \olbl,\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl',\oprogram \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0
              }

              \relationRule{End of Function}{
                  \ostack \gteq [\langle \osend,\oprogram \rangle,\langle \olbl,\oprogram' \rangle]\listConcat \ostack' \\
                  \omem_0' \gteq \oparent[\omem_0] \\
                  \olbl \osBefore{S'} \oglbl'
              }{
                  [\langle \osend,\oprogram \rangle,\langle \olbl,\oprogram' \rangle] \listConcat \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [\langle \olbl',\oprogram' \rangle] \listConcat \ostack',\oheap,\oenv,\oparent,\omem_0'
              }

              \relationRule{End of Program}{
                  \ostack = [(\osend,\ostackframe)] \\
              }{
                  \ostack,\oheap,\oenv,\oparent,\omem_0 \osTransition
                  [],\oheap,\oenv,\oparent,\omem_0'
              }


            \end{mathpar}
            \caption{Operation Semantics (cont.)}
            \label{fig_languageOS}
        \end{figure}

        \begin{figure}\center
          \ContinuedFloat
            \begin{mathpar}

            \end{mathpar}
            \caption{Operation Semantics (cont.)}
            \label{fig_languageOS}
        \end{figure}

    \begin{figure}\center
        \begin{grammar}
            \grule[abstract programs]{\aprogram}{
                        [\astmt,\ldots]
            }
            \grule[abstract statements]{\astmt}{
                        \xstmt{\albl}{\albl}{\adirective}
            }
            \grule[abstract directives]{\adirective}{
                        \avariable \gteq \avalue
                \gor    \avariable \gteq \avariable
            }
            \grule[abstract values]{\avalue}{
                        \gtintplus
                \gor    \gtintminus
                \gor    \gtintzero
            }
            \grule[abstract variables]{\avariable}{}
            \grule[abstract labels]{\albl}{}

        \end{grammar}
        \caption{Normalized Python Language Grammar}
        \label{fig_languageGrammar}
    \end{figure}

    The grammar of the language to be analyzed appears in Figure~\ref{fig_languageGrammar}.

    We assume throughout the rest of this document that a fixed program $\aprogram$ is under analysis.  \znote{TODO: describe here the idea of a bijection between labels and statements in this fixed program.}

    \subsection{Control Flow}

    The grammar of control flow graphs appears in Figure~\ref{fig_cfgGrammar}.  \znote{Discuss construction of initial graph.}

    \begin{figure}\center
        \begin{grammar}
            \grule[control flow graphs]{\cfg}{
                        \{\cfgedge, \ldots\}
            }
            \grule[control flow graph edge]{\cfgedge}{
                        \cfgnode \lexicallyBefore \cfgnode
                \gor    \cfgnode \before \cfgnode
            }
            \grule[control flow graph nodes]{\cfgnode}{
                        \gstart
                \gor    \gend
                \gor    \astmt
            }
        \end{grammar}
        \caption{Control Flow Graph Grammar}
        \label{fig_cfgGrammar}
    \end{figure}



    We write $\cfgnode \islexicallyBefore \cfgnode'$ to denote $(\cfgnode \lexicallyBefore \cfgnode' \in \cfg$ when $\cfg$ is understood from context.  Likewise, we write $\cfgnode \isbefore \cfgnode'$ to denote $(\cfgnode \before \cfgnode' \in \cfg$ when $\cfg$ is understood from context.

    We define a relation $\cfgClosureStep$ to perform control flow graph closure.

    \begin{definition}
        Let $\cfg \cfgClosureStep \cfg'$ be the least relation satisfying the rules appearing in Figure~\ref{fig_cfgClosure}.  Throughout these rules, the predicates $\isbefore$ and $\islexicallyBefore$ refer to graph $\cfg$.
    \end{definition}

    \begin{figure}
        \begin{mathpar}
            \relationRule{Lexical Start}{
                \gstart \islexicallyBefore \cfgnode
            }{
                \cfg \cfgClosureStep \cfg \cup \{\gstart \before \cfgnode\}
            }

            \relationRule{Literal Assignment}{
                \cfgnode_1 = (\avariable \gteq \avalue) \\
                \cfgnode_1 \islexicallyBefore \cfgnode_2
            }{
                \cfg \cfgClosureStep \cfg \cup \{\cfgnode_1 \before \cfgnode_2\}
            }

            \relationRule{Variable Accessible}{
                \cfgnode_1 = (\avariable \gteq \avariable') \\
                \cfgnode_1 \islexicallyBefore \cfgnode_2 \\
                \avalue \in \valueLookup{\cfgnode_1}{[\avariable']} \\
                \avalue \neq {\text{\textsmaller{\sc Undefined}}}
            }{
                \cfg \cfgClosureStep \cfg \cup \{\cfgnode_1 \before \cfgnode_2\}
            }
        \end{mathpar}
        \caption{Control Flow Graph Closure}
        \label{fig_cfgClosure}
    \end{figure}

    \subsection{Value Lookup}

    The value lookup function uses the additional grammar in Figure~\ref{fig_valueLookupGrammar}.

    \begin{figure}
        \begin{grammar}
            \grule[lookup stacks]{\astack}{
                        [\astackelement, \ldots]
            }
            \grule[lookup stack elements]{\astackelement}{
                        \avariable
                \gor    \avalue % subject to change to e.g. heap fragments
                \gor    \kcapture{\mathbb{N}}
                \gor    \kjump{\cfgnode}
            }
        \end{grammar}
        \caption{Value Lookup Grammar}
        \label{fig_valueLookupGrammar}
    \end{figure}

    \begingroup
        \newenvironment{enumerateClauses}%
            {\begin{enumerate}[label=(\alph*),ref=\arabic{enumi}\alph*]}%
            {\end{enumerate}}
        \newenvironment{enumerateSubclauses}%
            {\begin{enumerate}[label=\roman*.,ref=\arabic{enumi}\alph{enumii}(\roman*)]}%
            {\end{enumerate}}
        \newcommand{\clauseSectionTitle}[1]{\textbf{#1}}
        \newcommand{\clauseSubsectionTitle}[1]{\underline{\smash{#1}}}
        \newcommand{\rulename}[1]{%
            \begingroup%
                \setlength{\fboxsep}{1.5pt}%
                \fcolorbox{black}{gray!15!white}{%
                    \textsc{\textsmaller{#1}}%
                }%
                \vspace*{1pt}%
            \endgroup%
            \\%
        }
        \begin{definition}
            Given a control-flow graph $\cfg$, let $\valueLookup[\cfg]{\cfgnode_0}{\astack}$ be the function returning the least set $\avalues$ which satisfies the following conditions:

            \begin{enumerate}
                \item \clauseSectionTitle{Value Manipulation}
                \begin{enumerateClauses}
                    \item \rulename{Result}
                        If
                            $\astack = [\avalue]$,
                        then
                            $\avalue \in \avalues$.
                \end{enumerateClauses}

                \item \clauseSectionTitle{Variable Lookup}
                \begin{enumerateClauses}
                    \item \rulename{Value Discovery}
                        If
                            $\cfgnode_1 \isbefore \cfgnode_0$,
                            $\cfgnode_1 =
                                \xstmt{\albl_1}{\albl_2}{\avariable \gteq \avalue}$, and
                            $\astack = [\avariable] \listConcat \astack'$,
                        then
                            $\valueLookup{\cfgnode_1}{[\avalue] \listConcat \astack'} \subseteq \avalues$.

                    \item \rulename{Value Skip}
                        If
                            $\cfgnode_1 \isbefore \cfgnode_0$,
                            $\cfgnode_1 =
                                \xstmt{\albl_1}{\albl_2}{\avariable' \gteq \avalue}$,
                            $\astack = [\avariable] \listConcat \astack'$, and
                            $\avariable \neq \avariable'$,
                        then
                            $\valueLookup{\cfgnode_1}{\astack} \subseteq \avalues$.
                    \item \rulename{Value Aliasing}
                        If
                            $\cfgnode_1 \isbefore \cfgnode_0$,
                            $\cfgnode_1 =
                                \xstmt{\albl_1}{\albl_2}{\avariable \gteq \avariable'}$, and
                            $\astack = [\avariable] \listConcat \astack'$,
                        then
                            $\valueLookup{\cfgnode_1}{[\avariable'] \listConcat \astack} \subseteq \avalues$.
                \end{enumerateClauses}


            \end{enumerate}
        \end{definition}
        \endgroup
\end{document}
