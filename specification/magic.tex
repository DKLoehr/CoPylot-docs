%<*micro>
\gor    \osMC{Assert} \;n
\gor    \osMC{Sum}
\gor    \osMC{Neg}
\gor    \osMC{StrConcat}
\gor    \osMC{StrContains}
\gor    \osMC{Contains}
%</micro>

%<*assertions>
\begin{mathpar}
  \relationRule{Assert Method}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \in \ogenm \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{MetType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert Int}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \in \mathbb{Z} \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{IntType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert String}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \in \mathbb{S} \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{StrType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert List}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \text{ is of form } [\omem, \ldots] \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{LstType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert Tuple}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \text{ is of form } (\omem, \ldots) \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{TplType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert (base case)}{
    \\
  }{
    \osInStack{\osMC{Assert} \;0}, \ostack, \oheap \osTransition
    [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
  }
\end{mathpar}
%</assertions>

%<*binop>
\begin{mathpar}
  \relationRule{Sum \ovalue \; \ovalue}{
    \ovalue = \ovalue_1 + \ovalue_2
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{Sum}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Neg \ovalue}{
    \ovalue' = -(\ovalue)
  }{
    \osInStack{\ovalue, \osMC{Neg}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrConcat \ovalue}{
    \ovalue = \ovalue_1 \strConcat \ovalue_2
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{StrConcat}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrContains \ovalue}{
    \ovalue =
    \begin{cases}
      \ostrue, & \text{if } \ovalue_2 \text{ is a substring of } \ovalue_1 \cr
      \osfalse, & \text{otherwise}
    \end{cases}
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{StrContains}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue}, \ostack, \oheap
  }
\end{mathpar}

\tnote{Iters do not exist yet.}

\begin{mathpar}
  \relationRule{Contains \ovalue}{
    \ovalue =
    \begin{cases}
      \ostrue, & \text{if } \ovalue_2 \in \ovalue_1 \cr
      \osfalse, & \text{otherwise}
    \end{cases}
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{Contains}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue}, \ostack, \oheap
  }
\end{mathpar}
%</binop>

%<*op>
\begin{mathpar}
  \relationRule{IntAdd}{
    \ovalue = \osMagic{IntAdd} \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\omem_1, \osMC{Get}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, \osMem{IntType}, \osMC{Assert}, \omem_2, \osMC{Get}, \ostarvalue{value}, \osMC{Retrieve}, \\ \osMC{Get}, \osMem{IntType}, \osMem{FloatType}, \osMC{Assert}, \osMC{Sum}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{IntNeg}{
    \ovalue = \osMagic{IntNeg} \\
    \ovalue' = \oheap[\omem][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_{\texttt{neg}} = -(\ovalue') \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{neg}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem, \osMC{Call} \;1}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrAdd}{
    \ovalue = \osMagic{StrAdd} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_{\texttt{concat}} = \ovalue_1 \strConcat \ovalue_2 \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{concat}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrContains}{
    \ovalue = \osMagic{StrContains} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_{\texttt{has}} =
    \begin{cases}
      \ostrue, & \text{if}\; \ovalue_2 \in \ovalue_1 \cr
      \osfalse, & \text{otherwise}
    \end{cases} \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{has}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{LstContains}{
    \ovalue = \osMagic{LstContains} \\
    \ovalue_1 = \oheap[\omem][\ostarvalue{value}] = [\omem_1,\omem_2,\ldots] \\
    \ovalue_2 = \oheap[\omem'][\ostarvalue{value}] \\
    \ovalue' = [\oheap[\omem_1],\oheap[\omem_2],\ldots] \\
    \ovalue_{\texttt{has}} =
    \begin{cases}
      \ostrue, & \text{if}\; \ovalue_2 \in \ovalue_1 \cr
      \osfalse, & \text{otherwise}
    \end{cases} \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{has}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem, \omem', \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}
%</op>

%<*graph>
\begin{mathpar}
  \relationRule{IntAdd}{
    \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
    \ovalue = \osMagic{IntAdd} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_{\texttt{sum}} = \ovalue_1 + \ovalue_2 \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{sum}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}
%</graph>
