%<*micro>
\gor    \osMC{Assert} \;n
\gor    \osMC{Sum}
\gor    \osMC{Neg}
\gor    \osMC{StrConcat}
\gor    \osMC{StrContains}
\gor    \osMC{Getitem}
% \gor    \osMC{Contains}
%</micro>

%<*grimoire>
  \gor    \osMagic{IntAdd}
  \gor    \osMagic{IntNeg}
  \gor    \osMagic{StrAdd}
  \gor    \osMagic{StrContains}
  \gline
  % \gor    \osMagic{LstIter}
  % \gor    \osMagic{LstContains}
  \gor    \osMagic{LstGetitem}
  % \gor    \osMagic{TplIter}
  % \gor    \osMagic{TplContains}
  % \gline
  \gor    \osMagic{TplGetitem}
%</grimoire>

%<*assertions>
\begin{mathpar}
  \relationRule{Assert Method}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \in \ogenm \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{MetType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert Int}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \in \mathbb{Z} \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{IntType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert String}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \in \mathbb{S} \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{StrType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert List}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \text{ is of form } [\omem, \ldots] \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{LstType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert Tuple}{
    \omstack' =
    \begin{cases}
      [\ovalue], & \text{if}\; \ovalue \text{ is of form } (\omem, \ldots) \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{TplType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert (base case)}{
    \\
  }{
    \osInStack{\osMC{Assert} \;0}, \ostack, \oheap \osTransition
    [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
  }
\end{mathpar}
%</assertions>

%<*binop>
\begin{mathpar}
  \relationRule{Sum \ovalue \; \ovalue}{
    \ovalue = \ovalue_1 + \ovalue_2
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{Sum}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Neg \ovalue}{
    \ovalue' = -(\ovalue)
  }{
    \osInStack{\ovalue, \osMC{Neg}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrConcat \ovalue \; \ovalue}{
    \ovalue = \ovalue_1 \strConcat \ovalue_2
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{StrConcat}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrContains \ovalue}{
    \ovalue =
    \begin{cases}
      \ostrue, & \text{if } \ovalue_2 \text{ is a substring of } \ovalue_1 \cr
      \osfalse, & \text{otherwise}
    \end{cases}
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{StrContains}}, \ostack, \oheap \osTransition
    \osInStack{\ovalue}, \ostack, \oheap
  }
\end{mathpar}

\tnote{Iters do not exist yet.}

% \begin{mathpar}
%   \relationRule{Contains \ovalue}{
%     \ovalue =
%     \begin{cases}
%       \ostrue, & \text{if } \ovalue_2 \in \ovalue_1 \cr
%       \osfalse, & \text{otherwise}
%     \end{cases}
%   }{
%     \osInStack{\ovalue_1, \ovalue_2, \osMC{Contains}}, \ostack, \oheap \osTransition
%     \osInStack{\ovalue}, \ostack, \oheap
%   }
% \end{mathpar}

\begin{mathpar}
  \relationRule{Getitem \ovalue}{
    \ovalue_1 = [\omem_0, \ldots, \omem_n] \;|\; (\omem_1, \ldots, \omem_n) \\
    0 \le \ovalue_2 \le n \\
    \omstack' = [\omem_{\ovalue_2}, \osMC{Get}]
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{Getitem}}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Getitem (out of bound)}{
    \ovalue_1 = [\omem_0, \ldots, \omem_n] | (\omem_1, \ldots, \omem_n) \\
    0 > \ovalue_2 \;|\; \ovalue > n
  }{
    \osInStack{\ovalue_1, \ovalue_2, \osMC{Getitem}}, \ostack, \oheap \osTransition
    [\osMC{AllocIndexError}, \osMC{Raise}], \ostack, \oheap
  }
\end{mathpar}
%</binop>

%<*op>
\begin{mathpar}
  \relationRule{Wrong Number of Args}{
    \ovalue = \omagicm \\
    \osFunc{CheckArgs}(\ovalue, n) = \osfalse \\
    \omstack' = [\osMC{AllocTypeError}, \osMC{Raise}]
  }{
    \osInStack{\ovalue, \omem_1, \ldots, \omem_n, \osMC{Call} \;n}, \ostack, \oheap \osTransition%
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \osDuoMagic {IntAdd} {\osMem{IntType}} {\osMem{IntType}, \osMem{FloatType}} {2} {\osMC{Sum}} {}
\end{mathpar}

\begin{mathpar}
  \relationRule{IntNeg}{
    \ovalue = \osMagic{IntNeg} \\
    \osFunc{CheckArgs}(\ovalue, 1) = \ostrue \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\omem, \osMC{Get}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, \osMem{IntType}, \osMC{Assert} \;1, \osMC{Neg}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem, \osMC{Call} \;1}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \osDuoMagic {StrAdd} {\osMem{StrType}} {\osMem{StrType}} {1} {\osMC{StrConcat}} {}
\end{mathpar}

\begin{mathpar}
  \osDuoMagic {StrContains} {\osMem{StrType}} {\osMem{StrType}} {1} {\osMC{StrContains}} {}
\end{mathpar}

% \begin{mathpar}
%   \osDuoMagic {LstContains} {\osMem{LstType}} {} {} {\osMC{Contains}} {}
% \end{mathpar}

\begin{mathpar}
  \relationRule{LstGetitem}{
    \ovalue = \osMagic{LstGetitem} \\
    \osFunc{CheckArgs}(\ovalue, 2) = \ostrue \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\opscope, \omem_1, \osMC{Get}, \ostarvalue{value}, \osMC{Retrieve}, \osMC{Get}, \osMem{LstType}, \osMC{Assert} \;1, \omem_2, \osMC{Get}, \ostarvalue{value}, \osMC{Retrieve}, \\ \osMC{Get}, \osMem{IntType}, \osMC{Assert} \;1, \osMC{Getitem}, \ovariable, \osMC{Bind}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition%
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

% \begin{mathpar}
%   \osDuoMagic {TplContains} {\osMem{TplType}} {} {} {\osMC{Contains}} {}
% \end{mathpar}
%</op>

%<*helper>
\begin{definition}[Magic argument check]
  \begin{flalign*}
    \osFunc{CheckArgs}(\ovalue, n) =
    \begin{cases}
      \ostrue, & \text{if } (\ovalue, n) =
        \begin{cases}
          (\osMagic{IntAdd}, 2) \\
          (\osMagic{IntNeg}, 1) \\
          (\osMagic{StrAdd}, 2) \\
          (\osMagic{StrContains}, 2) \\
          (\osMagic{LstGetitem}, 2) \\
          (\osMagic{TplGetitem}, 2) \\
        \end{cases}
      \\
      \osfalse, & \text{otherwise}
    \end{cases}
  \end{flalign*}
\end{definition}
%</helper>

%<*graph>
\begin{mathpar}
  \relationRule{IntAdd}{
    \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
    \ovalue = \osMagic{IntAdd} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_{\texttt{sum}} = \ovalue_1 + \ovalue_2 \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{sum}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}
%</graph>
