%<*micro>
\gor    \osMC{Assert} \;n
\gor    \osMC{IntSum}
\gor    \osMC{IntNeg}
\gor    \osMC{StrSum}
\gor    \osMC{StrContains}
\gline
\gor    \osMC{LstIter}
\gor    \osMC{LstContains}
\gor    \osMC{TplIter}
\gor    \osMC{TplContains}
%</micro>
%<*assertions>
\begin{mathpar}
  \relationRule{Assert Method}{
    \omstack' =
    \begin{cases}
      [\;], & \text{if}\; \ovalue \in \ogenm \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{MetType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert Int}{
    \omstack' =
    \begin{cases}
      [\;], & \text{if}\; \ovalue \in \mathbb{Z} \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{IntType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert String}{
    \omstack' =
    \begin{cases}
      [\;], & \text{if}\; \ovalue \in \mathbb{S} \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{StrType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert List}{
    \omstack' =
    \begin{cases}
      [\;], & \text{if}\; \ovalue \text{ is of form } [\omem, \ldots] \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{LstType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert Tuple}{
    \omstack' =
    \begin{cases}
      [\;], & \text{if}\; \ovalue \text{ is of form } (\omem, \ldots) \cr
      [\ovalue, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n-1], & \text{otherwise}
    \end{cases} \\
  }{
    \osInStack{\ovalue, \osMem{TplType}, \olcode_2, \ldots, \olcode_n, \osMC{Assert} \;n}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Assert (base case)}{
    \\
  }{
    \osInStack{\osMC{Assert} \;0}, \ostack, \oheap \osTransition
    [\osMC{AllocTypeError}, \osMC{Raise}], \ostack, \oheap
  }
\end{mathpar}

%</assertions>
%<*op>
\begin{mathpar}
  \relationRule{IntAdd}{
    \ovalue = \osMagic{IntAdd} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_{\texttt{sum}} = \ovalue_1 + \ovalue_2 \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{sum}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{IntNeg}{
    \ovalue = \osMagic{IntNeg} \\
    \ovalue' = \oheap[\omem][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_{\texttt{neg}} = -(\ovalue') \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{neg}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem, \osMC{Call} \;1}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrAdd}{
    \ovalue = \osMagic{StrAdd} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_{\texttt{concat}} = \ovalue_1 \strConcat \ovalue_2 \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{concat}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{StrContains}{
    \ovalue = \osMagic{StrContains} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{S} \\
    \ovalue_{\texttt{has}} =
    \begin{cases}
      \ostrue, & \text{if}\; \ovalue_2 \in \ovalue_1 \cr
      \osfalse, & \text{otherwise}
    \end{cases} \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{has}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{LstContains}{
    \ovalue = \osMagic{LstContains} \\
    \ovalue_1 = \oheap[\omem][\ostarvalue{value}] = [\omem_1,\omem_2,\ldots] \\
    \ovalue_2 = \oheap[\omem'][\ostarvalue{value}] \\
    \ovalue' = [\oheap[\omem_1],\oheap[\omem_2],\ldots] \\
    \ovalue_{\texttt{has}} =
    \begin{cases}
      \ostrue, & \text{if}\; \ovalue_2 \in \ovalue_1 \cr
      \osfalse, & \text{otherwise}
    \end{cases} \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{has}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem, \omem', \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}
%</op>
%<*graph>
\begin{mathpar}
  \relationRule{IntAdd}{
    \gnode_1 \gsBefore \gnode_2 \in \ggraph \\
    \ovalue = \osMagic{IntAdd} \\
    \ovalue_1 = \oheap[\omem_1][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_2 = \oheap[\omem_2][\ostarvalue{value}] = \mathbb{Z} \\
    \ovalue_{\texttt{sum}} = \ovalue_1 + \ovalue_2 \\
    \ostack = [\osLR{\opscope, \olbl}] \listConcat \ostack' \\
    \oprogram(\olbl) = \olbl:\oglbl': \ovariable \gteq \oexpr \\
    \omstack' = [\ovalue_{\texttt{sum}}, \ovariable, \osMC{Assign}, \osMC{Advance}]
  }{
    \osInStack{\ovalue, \omem_1, \omem_2, \osMC{Call} \;2}, \ostack, \oheap \osTransition
    \osInStack{\omstack'}, \ostack, \oheap
  }
\end{mathpar}
%</graph>
