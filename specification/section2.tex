\section{Graph-Based Semantics}

\tnote{This section is obsolete. }

\subsection{Graph Grammar}

\begin{grammar}
  \grule[graph]{\ggraph}{\gsSet{\gedge, \ldots}}
  \grule[edges]{\gedge}{\gnode \gsBefore \gnode}
  \grule[nodes]{\gnode}{\gsLR{\gstate, \gtime}}
  \grule[states]{\gstate}{
              \gsstart
      \gor    \gsend
      \gor    \ostmt
      \gor    \gsadvance[\ostmt]
      \gor    \gsifresult[\ostmt]
      \gor    \gsreturn[\ostmt]
      \gline
      \gor    \gsraise[\ostmt]
  }
  \grule[general statements]{\gstmt}{
              \ostmt
      \gor    \osplat
  }
  \grule[time stack]{\gtime}{[n, \ldots]}
  \grule[memory addresses]{\omem, \opscope}{\gsLR{\ostmt, \gtime}}
\end{grammar}

\begin{definition}[Skippable statements]
  $\ostmt = \olbl \gtcolon \odirective$ is skippable if and only if
  \begin{flalign*}
    \odirective \in & \gsSet{\gtlet \ovalvariable \gteq \oexpr, \gtlet \omemvariable \gteq \gtalloc, \gtlet \ovalvariable \gteq \ovalvariable, \gtlet \omemvariable \gteq \omemvariable, \\
    & \gtlet \ovalvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtarrow \omemvariable \gtcbrc, \gtlet \omemvariable \gteq \ovalvariable \gtobrc \ovalvariable \gtcbrc, \gtlet \omemvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcbrk, \\
    & \gtlet \ovalvariable \gteq \ovalvariable \gtobrk \ovalvariable \gtcolon \ovalvariable \gtcbrk, \gtstore \omemvariable \; \ovalvariable, \gtlet \ovalvariable \gteq \gtget \omemvariable, \gtlet \ovalvariable \gteq \omemvariable \gtis \omemvariable, \gtlet \ovalvariable \gteq \ounop \ovalvariable, \\
    & \gtlet \ovalvariable \gteq \ovalvariable \obinop \ovalvariable}
  \end{flalign*}
\end{definition}

\begin{notation} [Statement relations]
  \begin{flalign*}
    \ostmt \osBefore \ostmt' & \iff \text{\ostmt \! is lexically before \ostmt'} \\
    \ostmt \osUnder \ostmt' & \iff \text{\ostmt' \! is the lexical parent of \ostmt} \\
    \ostmt \osStartof \ostmt' & \iff \text{\ostmt \! is the first statement of the block where \ostmt' lives} \\
  \end{flalign*}
\end{notation}

\begin{notation} [Graph node relations]
  \begin{flalign*}
    \gnode \gsBeforeIn \gnode' & \iff \gnode \gsBefore \gnode' \in \ggraph \\
  \end{flalign*}
\end{notation}

\begin{notation} [Time stack operations]
  \begin{flalign*}
    ([n] \listConcat \gtime) \tplus & \iff [n+1] \listConcat \gtime &\osNote{time count +1}\\
    ([n] \listConcat \gtime) \tminus & \iff [n-1] \listConcat \gtime &\osNote{time count -1}\\
    ([0] \listConcat \gtime) \tminus & \iff \gtime &\osNote{time count 0, pop stack}\\
    \gtime \tpush & \iff [0] \listConcat \gtime &\osNote{push stack and reset count}\\
    ([p, q] \listConcat \gtime) \tpop & \iff [q+1] \listConcat \gtime &\osNote{pop stack and increment count by 1}\\
    ([n] \listConcat \gtime) \treset & \iff [0] \listConcat \gtime &\osNote{reset count}\\
  \end{flalign*}
\end{notation}

\subsection{Lookup Grammar}

\begin{grammar}
  \grule[lookup stack]{\lstack}{[\lstackelt, \ldots]}
  \grule[lookup stack elements]{\lstackelt}{
              \ovalvariable
      \gor    \ovalue
      \gor    \omemvariable
      \gor    \omem
      \gor    \linstr
  }
  \grule[lookup results]{\lresult}{
              \ovalue
      \gor    \omem
  }
  \grule[lookup result set]{\lresults}{\gsSet{\lresult, \ldots}}
  \grule[lookup stack instructions]{\linstr}{
              \lInstr{Capture}_ n
      \gor    \lInstr{Jump} \; \gnode
      \gor    \lInstr{Bind}
      \gor    \lInstr{Project}
      \gor    \lInstr{Index}
      \gline
      \gor    \lInstr{Slice}
      \gor    \lInstr{Alias?}
      \gor    \lInstr{!}
      \gor    \lInstr{Unop}
      \gor    \lInstr{Binop}
      \gor    \lInstr{Answer}
      \gor    \lInstr{Is}
      \gline
      \gor    \lInstr{Drop}
      \gor    \lInstr{List}
  }
\end{grammar}

\subsection{Graph Rules}

\begin{mathpar}
  \relationRule{Start}{
    \ostmts = [\ostmt, \ldots]
  }{
    \gsAddEdge{\gsLR{\gsstart, [0]} \gsBefore \gsLR{\ostmt, [1]}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Skip}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt \text{ is skippable}
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt], \gtime \tplus}}
  }
\end{mathpar}

\subsubsection{While}

\begin{mathpar}
  \relationRule{While-True Start}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc \\
    \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, [\omemvariable, \lInstr{!}]) \\
    \ostmts = [\ostmt', \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tpush}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{While-False}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc \gtsemi \\
    \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, [\omemvariable, \lInstr{!}])
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt], \gtime \tplus}}
  }
\end{mathpar}

\subsubsection{If}

\begin{mathpar}
  \relationRule{If-True Start (\ovalvariable)}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
    \ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
    \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
    \ostmts_1 = [\ostmt_1, \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime \tpush}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{If-False Start (\ovalvariable)}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
    \ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
    \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
    \ostmts_2 = [\ostmt_2, \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime \tpush}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{If Result (\ovalvariable)}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt = \olbl \gtcolon \gtifresult \ovalvariable
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt], \gtime \tplus}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{If-True Start (\omemvariable)}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
    \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
    \ostrue \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
    \ostmts_1 = [\ostmt_1, \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime \tpush}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{If-False Start (\omemvariable)}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
    \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc \\
    \osfalse \in \osFunc{Lookup}(\ggraph, \ostmt, [\ovalvariable']) \\
    \ostmts_2 = [\ostmt_2, \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime \tpush}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{If Result (\omemvariable)}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt = \olbl \gtcolon \gtifresult \omemvariable \\
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt], \gtime \tplus}}
  }
\end{mathpar}

\subsubsection{Function}

\begin{mathpar}
  \relationRule{Function Call}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_0 \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar \\
    \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \ostmts' \in \osFunc{Lookup}(\ggraph, \gnode_2, [\ovalvariable_0]) \\
    \ostmts' = [\ostmt', \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tpush}}
  }
\end{mathpar}

\tnote{We don't need param list here. This is done in lookup.}

\begin{mathpar}
  \relationRule{Function Return}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt = \olbl \gtcolon \gtreturn \omemvariable
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsreturn[\ostmt], \gtime \tplus}}
  }
\end{mathpar}

\subsubsection{Exception}

\begin{mathpar}
  \relationRule{Try}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\\\
    \ostmt = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
    \ostmts_1 = [\ostmt_1, \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_1, \gtime \tpush}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Raise Exception}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\ostmt, \gtime}\\
    \ostmt = \olbl \gtcolon \gtraise \omemvariable
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt], \gtime \tplus}}
  }
\end{mathpar}

\subsubsection{Flow}

\begin{mathpar}
  \relationRule{Advance}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
    \ostmt \osBefore \ostmt'
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tplus}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Advance End of While}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
    \ostmt \osBefore \osplat \\
    \ostmt \osUnder \ostmt' \\
    \ostmt' \text{ is a while statement}
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt', \gtime \tpop}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Advance End of Try and Except}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
    \ostmt \osBefore \osplat \\
    % \ostmt \osUnder \ostmt' \\
    \ostmt \osUnder \ostmt' \\
    \ostmt' \text{ is a try statement}
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt'][\tpop \tminus], \gtime \tpop}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Advance EOF}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsadvance[\ostmt]['], \gtime}\\
    \ostmt \osBefore \osplat \\
    \ostmt \osUnder \osplat
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsend, \gtime \tplus}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Ifresult}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsifresult[\ostmt]['], \gtime}\\
    % \ostmt \osUnder \ostmt' \\
    \ostmt \osUnder \ostmt' \\
    \ostmt' \text{ is an if statement}
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt'][\tpop \tminus], \gtime \tpop}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Ifresult Through Blocks}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsifresult[\ostmt]['], \gtime}\\
    \ostmt \osUnder \ostmt' \\
    \ostmt' \text{ is a while or try statement}
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsifresult[\ostmt'][\tpop \tminus], \gtime \tpop}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Return}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsreturn[\ostmt]['], \gtime}\\
    \ostmt \osUnder \ostmt' \\
    \ostmt' \text{ is a funcdef} \\
    \ostmt_1 \osStartof \ostmt \\
    \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset} \\
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsadvance[\ostmt_0][_0], \gtime \tpop}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Return Through Blocks}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsreturn[\ostmt]['], \gtime}\\
    \ostmt \osUnder \ostmt' \\
    \ostmt' \text{ is not a funcdef} \\
    \ostmt_1 \osStartof \ostmt \\
    \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset} \\
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsreturn[\ostmt_0][_0], \gtime \tplus}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Raise in Try Statment}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsraise[\ostmt]['], \gtime}\\
    \ostmt \osUnder \ostmt' \\
    \ostmt' = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
    \ostmt \in \ostmts_1 \\
    \ostmts_2 = [\ostmt_2, \ldots]
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\ostmt_2, \gtime \tplus \tpop \tpush}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Raise From Exception Block}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsraise[\ostmt]['], \gtime}\\
    \ostmt \osUnder \ostmt' \\
    \ostmt' = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc \\
    \ostmt \in \ostmts_2 \\
    \ostmt_1 \osStartof \ostmt \\
    % \gsLR{\ostmt', \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset}
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt'][_0 \tpop \tminus], \gtime \tpop}}
  }
\end{mathpar}

\begin{mathpar}
  \relationRule{Raise Through Blocks}{
    \gnode_1 \gsBeforeIn \gnode_2 \\
    \gnode_2 = \gsLR{\gsraise[\ostmt]['], \gtime}\\
    \ostmt \osUnder \ostmt' \\
    \ostmt' \text{ is an if statement, while statement or funcdef} \\
    \ostmt_1 \osStartof \ostmt \\
    % \gsLR{\ostmt_0, \gtime_0} \gsBeforeIn \gsLR{\ostmt_1, \gtime' \treset}
  }{
    \gsAddEdge{\gnode_2 \gsBefore \gsLR{\gsraise[\ostmt'][_0 \tpop \tminus], \gtime \tpop}}
  }
\end{mathpar}

% \tnote{todo: add raise at top level}

\subsection{Helper Functions}

\begin{definition}[Lookup]
  Let \osFunc{Lookup}($\ggraph, \gnode_0, \lstack$) be the function returning the least set \lresults \;such that the following rules hold for $\gnode_1 \gsBefore \gnode_0$ :
  \begin{enumerate}%[label=(\alph*)]
    \item \textbf{Store}
    \begin{enumerate}[label=(\alph*)]
      \item \rulename{Singleton stack}
      If $\lstack = [\ovalue]$,
      then \formalRuleLine $\ovalue \in \lresults$.

      \item \rulename{Expression Assignment}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \oexpr, \gtime}$,
         $\lstack = [\ovalvariable] \listConcat \lstack'$, and
         $\ovalue = \osFunc{Valueof}(\oexpr)$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

      \item \rulename{List Assignment}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \gtobrk \omemvariable_1, \ldots, \omemvariable_n \gtcbrk, \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_n, \lInstr{Capture}_{3n-1}, \lInstr{Jump}\;\gnode_1, \ldots, \omemvariable_1, \lInstr{Capture}_{2}, \lInstr{Jump}\;\gnode_1,  \lInstr{List}_n] \listConcat \lstack')$.

      \item \rulename{Memory Allocation}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtalloc, \gtime}$,
         $\lstack = [\omemvariable] \listConcat \lstack'$, and
         $\omem = \osFunc{Alloc}(\gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtalloc, \gtime})$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem] \listConcat \lstack')$.
    \end{enumerate}

    \item \textbf{Heap search}
    \begin{enumerate}[label=(\alph*)]
      \item \rulename{Value Alias}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable_1 \gteq \ovalvariable_2, \gtime}$, and
         $\lstack = [\ovalvariable_1] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_2] \listConcat \lstack')$.

      \item \rulename{Memory Alias}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable_1 \gteq \omemvariable_2, \gtime}$, and
         $\lstack = [\omemvariable_1] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_2] \listConcat \lstack')$.

      \item \rulename{Bind}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtarrow \omemvariable \gtcbrc, \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_8, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_6, \lInstr{Jump}\;\gnode_1, \omemvariable, \lInstr{Capture}_4, $ \\
      $\lInstr{Jump}\;\gnode_1, \lInstr{Bind}] \listConcat \lstack')$.

      \item \rulename{Retrieve}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_1 \gtobrc \ovalvariable_2 \gtcbrc, \gtime}$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Project}] \listConcat \lstack')$.

      \item \rulename{List Indexing}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable_1 \gtobrk \ovalvariable_2 \gtcbrk, \gtime}$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Index}] \listConcat \lstack')$.

      \item \rulename{List Slicing}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable' \gtobrk \ovalvariable_1 \gtcolon \ovalvariable_2 \gtcbrk, \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable', \lInstr{Capture}_8, \lInstr{Jump}\;\gnode_1, \ovalvariable_1, \lInstr{Capture}_6, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_4, $ \\
      $\lInstr{Jump}\;\gnode_1, \lInstr{Slice}] \listConcat \lstack')$.

      \item \rulename{Store}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$, and
         $\lstack = [\omem, \lInstr{!}] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable, \lInstr{Capture}_2, \lInstr{Jump} \; \gnode_0, \lInstr{Alias?}] \listConcat \lstack)$.

      \item \rulename{Get}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \gtget \omemvariable}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable, \lInstr{Capture}_1, \lInstr{Jump} \; \gnode_0, \lInstr{!}] \listConcat \lstack')$.

      \item \rulename{Is}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \omemvariable_1 \gtis \omemvariable_2 , \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \omemvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_1, \lInstr{Is}] \listConcat \lstack')$.
    \end{enumerate}

    \item \textbf{Operations}
    \begin{enumerate}[label=(\alph*)]
      \item \rulename{Unary Operation}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ounop \ovalvariable' , \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable', \lInstr{Capture}_2, \lInstr{Jump}\;\gnode_0, \lInstr{Unop}] \listConcat \lstack')$.

      \item \rulename{Binary Operation}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable_1 \obinop \ovalvariable_2 , \gtime}$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_1, \lInstr{Capture}_5, \lInstr{Jump}\;\gnode_1, \ovalvariable_2, \lInstr{Capture}_3, \lInstr{Jump}\;\gnode_0, \lInstr{Binop}] \listConcat \lstack')$.
    \end{enumerate}

    \item \textbf{Leave Block}
    \begin{enumerate}[label=(\alph*)]
      % \item \rulename{Skip While}
      % If $\gnode_1 = \gsLR{\ostmt, \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc$, and
      %    $\gnode_0 = \gsLR{\gsadvance [\ostmt] [_1], \gtime_0}$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime_1}, \lstack)$.

      \item \rulename{Leave If/While/Try}
      If $\gnode_1 = \gsLR{\ostmt, \gtime_1}$ where $\ostmt$ %= \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc$,
         is an if/while/try statement,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      % \item \rulename{If Block Top (unbound \ovalvariable)}
      % If $\gnode_1 = \gsLR{\ostmt, \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$,
      %    $\gsLR{\gstate, \gtime_1 \tminus} \osBefore \gnode_1$, and
      %    $\lstack = [\ovalvariable] \listConcat \lstack'$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \tnote{In the cases where we lookup memloc, just follow the cfg loop.}

      % \item \rulename{Ifresult \ovalvariable \;(bound)}
      % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
      %    $\gnode_0 = \gsLR{\gsadvance [\olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$, and
      %    $\lstack = [\ovalvariable] \listConcat \lstack'$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.
      %
      % \item \rulename{Ifresult \ovalvariable \;(unbound)}
      % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
      %    $\gnode_0 = \gsLR{\gsadvance [\olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$,
      %    $\lstack = [\ovalvariable''] \listConcat \lstack'$, and
      %    $\ovalvariable'' \neq \ovalvariable$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc, \gtime'}, \lstack)$.
      %
      % \item \rulename{Ifresult \omemvariable \;(bound)}
      % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
      %    $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$, and
      %    $\lstack = [\omemvariable] \listConcat \lstack'$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.
      %
      % \item \rulename{Ifresult \omemvariable \;(unbound)}
      % If $\gnode_1 = \gsLR{\gsifresult [\ostmt], \gtime_1}$, \\
      %    $\gnode_0 = \gsLR{\gsadvance[\olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc] ['], \gtime_0}$,
      %    $\lstack = [\omemvariable'] \listConcat \lstack'$, and
      %    $\omemvariable' \neq \omemvariable$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc, \gtime'}, \lstack)$.

      \item \rulename{Function Variable Search \;(argument)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar, \gtime_1}$,
         $\gnode_0 = \gsLR{\ostmt, \gtime_0}$, \\
         $\ostmt \osUnder \olbl \gtcolon \gtlet \ovalvariable' \gteq \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1$, and
         $\lstack = [\ovalvariable'_i] \listConcat \lstack'$ where $1 \leq i \leq n$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable_i] \listConcat \lstack')$.

      \item \rulename{Function Variable Search \;(heap lookup)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar, \gtime_1}$,
         $\gnode_0 = \gsLR{\ostmt, \gtime_0}$, \\
         $\ostmt \osUnder \olbl \gtcolon \gtlet \ovalvariable' \gteq \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1$, and
         $\lstack = [\omem] \listConcat \lstack'$
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Function Variable Search \;(free variable)}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar, \gtime_1}$,
         $\gnode_0 = \gsLR{\ostmt, \gtime_0}$, \\
         $\ostmt \osUnder \olbl \gtcolon \gtlet \ovalvariable' \gteq \gtfun \gtopar \ovalvariable'_1, \ldots, \ovalvariable'_n \gtcpar \gtarrow \otstmts'_1$,
         $\lstack \neq [\ovalvariable'_i] \listConcat \lstack'$ where $1 \leq i \leq n$ and $\lstack \neq [\omem] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable, \lInstr{Capture}_1, \lInstr{Drop}] \listConcat \lstack)$.
    \end{enumerate}

    \item \textbf{Enter Block}
    \begin{enumerate}[label=(\alph*)]

      \item \rulename{Enter If block \ovalvariable}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

      \item \rulename{Enter If block \omemvariable}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

      \item \rulename{Enter function block}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

    \end{enumerate}

    \item \textbf{Stack Instructions}
    \begin{enumerate}[label=(\alph*)]
      \item \rulename{Capture Rule}
      If $\lstack = [\lresult, \lInstr{Capture}_n, \lstackelt_1, \ldots, \lstackelt_n] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lstackelt_1, \ldots, \lstackelt_n, \lresult] \listConcat \lstack')$.

      \item \rulename{Jump Rule}
      If $\lstack = [\lInstr{Jump} \;\gnode] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode, \lstack')$.

      \item \rulename{Drop Rule}
      If $\lstack = [\lInstr{Drop}, \lstackelt] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack')$.

      \item \rulename{Bind Rule}
      If $\lstack = [\lInstr{Bind}, \ovalue_1, \ovalue_2, \omem] \listConcat \lstack'$,
      and
         $\ovalue_1 = \obinding, \ovalue_2 \in \mathbb{S}, \obinding' = \obinding[\ovalue_2 \mapsto \omem]$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\obinding'] \listConcat \lstack')$.

      \item \rulename{Project Rule}
      If $\lstack = [\lInstr{Project}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
         $\ovalue_1 = \obinding, \ovalue_2 \in \mathbb{S}, \omem = \ovalue_1[\ovalue_2]$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem] \listConcat \lstack')$.

      \item \rulename{List Rule}
      If $\lstack = [\lInstr{List}_n, \omem_1, \ldots, \omem_n] \listConcat \lstack'$, and
         $\ovalue = [\omem_1, \ldots, \omem_n]_{n+1}$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

      \item \rulename{Index Rule}
      If $\lstack = [\lInstr{Index}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
        $\ovalue_1 = [\omem_1, \ldots, \omem_n]_k,
        L = $ \\
        $
        \begin{cases}
          [\omem_i] \text{ or } [\;], \omem_i \in \ovalue_1, & \text{if } \ovalue_2 = \gtintplus \cr
          [\;], & \text{if } \ovalue_2 = \gtintminus \cr
          [\omem_1], & \text{if } \ovalue_2 = \gtintzero
        \end{cases},
        $
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, L \listConcat \lstack')$.

      \item \rulename{Index Rule (imprecise)}
      If $\lstack = [\lInstr{Index}, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
         $\ovalue_1  = \osBag{\omem_1, \ldots, \omem_n},
         L = $ \\
         $
         \begin{cases}
           [\omem_i] \text{ or } [\;], \omem_i \in \ovalue_1, & \text{if } \ovalue_2 = \gtintplus \cr
           [\;], & \text{if } \ovalue_2 = \gtintminus \cr
           [\omem_i], \omem_i \in \ovalue_1, & \text{if } \ovalue_2 = \gtintzero
         \end{cases},
         $
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, L \listConcat \lstack')$.

      \item \rulename{Slice Rule (precise)}
      If $\lstack = [\lInstr{slice}, \ovalue, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
         $\ovalue = [\omem_1, \ldots, \omem_n]_k,
        %  p =
        %  \begin{cases}
        %    \ovalue_1, & \text{if } \ovalue_1 \in \mathbb{Z} \cr
        %    0, & \text{if } \ovalue_1 = \osnone
        %  \end{cases}, \\
        %  q =
        %  \begin{cases}
        %    \ovalue_2 - 1, & \text{if } \ovalue_2 \in \mathbb{Z} \cr
        %    n, & \text{if } \ovalue_2 = \osnone
        %  \end{cases},
        %  q \le p,
        %  \ovalue' = [\omem_p, \ldots, \omem_q]_k,
        %  k = q-p+1$,
        \ovalue' = \osFunc{PreciseSlice}(\ovalue,\ovalue_1,\ovalue_2)$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue'] \listConcat \lstack')$.

      \item \rulename{Slice Rule (imprecise)}
      If $\lstack = [\lInstr{slice}, \ovalue, \ovalue_1, \ovalue_2] \listConcat \lstack'$, and
         $\ovalue = \osBag{\omem_1, \ldots, \omem_n},
        %  \ovalue_1 \le \ovalue_2,
        %  \omem_i, \ldots, \omem_j \in \ovalue,
        %  \ovalue' = \osBag{\omem_i, \ldots, \omem_j}$,
        \ovalue' = \osFunc{ImpreciseSlice}(\ovalue,\ovalue_1,\ovalue_2)$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue'] \listConcat \lstack')$.

      % \item \rulename{List k}
      % If $\lstack = [\omem_p, \ldots, \omem_q, \lInstr{List}_k] \listConcat \lstack'$, and
      % $\ovalue = [\omem_p, \ldots, \omem_q]_k$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.
      %
      % \item \rulename{Bag}
      % If $\lstack = [\omem_i, \ldots, \omem_j, \lInstr{Bag}] \listConcat \lstack'$, and
      % $\ovalue = \osBag{\omem_i, \ldots, \omem_j}$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

      \item \rulename{Is Alias}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$, and
         $\lstack = [\lInstr{Alias?}, \omem, \omem, \lInstr{!}] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable] \listConcat \lstack')$.

      \item \rulename{Not Alias}
      If $\gnode_1 = \gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$,
         $\lstack = [\lInstr{Alias?}, \omem, \omem', \lInstr{!}] \listConcat \lstack'$, and
         $\omem \neq \omem'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omem', \lInstr{!}] \listConcat \lstack')$.

      \item \rulename{Unop Rule \ovalue}
      If $\lstack = [\lInstr{Unop}, \ovalue] \listConcat \lstack'$,
         $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ounop \ovalvariable' , \gtime}$, and
         $\ovalue' = \osFunc{UnaryOperation}(\ounop, \ovalue)$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue'] \listConcat \lstack')$.

      \item \rulename{Binop Rule \ovalue}
      If $\lstack = [\lInstr{Binop}, \ovalue_1, \ovalue_2] \listConcat \lstack'$,
         $\gnode_1 = \gsLR{\olbl \gtcolon \gtlet \ovalvariable \gteq \ovalvariable_1 \obinop \ovalvariable_2, \gtime}$, and
         $\ovalue = \osFunc{BinaryOperation}(\obinop, \ovalue_1, \ovalue_2)$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.

      \item \rulename{Trace Answer}
      If $\lstack = [\lInstr{Answer}] \listConcat \lstack'$, and
         $\gnode_1 = \gsLR{\gsreturn[\ostmt], \gtime'} \;|\; \gsLR{\gsifresult[\ostmt], \gtime'} \;|\;$ \\ $\gsLR{\gsraise[\ostmt], \gtime'}$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Get Answer \ovalvariable}
      If $\lstack = [\lInstr{Answer}] \listConcat \lstack'$, and
         $\gnode_1 = \gsLR{\olbl \gtcolon \gtifresult \ovalvariable, \gtime}$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalvariable] \listConcat \lstack')$.

      \item \rulename{Get Answer \omemvariable}
      If $\lstack = [\lInstr{Answer}] \listConcat \lstack'$, and
         $\gnode_1 = \gsLR{\olbl \gtcolon \gtreturn \omemvariable, \gtime} \;|\; \gsLR{\olbl \gtcolon \gtraise \omemvariable, \gtime} \;|\; $ \\
         $\gsLR{\olbl \gtcolon \gtifresult \omemvariable, \gtime}$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\omemvariable] \listConcat \lstack')$.

      \item \rulename{Start Tracing Raise}
      If $\gnode_1 = \gsLR{\gsraise[\ostmt]['], \gtime_1}$,
         $\gnode_0 = \gsLR{\ostmt', \gtime_0}$, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\lInstr{Answer}] \listConcat \lstack')$.

      \item \rulename{Start Tracing Raise (unbound)}
      If $\gnode_1 = \gsLR{\gsraise[\ostmt]['], \gtime_1}$,
         $\gnode_0 = \gsLR{\ostmt', \gtime_0}$, and
         $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \! is not of form \omemvariable,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Is Rule \omem}
      If $\lstack = [\lInstr{Is}, \omem_1, \omem_2] \listConcat \lstack'$, and
         \begin{flalign*}
           \ovalue =
           \begin{cases}
             \ostrue, & \text{if } \omem_1 = \omem_2 \\
             \osfalse, & \text{if } \omem_1 \neq \omem_2,
           \end{cases}
         \end{flalign*}
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, [\ovalue] \listConcat \lstack')$.
    \end{enumerate}

    \item \textbf{Skip}
    \begin{enumerate}
      \item \rulename{Skip \ovalvariable \;assignments with \omemvariable}
      If $\gnode_1$ is an \ovalvariable \! assignment clause, and
         $\lstack = [\omemvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Skip \omemvariable \;assignments with \ovalvariable}
      If $\gnode_1$ is an \omemvariable \! assignment clause, and
         $\lstack = [\ovalvariable] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Skip \ovalvariable \;assignments with \ovalvariable'}
      If $\gnode_1$ is an \ovalvariable \! assignment clause, and
         $\lstack = [\ovalvariable'] \listConcat \lstack'$ where $\ovalvariable \neq \ovalvariable'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Skip \omemvariable \;assignments with \omemvariable'}
      If $\gnode_1$ is an \omemvariable \! assignment clause, and
         $\lstack = [\omemvariable'] \listConcat \lstack'$ where $\omemvariable \neq \omemvariable'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Dereference}
      If $\gnode_1$ is not of form $\gsLR{\olbl \gtcolon \gtstore \omemvariable \; \ovalvariable}$, and
         $\lstack = [\omem, \lInstr{!}] \listConcat \lstack'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Skip Advance}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt$ does not create a new block,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Skip Advance If \ovalvariable}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \ovalvariable \gteq \gtif \ovalvariable' \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$,
      and
         $\lstack = [\ovalvariable'] \listConcat \lstack'$ where $\ovalvariable \neq \ovalvariable'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.

      \item \rulename{Skip Advance If \omemvariable}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtlet \omemvariable \gteq \gtif \ovalvariable \gtthen \gtobrc \ostmts_1 \gtcbrc \gtelse \gtobrc \ostmts_2 \gtcbrc$, and
         $\lstack = [\omemvariable'] \listConcat \lstack'$ where $\omemvariable \neq \omemvariable'$,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.

      \item \rulename{Skip while}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc$, and
         $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \;is not of form \omem,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Skip function}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \gtlet \omemvariable \gteq \ovalvariable \gtopar \ovalvariable_1, \ldots, \ovalvariable_n \gtcpar$,
         $\lstack = [\lstackelt] \listConcat \lstack'$ where $\lstackelt \neq \omemvariable$, and
         \lstackelt \;is not of form \omem,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      \item \rulename{Skip advance from while}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$,
         $\gnode_0 = \gsLR{\olbl \gtcolon \gtwhile \omemvariable \gtdo \gtobrc \ostmts \gtcbrc, \gtime_1}$, and
         $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \;is not of form \omem,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gnode_1, \lstack)$.

      % \tnote{Add a lot more, and delete the Ifresult, etc. rules}

      \item \rulename{Skip Try/except}
      If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc$, and
         $\lstack = [\lstackelt] \listConcat \lstack'$ where \lstackelt \;is not of form \omem,
      then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.
      %
      % \item \rulename{Enter Try/except with \omemvariable}
      % If $\gnode_1 = \gsLR{\gsadvance [\ostmt] [], \gtime_1}$ where $\ostmt = \olbl \gtcolon \gttry \gtobrc \ostmts_1 \gtcbrc \gtexcept \omemvariable \gtobrc \ostmts_2 \gtcbrc$, and
      %    $\lstack = [\omemvariable] \listConcat \lstack'$,
      % then \formalRuleLine $\lresults \supseteq \osFunc{Lookup}(\ggraph, \gsLR{\ostmt, \gtime}, \lstack)$.
    \end{enumerate}
  \end{enumerate}
\end{definition}

\begin{definition}[Unary Operation]
  $\osFunc{UnaryOperation}(\ounop, \ovalue) = V$ for each of the following rows:
  \begin{flalign*}
  \begin{array}[t]{ c c | c }
   \ounop & \ovalue & V \\
   \hline
   % not
   \gtnot & \ostrue & \osfalse \\
   \gtnot & \osfalse & \ostrue \\
   % isfunc
   \gtisfunc & \text{function} & \ostrue \\
   \gtisfunc & \text{not function} & \osfalse \\
   % isint
   \gtisint & \in \mathbb{Z} & \ostrue \\
   \gtisint & \notin \mathbb{Z} & \osfalse \\
   % isbool
   \gtisbool & \in \mathbb{B} & \ostrue \\
   \gtisbool & \notin \mathbb{B} & \osfalse \\
  \end{array}
  \end{flalign*}
\end{definition}

\begin{definition}[Binary Operation]
  $\osFunc{BinaryOperation}(\obinop, \ovalue_1, \ovalue_2) = V$ for each of the following rows:
  \begin{flalign*}
  \begin{array}[t]{ c c c | l }
   \obinop & \ovalue_1 & \ovalue_2 & V \\
   \hline
   \gtintplus & \in \mathbb{Z} & \in \mathbb{Z} & \ovalue_1 + \ovalue_2 \\
   \gtintminus & \in \mathbb{Z} & \in \mathbb{Z} & \ovalue_1 - \ovalue_2 \\
   \gthaskey & \gsSet{\ovalue_2 \mapsto \ovalue, \ldots} & \in \mathbb{S} & \ostrue \\
   \gthaskey & \obinding \niton \ovalue_2 \mapsto \ovalue & \in \mathbb{S} & \osfalse \\
   \gtlstconcat & [\omem_m, \ldots, \omem_n] & [\omem_p, \ldots, \omem_q] & [\omem_m, \ldots, \omem_n, \omem_p, \ldots, \omem_q] \\
   \gtcmp & \ovalue & \ovalue & \ostrue \\
   \gtcmp & \ovalue & \ovalue' \neq \ovalue & \osfalse \\
  \end{array}
  \end{flalign*}
\end{definition}

\begin{definition}[Precise Slice]
  $\osFunc{PreciseSlice}(\ovalue, \ovalue_1, \ovalue_2)$ returns the content of row $\ovalue_1$, column $\ovalue_2$ for $\ovalue=[\omem_1,\ldots,\omem_n]_k$:
  \begin{flalign*}
  \begin{array}[t]{ c | c c c c }
   & \gtintplus & \gtintminus & \gtintzero & \osnone \\
   \hline
   \gtintplus & [\omem_i,\ldots,\omem_j]_k, 1 \le i \le j \le n & \text{---} & \text{---} & [\omem_i,\ldots,\omem_n]_k, 1 \le i \le n\\
   \gtintminus & \text{---} & \text{---} & \text{---} & \text{---} \\
   \gtintzero & [\omem_1,\ldots,\omem_i]_k, 1 \le i \le n & \text{---} & [\omem_1]_k & \ovalue \\
   \osnone & [\omem_1,\ldots,\omem_i]_k, 1 \le i \le n & \text{---} & [\omem_1]_k & \ovalue \\
  \end{array}
  \end{flalign*}
\end{definition}

\begin{definition}[Imprecise Slice]
  $\osFunc{ImpreciseSlice}(\ovalue, \ovalue_1, \ovalue_2)$ returns the content of row $\ovalue_1$, column $\ovalue_2$:
  \begin{flalign*}
  \begin{array}[t]{ c | c c c c }
   & \gtintplus & \gtintminus & \gtintzero & \osnone \\
   \hline
   \gtintplus & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue & \text{---} & \text{---} & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue \\
   \gtintminus & \text{---} & \text{---} & \text{---} & \text{---} \\
   \gtintzero & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue & \text{---} & \osBag{\omem_1} & \ovalue \\
   \osnone & \osBag{\omem_i,\ldots,\omem_j} \subseteq \ovalue & \text{---} & \osBag{\omem_1} & \ovalue \\
  \end{array}
  \end{flalign*}
\end{definition}
\tnote{In real life, we simply take the entire list. Slice does not exist. "None" is not supported now. }
